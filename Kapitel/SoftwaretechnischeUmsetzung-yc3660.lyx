#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass dlrreport
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Implementierung
\end_layout

\begin_layout Standard
In diesem Kapitel soll die Softwaretechnische Umsetzung des Algorithmus
 zur Bildung der Korrelationsmatrix dargestellt werden.
 Da in den Algorithmen sehr viele Matrix Operationen verwendet werden, wurde
 eine Matrix Klasse eingeführt.
 Diese wird am Anfang des Kapitels erläutert.
 
\end_layout

\begin_layout Standard
Im nächsten Abschnitt wird dann die Bildungsvorschrift der Matrix gezeigt
 und darauf folgend eine häufig genutzte Korrelationsfunktion und deren
 softwaretechnische Umsetzung erläutert.
 
\end_layout

\begin_layout Standard
Der letzter Abschnitt zeigt dann den eigentlichen Algorithmus zur Bildung
 der Korrelationsmatrix.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

- Implementierung
\end_layout

\begin_layout Plain Layout

	- SoftwareDesign 
\end_layout

\begin_layout Plain Layout

		- AutoOpti Interface
\end_layout

\begin_layout Plain Layout

		- Korrelationsfunktionen und Matrix für alle Verfahren
\end_layout

\begin_layout Plain Layout

		- Training
\end_layout

\begin_layout Plain Layout

		- UMLs und Code
\end_layout

\begin_layout Plain Layout

	- Algorithmische Effizienz steigern
\end_layout

\begin_layout Plain Layout

		- Vorwort (warum usw.
 GEK große Matrizen und COkriging viele partielle Ableitungen)
\end_layout

\begin_layout Plain Layout

		- Wiederverwenden von Korrelationswerten
\end_layout

\begin_layout Plain Layout

		- SSE Beschleunigung Korrelationsfunktionen
\end_layout

\begin_layout Plain Layout

		- Minimierungsverfahren beleuchten QuasiNewton / RPROP
\end_layout

\begin_layout Plain Layout

		- Verschiedenen Initialisierungen / Ultra Restart
\end_layout

\begin_layout Plain Layout

		- Filtern von unwichtigen Samples
\end_layout

\begin_layout Plain Layout

		- Inverse durch Gleichungssystem ersetzen
\end_layout

\begin_layout Plain Layout

		- Approximation der Spur
\end_layout

\begin_layout Plain Layout

		- Rückwärtsdifferenzierung der partiellen Ableitungen
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	- Verwendung von GPUs
\end_layout

\begin_layout Plain Layout

		- GPU Computing vorstellen (Flops/Euro unschlagbar, zukünftige Pascal
 Generation wird die stärkste seinm Power Consumption vergleichen)
\end_layout

\begin_layout Plain Layout

		- CuBlas
\end_layout

\begin_layout Plain Layout

		- Transferproblematik
\end_layout

\begin_layout Plain Layout

		- Symmetrie Copy Kernel
\end_layout

\begin_layout Plain Layout

		- K80 MultiGPU notwendig, ungeeignet für das Kriging
\end_layout

\begin_layout Plain Layout

		- CuBlasXT kann nicht sinnvoll verwendet werden, 
\end_layout

\begin_layout Plain Layout

 		- Mehrere Kriging Trainings auf verschiedenen / gleichen GPUs als Ausweg
\end_layout

\begin_layout Plain Layout

		- AdjointChodec als Beispiel
\end_layout

\begin_layout Plain Layout

		 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Softwaredesign
\end_layout

\begin_layout Subsection
Klasse zur Berechnung von Matrix Operationen
\begin_inset CommandInset label
LatexCommand label
name "sec:MatrixKlasse"

\end_inset


\end_layout

\begin_layout Standard
Da für das Training und Vorhersagen des Kriging Ersatzmodells hauptsächlich
 Matrix Operationen verwendet werden, ist es sinnvoll diese in einer Klasse
 zusammenzufassen.
 Außerdem sind für die Matrix Operationen verschiedene Implementierungen
 möglich, z.B.
 könnte es eine Klasse für OpenMP parallelisierte Operationen geben und
 eine andere Klasse wo dieselben Operationen über eine GPU (Graphics Processing
 Unit) berechnet werden.
 Daher werden die gemeinsamen Elemente in einer Superklasse Matrix zusammengefas
st, siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLMatrix"

\end_inset

.
 In dem UML Diagramm sind noch zwei andere Klassen erkennbar, eine Superklasse
 SaveableOnServer und eine Spezialisierung namens OpenMPMatrix.
\end_layout

\begin_layout Standard
SaveableOnServer sollte in einer modernen objektorientierten Programmiersprache
 wie z.B.
 Java ein kontextspezifisches anbietendes Client/Server Interface 
\begin_inset CommandInset citation
LatexCommand citep
key "ModProg"

\end_inset

 sein.
 Dies ist zur Verdeutlichung nochmals als UML Diagramm in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLMatrixInterface"

\end_inset

 dargestellt.
 In C++ muss ersatzweise eine abstrakte Klasse verwendet werden.
 Das Interface SaveableOnServer muss implementiert werden, um in späteren
 Anwendungen eine prozessweite Parallelisierung über eine Parallelisierungsbibli
othek vornehmen zu können.
 Diese Parallelisierungsbibliothek wurde ebenfalls im Institut für Antriebstechn
ik entwickelt, allerdings außerhalb des Rahmens dieser Masterarbeit und
 soll daher nicht näher erläutert werden.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/UML/Matrix.png
	lyxscale 80
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:UMLMatrix"

\end_inset

UML Diagramm der Matrixklasse mit einer Spezialisierung (OpenMPMatrix) und
 der abstrakten Klasse SaveableOnServer, welche prinzipiell ein Interface
 darstellt.
 Interfaces weden in C++ jedoch nicht unterstützt, daher wird eine abstrakte
 Klasse verwendet.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Matrix Klasse besitzt genau drei Attribute, welche als protected deklariert
 sind.
 Das erste Attribut 
\begin_inset Quotes eld
\end_inset

elements
\begin_inset Quotes erd
\end_inset

 stellt ein eindimensionales Array dar und beinhaltet die Matrixelemente.
 Da eine Matrix einem zweidimensionalen Array entspricht, wird das eindimensiona
le Array auf ein zweidimensionales Array übersetzt.
 Dies wird gemacht, da so ein linearer Aufbau des Arrays garantiert gewährleiste
t wird und dies kann in einigen Systemen Geschwindigkeitsvorteile bringen.
 Der Aufbau des Array 
\begin_inset Quotes eld
\end_inset

elements
\begin_inset Quotes erd
\end_inset

 sieht wie folgt aus:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Elementnr.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Funktion
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zeilenanzahl
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Spaltenanzahl
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dummy
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dummy
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 bis Spaltenanzahl 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Erste Zeile der Matrix
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Spaltenanzahl bis x*Spaltenanzahl
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x'te Zeile der Matrix
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Die Anzahl der Zeilen und Spalten sind also ebenfalls im Array gespeichert.
 Dies wird gemacht, um die Daten als einen Block zu serialisieren und damit
 als einen Datenstrom über das Netzwerk verschicken zu können.
 
\end_layout

\begin_layout Standard
Zusätzlich sind die Anzahl der Zeilen und Spalten als Attribut in der Klasse
 Matrix gespeichert, da auf diese Attribute sehr oft lesend zugegriffen
 wird und der Zugriff auf eine einzelne Variable schneller ist, als der
 Zugriff auf die beiden ersten Elemente des Arrays.
 Da die Attribute nur über Getter und Setter Methoden zugreifbar sind, kann
 immer gewährleistet werden, dass diese identisch sind.
 Die Übersetzung auf ein zweidimensionales Array wird dadurch erreicht,
 dass man den 
\begin_inset Quotes eld
\end_inset

[]
\begin_inset Quotes erd
\end_inset

 Operator der Matrix Klasse in folgender Weise überlädt:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},tabsize=4"
inline false
status open

\begin_layout Plain Layout

T* operator[] (int row) {
\end_layout

\begin_layout Plain Layout

	return this->elements + 4 + (row * this->getColumnSize());
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bei einem Zugriff auf den 
\begin_inset Quotes eld
\end_inset

[]
\begin_inset Quotes erd
\end_inset

 Operator wird also ein Zeiger auf das erste Element der entsprechenden
 Zeile zurückgegeben.
 Dies wird in C++ als ein Array interpretiert und das Array kann über den
 Operator 
\begin_inset Quotes eld
\end_inset

[]
\begin_inset Quotes erd
\end_inset

 die entsprechende Spalte liefern.
 Die Verwendung ist also dieselbe wie bei einem 
\begin_inset Quotes eld
\end_inset

normalen
\begin_inset Quotes erd
\end_inset

 zweidimensionalen C Array oder C++ Vektor.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/UML/MatrixInterface.png
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:UMLMatrixInterface"

\end_inset

UML Diagramm der Matrix Klasse, wobei SaveableOnServer in diesem Fall durch
 ein kontextspezifisches Client Server Interface dargestellt wird.
\end_layout

\end_inset


\end_layout

\end_inset

Zusätzlich gibt es noch die Methoden saveAsAscii und parseAscii, welche
 es ermöglichen die Daten in eine Textdatei zu speichern und auszulesen.
 Zur Änderung der Größe der Matrix gibt es die Methode resiz
\begin_inset Formula $ $
\end_inset

e, welche die Matrix entsprechend vergrößert oder verkleinert.
 Die Methode appendMatrix hängt eine Matrix an die bestehende an und zwar
 an die letzte Zeile.
 Dies geht also nur, wenn die Spaltenanzahl identisch ist.
 Um eine Submatrix als Block in eine bestehende Matrix zu integrieren, gibt
 es die Funktion insertSubMatrix.
 Diese fügt die als Parameter angegebene Matrix in die Bestehende ein.
 
\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLMatrix"

\end_inset

 ist zusätzlich noch eine Spezialisierung namens OpenMPMatrix eingezeichnet,
 diese nutzt OpenMP zur Thread Parallelisierung und wird auch für das Kriging
 Modell verwendet.
 Im Wesentlichen wird in der Klasse OpenMPMatrix die Superklasse Matrix
 durch verschiedene Operatoren zur Addition, Multiplikation usw.
 erweitert und stellt so alle nötigen Operationen für das Kriging Modell
 bereit.
 
\end_layout

\begin_layout Subsection
Korrelationsfunktionen
\begin_inset CommandInset label
LatexCommand label
name "sec:Korrelationsfunktionen"

\end_inset


\end_layout

\begin_layout Standard
Um die Korrelationsmatrix aufzustellen, ist es nötig, einen Korrelationswert
 zwischen allen bekannten Stützstellen zu berechnen und auch zwischen den
 Stützstellen und deren partiellen Ableitungen.
 Um diesen Wert zu berechnen, wird eine Korrelationsfunktion verwendet.
 Wie bereits in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Bildungsvorschrift-der-KorrelatiGEk"

\end_inset

 beschrieben, kann die Korrelationsfunktion nur angenähert werden und ist
 abhängig vom Abstand zweier Stützstellen zueinander.
 
\end_layout

\begin_layout Standard
In diesem Abschnitt soll eine sehr häufig verwendete Korrelationsfunktion
 beschrieben und deren softwaretechnische Umsetzung gezeigt werden.
 Da diese Korrelationsfunktion einer gaußschen Normalverteilung sehr ähnlich
 ist, wird diese im Folgenden als gaußsche Korrelationsfunktion bezeichnet.
 Die Formel sieht wie folgt aus:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
c\left(\vec{x}_{1},\vec{x}_{2}\right) & =e^{-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(e^{\theta_{l}}\left|x_{1l}-x_{2l}\right|^{2}\right)}\label{eq:GaussCorrelationFunction}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Die Vektoren 
\begin_inset Formula $\vec{x}_{1},\vec{x}_{2}\in\mathbb{R^{\mathrm{k}}}$
\end_inset

 stellen hier die Ortsvektoren der Stützstellen dar.
 Die Funktion liefert immer Werte zwischen Null und Eins, wobei eine Eins
 bei zwei identischen Stützpunken und eine Null bei unendlich weit entfernten
 Stützstellen herauskommen würde.
 Der Vektor 
\begin_inset Formula $\vec{\theta}\in\mathbb{R^{\textrm{k}}}$
\end_inset

 (auch Hyperparameter genannt) legt fest, wie stark die Korrelation mit
 steigendem Abstand der Stützstellen zueinander abfällt, wobei ein hoher
 Wert einen stärkeren Abfall bewirkt.
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispiel-einer-Gauss"

\end_inset

 ist eine beispielhafte Korrelationsfunktion mit zwei verschiedenen 
\begin_inset Formula $\theta$
\end_inset

 Werten zu sehen, wobei die Stützstellen in der Abbildung jeweils nur eine
 freie Variable haben.
 Auf der X-Achse des Diagramms ist die Differenz der beiden Stützstellen
 zueinander aufgetragen und auf der Y-Achse der entsprechende Korrelationswert.
 Die rote durchgezogene Kurve zeigt die Korrelationsfunktion mit einem 
\begin_inset Formula $\theta=0.01$
\end_inset

 und die grüne gestrichelte Kurve hat ein 
\begin_inset Formula $\theta=0.1$
\end_inset

.
 Nimmt man eine Differenz der beiden Stützstellen von z.B.
 
\begin_inset Formula $\Delta x=-5$
\end_inset

 an, dann ergeben sich für einen Hyperparameter von 
\begin_inset Formula $\theta=0.01$
\end_inset

 ein Korrelationswert von 0.53 und für 
\begin_inset Formula $\theta=0.1$
\end_inset

 ein Korrelationswert von 0.08.
 In dem einen Fall wird also eine stärkere Abhängigkeit der beiden Stützstellen
 angenommen und im anderen Fall eine sehr schwache Abhängigkeit.
 Für das gesamte Kriging Modell gibt es genau einen 
\begin_inset Formula $\vec{\theta}$
\end_inset

 Vektor, die Bestimmung dieser Werte ist Aufgabe des Trainings.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/CorrelatoinFunction.eps
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-einer-Gauss"

\end_inset

Beispiel einer Gauss Korrelationsfunktion mit einer freien Variable und
 zwei unterschiedlichen 
\begin_inset Formula $\theta$
\end_inset

 Einstellungen und deren Einfluss auf den Korrelationswert 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispiel-einer-Gauss3D"

\end_inset

 wird eine Korrelationsfunktion zwischen zwei Stützstellen 
\begin_inset Formula $\vec{x}_{1},\vec{x}_{2}\in\mathbb{R^{\mathrm{k}}}$
\end_inset

 mit zwei freien Variablen 
\begin_inset Formula $k=2$
\end_inset

 gezeigt.
 Für diesen Fall hat der Vektor 
\begin_inset Formula $\vec{\theta}\in\mathbb{R^{\textrm{k}}}$
\end_inset

 ebenfalls zwei Komponenten.
 Auf der X-Achse ist die Differenz zwischen den beiden ersten Komponenten
 der beiden Stützstellen aufgetragen, auf der Y-Achse die Differenz zwischen
 den zweiten Komponenten der Stützstellenvektoren und die Z-Achse zeigt
 den entsprechenden Korrelationswert.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/CorrelatoinFunction3D.eps
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-einer-Gauss3D"

\end_inset

Beispiel einer Gauss Korrelationsfunktion mit zwei freien Variablen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Die programmiertechnische Umsetzung ist sehr simpel und sieht wie folgt
 aus:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset listings
lstparams "basicstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

for(size_t i=0; i<point1.getNumVars() ; i++){
\end_layout

\begin_layout Plain Layout

    correl += fmath::exp(thetas[i]) * sqr(point1.getVarsRef(i) - point2.getVarsRef
(i)); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

correl=fmath::exp(-0.5*correl);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Da diese Funktion während eines Trainings sehr häufig aufgerufen wird, macht
 es Sinn, diese zu beschleunigen.
 Um dies zu erreichen, wurden SSE (Streaming SIMD Extensions) CPU Befehle
 verwendet.
 Die Lesbarkeit des Codes leidet zwar recht stark darunter, da sich diese
 Methode zukünftig aber kaum noch ändern wird, ist dies vertretbar.
\end_layout

\begin_layout Subsubsection*
Streaming SIMD Extensions (SSE)
\begin_inset CommandInset label
LatexCommand label
name "subsec:Streaming-SIMD-Extensions"

\end_inset


\end_layout

\begin_layout Standard
\noindent
Die Streaming SIMD Extensions (SSE) sind eine von Intel entwickelte Befehlssatze
rweiterung der x86-Architektur.
 Mit Einführung des Pentium-III-(Katmai)-Prozessors wurde diese 1999 vorgestellt.
 Aufgabe der SSE Befehle ist es Programme durch Parallelisierung auf Instruktion
slevel zu beschleunigen, auch SIMD (Single Instruction Multiple Data) genannt.
 Die SSE-Befehlssatzerweiterung umfasst ursprünglich 70 Instruktionen und
 8 neue Register, genannt XMM0 bis XMM7.
 Ursprünglich wurden die 128
\begin_inset space ~
\end_inset

Bit breiten Register allerdings nicht in einem Schritt verarbeitet.
 Bei heutigen CPUs (z.B.
 Intel Core CPUs) werden die Register in einem Schritt verarbeitet, zudem
 wurde die Anzahl der Register von 8 auf 16 erhöht.
 
\end_layout

\begin_layout Standard
Es gibt zahlreiche Umsetzungen der SSE Befehle.
 Diese reichen von SSE bis SSE5, wobei ab SSE3 AMD und Intel jeweils eigene
 Implementationen der SSE Architektur vornahmen.
 Der Nachfolger von SSE heißt AVX (Advanced Vector Extensions) und verbreitert
 die Register auf 16x
\begin_inset space ~
\end_inset

256
\begin_inset space ~
\end_inset

Bit.
 
\end_layout

\begin_layout Standard
Innerhalb dieser Arbeit wurden nur SSE Befehle verwendet, da diese praktisch
 von allen aktuellen CPUs und auch Compilern unterstützt werden.
 Für die Verwendung von AVX sind relativ neue Kompiler und CPUs notwendig,
 dies kann bei einigen Kunden zu Problemen führen.
 Durch die 128
\begin_inset space ~
\end_inset

Bit Register können nun in einem Rechenschritt vier float (32
\begin_inset space ~
\end_inset

Bit) oder zwei double (64
\begin_inset space ~
\end_inset

Bit) Werte gleichzeitig verarbeitet werden.
 Um diese Funktionen zu nutzen, müssen im C++-Code spezielle SSE Befehle
 verwendet werden 
\begin_inset CommandInset citation
LatexCommand citep
key "AGN,INTEL"

\end_inset

.
 Das folgende Listing zeigt die Umsetzung der Gauss Korrelationsfunktion
 mit SSE Befehlen, wobei die Parallelisierung hier über die Hyperparameter
 gemacht wird.
 Diese Methode wird zur Berechnung der Einträge der Kovarianzmatrix verwendet
 und wird dementspchrend oft aufgerufen.
 Aus diesem Grund ist es sinnvoll diese Methode zu Beschleunigen.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},numbers=left,basicstyle={\scriptsize},tabsize=4"
inline false
status open

\begin_layout Plain Layout

__m128d correlSSE=_mm_setzero_pd();
\end_layout

\begin_layout Plain Layout

__m128d thetasExpSSE, point1SSE, point2SSE, pointDiffSSE;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

array thetasExpArray;
\end_layout

\begin_layout Plain Layout

array point1Array;
\end_layout

\begin_layout Plain Layout

array point2Array;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for(i=0; i<point1.getNumVars()-1 ; i+=2){
\end_layout

\begin_layout Plain Layout

		thetasExpSSE =_mm_load_pd(&(thetasExpArray[i]));
\end_layout

\begin_layout Plain Layout

		point1SSE =_mm_load_pd(&(point1Array[i]));
\end_layout

\begin_layout Plain Layout

		point2SSE =_mm_load_pd(&(point2Array[i]));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		pointDiffSSE = _mm_sub_pd(point1SSE,point2SSE);
\end_layout

\begin_layout Plain Layout

		pointDiffSSE = _mm_mul_pd(pointDiffSSE,pointDiffSSE);
\end_layout

\begin_layout Plain Layout

		pointDiffSSE = _mm_mul_pd( thetasExpSSE, pointDiffSSE  );
\end_layout

\begin_layout Plain Layout

		correlSSE = _mm_add_pd( correlSSE,  pointDiffSSE );
\end_layout

\begin_layout Plain Layout

} 	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

correlSSE = _mm_hadd_pd(correlSSE,correlSSE); 
\end_layout

\begin_layout Plain Layout

_mm_store_sd(&correl,correlSSE);
\end_layout

\begin_layout Plain Layout

for(; i<point1.getNumVars() ; i++) 	{
\end_layout

\begin_layout Plain Layout

		correl += thetasExp[0][i] * (point1.getVar(i) - point2.getVar(i))*(point1.getVar(
i) - point2.getVar(i));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

correl=fmath::expd(-0.5*corre);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In den Zeilen 1-2 werden verschiedene Variablen definiert vom Typ 
\begin_inset Quotes eld
\end_inset

__m128d
\begin_inset Quotes erd
\end_inset

, dieser Typ stellt ein 128 Bit großes SSE Datentypen dar und kann zwei
 64
\begin_inset space ~
\end_inset

Bit double Werte aufnehmen.
 Zudem wird die Variable correlSSE mithilfe der Funktion_mm_setzero_pd()
 auf 0 gesetzt.
 Die Zeilen 4-6 stellen Arrays dar, welche für die Berechnung der Korrelationsfu
nktion benötigt werden.
 Das Array thetasExpArray beinhaltet die berechneten Hyperparameter 
\begin_inset Formula $e^{\theta_{l}}$
\end_inset

.
 Da diese Werte für alle Einträge in der Kovarianzmatrix identisch sollten
 sie daher vor dem Belegen der Kovarianzmatrix berechnet werden.
 Danach werden die beiden Arrays initialisiert, welche die Ortsvariablen
 
\begin_inset Formula $\vec{x}_{1},\vec{x}_{2}\in\mathbb{R^{\mathrm{k}}}$
\end_inset

 beinhalten.
 Die darauffolgende for-Schleife iteriert über die Anzahl an freien Variablen.
 Der Zähler wird hier immer um den Wert 2 erhöht, da mit den SSE Routinen
 2 double Werte gleichzeitig berechnet werden können.
 In den Zeilen 9-11 werden 128Bit aus den Arrays an der Stelle i in die
 SSE Register übertragen.
 Aus diesem Grund muss der Speicher zwingend 128Bit Speicherausrichtung
 besitzen.
 
\end_layout

\begin_layout Paragraph
Einschub: Speicherausrichtung
\begin_inset CommandInset label
LatexCommand label
name "par:Einschub-Speicherausrichtung"

\end_inset


\end_layout

\begin_layout Standard
In aktuellen C++ Compilern wird eine Speicherausrichtung von 128Bit im Normalfal
l gewährleistet.
 Die folgende Tabelle soll die Speicherausrichtung und die damit entstehende
 Problematik beim Programmieren verdeutlichen:
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64Bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64Bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64Bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64Bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64Bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64Bit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
underbrace{128Bit aligned}$
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:128Bit-Speicherausrichtung"

\end_inset

128Bit Speicherausrichtung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die erste Zeile der Tabelle beschreibt den Index eines normalen Arrays mit
 6 Einträgen und jeder Eintrag hat die Größe eines 64Bit (z.B.
 double) Werts.
 Der Compiler garantiert in diesem Fall einen zusammenhängenden Speicher
 von 128Bit, dargstellt durch die dritte Zeile.
 
\end_layout

\begin_layout Standard
In Zeile 5 wird die Variable correlSSE mit der Funktion auf Null gesetzt.
 Da in einem Schritt immer zwei Befehle gleichzeitig ausgeführt werden,
 muss die Anzahl durch zwei teilbar sein.
 Ist dies nicht der Fall, muss der Rest mit normalen Befehlen durchgeführt
 werden.
 Zeile 7 setzt die Anzahl der Schleifendurchläufe auf die Anzahl der freien
 Variablen geteilt durch zwei.
 Ist die Anzahl der freien Variablen ungerade, wird eins subtrahiert und
 dann durch zwei geteilt.
 Die Zeilen 8-16 stellen die Summation aus der Gauss Formel dar.
 Zuerst wird in den Zeilen 9-10 zwei Werte der Stützstellen in die SSE Variablen
 geladen.
 Dies geschieht mit der Funktion _mm_loadu_pd().
 Als Parameter erwartet die Funktion eine Speicheradresse und transferiert
 dann 128
\begin_inset space ~
\end_inset

Bit ab dieser Adresse in die entsprechende SSE Variable.
 In den Zeilen 11-12 wird die Exponentialfunktion der Hyperparameter berechnet.
 Dies geschieht auf konventionelle Weise, da es keinen SSE Befehl für die
 Exponentialfunktion gibt.
 Die beiden berechneten Werte werden dann in Zeile 13 ebenfalls in eine
 SSE Variable geladen.
 Die Differenz der Stützstellenkomponenten wird anschließend in Zeile 14
 vorgenommen.
 Hier werden wie bereits erwähnt, direkt zwei Differenzen gleichzeitig berechnet.
 In Zeile 15 wird dann die Differenz quadriert, mit den Hyperparametern
 multipliziert und aufsummiert, alles mit SSE Befehlen.
 
\end_layout

\begin_layout Standard
Ist der Schleifendurchlauf beendet, wird in Zeile 17 das Ergebnis in eine
 normale Variable zurück transferiert und in den restlichen Zeilen wird
 (falls die Anzahl der freien Variablen nicht durch zwei teilbar war) das
 letzte Element mit konventionellen Methoden berechnet.
 Die gemessenen Geschwindigkeitsvorteile lagen bei ca.
 20
\begin_inset space ~
\end_inset

%
\begin_inset space ~
\end_inset

-
\begin_inset space ~
\end_inset

30
\begin_inset space ~
\end_inset

%.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Algorithmus zur Bildung der Korrelationsmatrix für alle Kriging Verfahren
\end_layout

\begin_layout Standard
Beim Aufstellen der Korrelationsmatrix müssen alle Korrelationen zwischen
 Membern berechnet werden.
 Ein Member wird durch die Klasse Point beschrieben, in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLPoint"

\end_inset

 ist das UML Diagramm der entsprechenden Klasse dargestellt.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/UML/point.eps
	lyxscale 40
	scale 17

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:UMLPoint"

\end_inset

UML Diagramm der Klasse Point, welche einen Member/Stützstelle beschreibt
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "PointKlasseAnfang"

\end_inset

Die Klasse verwendet zwei Template Parameter.
 Zum einen den Parameter B, dieser gibt den verwendeten Fließkommazahlentyp
 an und zum anderen gibt es den Parameter T, welcher den verwendeten Matrix
 Typ darstellt.
 Der Matrix Typ muss ein Subtyp der Matrix Klasse aus Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Korrelationsmatrix"

\end_inset

 sein.
 Die Point Klasse besteht aus vier Attributen und zwei öffentlichen Methoden.
 Das Attribut fit beschreibt den Funktionswert des Members.
 PartialDerivatives beinhaltet die vorgegebenen partiellen Ableitungen eines
 Members.
 Der Typ des Attributs ist eine map (Hashtabelle), wobei der Schlüssel die
 Nummer der Variable darstellt, nach der abgeleitet wurde.
 In vars werden die Variablenwerte des Members gespeichert, der Typ des
 Attributs ist eine Matrix.
 Eigentlich wird nur ein Vektor als Typ benötigt, da man aber gerne die
 Matrix Operationen nutzen möchte, wird vars als einspaltige Matrix verwendet,
 was letztlich wieder einem Vektor entspricht.
 Das Attribut type beinhaltet den Typ des Members, dies ist für Variable
 Fidelity Methods ( siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Andere-Kriging-Verfahren"

\end_inset

 ) wichtig.
 In diesem Attribut wird dann über einen Identifier angegeben, ob es sich
 z.B.
 um einen Member handelt, welcher mit hoher Güte berechnet wurde oder niedriger.
 
\end_layout

\begin_layout Standard
Eine Korrelationsfunktion soll zwischen zwei solcher Point Objekte einen
 Korrelationswert bestimmen.
 Daher macht es Sinn, eine gemeinsame abstrakte Superklasse einzuführen,
 der Aufbau ist in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

 dargestellt.
 Da jedes Point Objekt auch die partiellen Ableitungen enthält ist es sinnvoll,
 dass die Korrelationsfunktion alle Korrelationen zwischen zwei Point Objekten
 zurück gibt, also auch die Korrelationen zwischen partiellen Ableitungen
 und Funktionswerten.
 Zu diesem Zweck wird die Korrelationsmatrix durch Zeilen- und Spaltentausch
 umsortiert, um die Korrelationen zwischen zwei Point Objekten direkt als
 Submatrix in die Gesamtmatrix einzufügen:
\end_layout

\begin_layout Standard

\lang english
\begin_inset Formula 
\begin{equation}
\mathbf{R}=\left[\begin{array}{c|cccc}
 & Z\left(\vec{x}_{1}\right) & \frac{\partial Z\left(\vec{x}_{1}\right)}{\partial x_{1}^{1}} & Z\left(\vec{x}_{2}\right) & \frac{\partial Z\left(\vec{x}_{2}\right)}{\partial x_{1}^{1}}\\
\hline Z\left(\vec{x}_{1}\right) & c\left(\vec{x}_{1},\vec{x}_{1}\right) & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{1}\right)}{\partial x_{1}^{1}} & c\left(\vec{x}_{1},\vec{x}_{2}\right) & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{2}^{1}}\\
\frac{\partial Z\left(\vec{x}_{1}\right)}{\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{1}\right)}{\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{1}\right)}{\partial x_{1}^{1}\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{1}^{1}\partial x_{2}^{1}}\\
Z\left(\vec{x}_{2}\right) & c\left(\vec{x}_{2},\vec{x}_{1}\right) & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{1}\right)}{\partial x_{1}^{1}} & c\left(\vec{x}_{2},\vec{x}_{2}\right) & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{2}\right)}{\partial x_{2}^{1}}\\
\frac{\partial Z\left(\vec{x}_{2}\right)}{\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{1}\right)}{\partial x_{2}^{1}} & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{1}\right)}{\partial x_{2}^{1}\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{2}\right)}{\partial x_{2}^{1}} & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{2}\right)}{\partial x_{2}^{1}\partial x_{2}^{1}}
\end{array}\right]\label{eq:FinalCorrMat}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Durch diese Anordnung stehen alle Korrelationen zwischen zwei bestimmten
 Punkten immer zusammen, dies vereinfacht den Algorithmus zum Aufstellen
 der Matrix erheblich.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/home/andreas/documents/GoogleDrive/Promotion/Diss/images/UML/CorrelationFunction.eps
	lyxscale 70
	width 30cm
	height 14cm
	scaleBeforeRotation

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:UMLCorrelation"

\end_inset

UML Diagramm der abstrakten Klasse CorrelationFunction mit zwei Subklassen,
 diese stellen spezifische Korrelationsfunktionen dar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Die Methode CreateCorrelationMatrix
\begin_inset CommandInset label
LatexCommand label
name "subsec:Die-Methode-CreateCorrelationMat"

\end_inset


\end_layout

\begin_layout Standard
Das UML Diagramm in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

 zeigt die abstrakte Superklasse CorrelationFunction mit zwei Spezialisierungen
 namens CorrelationFunctionGauss und CorrelationsFunctionSpline.
 Die Spezialisierungen stellen jeweils verschiedene Korrelationsfunktionen
 dar.
 Die Umsetzung der Gauss Korrelationsfunktion wurde im Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Korrelationsfunktionen"

\end_inset

 dargestellt, auf die Beschreibung der Spline Funktion wird hier verzichtet.
 Die Methode getAllCorrelation schreibt alle Korrelationswerte zwischen
 den Stützpunkten P1 und P2 in die ebenfalls übergebene Korrelationsmatrix
 corrMat.
 Da die Korrelationswerte zwischen zwei Stützstellen eine Submatrix der
 Korrelationsmatrix darstellen (siehe Formel 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:FinalCorrMat"

\end_inset

), wird der Methode getAllCorrelation die entsprechende Stelle der Submatrix
 in der Korrelationsmatrix über die Indizes i und j mit angegebenen.
 Die beiden Parameter stellen hier die Position der ersten Zeile und Spalte
 der Submatrix in der Korrelationsmatrix dar.
 Es wird also im ersten Schritt die Korrelation zwischen den beiden Punkten
 bestimmt, dann die Korrelationen der partiellen Ableitungen, daraus wird
 dann die entsprechende Submatrix gebildet und diese in die Korrelationsmatrix
 eingefügt.
\end_layout

\begin_layout Standard
Das folgende Programmlisting zeigt die Funktion, welche unter Benutzung
 der abstrakten Klasse CorrelationFunktion, eine Korrelationsmatrix mit
 Werten befüllt.
 Der gezeigte Code ist der Originalcode in C++, auf Pseudocode wird hier
 verzichtet da einige Besonderheiten von C++ eine recht große Rolle in der
 Programmierung spielen.
 Einige Zeilenumbrüche wären in C++ in der Form nicht zulässig, aus Platzgründen
 ließen sich diese allerdings nicht vermeiden.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

template <class T, class B> 
\end_layout

\begin_layout Plain Layout

void createCorrelationMatrix(
\end_layout

\begin_layout Plain Layout

					T &correlationMatrix,
\end_layout

\begin_layout Plain Layout

					vector<Point<T,B> > &points, 
\end_layout

\begin_layout Plain Layout

					map<string,map<string,CorrelationFunction<T,B>*>> correlationMap){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	T tmp(config::numSamplesDerivatives, config::numSamplesDerivatives);
\end_layout

\begin_layout Plain Layout

	correlationMatrix = tmp;
\end_layout

\begin_layout Plain Layout

	#pragma omp parallel for schedule(dynamic) 	
\end_layout

\begin_layout Plain Layout

	for(size_t i=0; i<points.size(); i++){ 		
\end_layout

\begin_layout Plain Layout

		for(size_t j=i; j<points.size(); j++){
\end_layout

\begin_layout Plain Layout

			if(i==j){ 				
\end_layout

\begin_layout Plain Layout

				correlationMap[points[i].getType()][points[j].getType()]->getAllCorrelation(
\end_layout

\begin_layout Plain Layout

						points[i],
\end_layout

\begin_layout Plain Layout

						points[j],
\end_layout

\begin_layout Plain Layout

						correlationMatrix,
\end_layout

\begin_layout Plain Layout

						0.0,
\end_layout

\begin_layout Plain Layout

						config::matrixPositions[i],
\end_layout

\begin_layout Plain Layout

						config::matrixPositions[j], 
\end_layout

\begin_layout Plain Layout

						true ); 								
\end_layout

\begin_layout Plain Layout

				correlationMatrix[config::matrixPositions[i]][config::matrixPositions[j]]
 
\end_layout

\begin_layout Plain Layout

								+= fmath::expd(config::diagonalAddition); 			
\end_layout

\begin_layout Plain Layout

			} 			
\end_layout

\begin_layout Plain Layout

			else{ 				
\end_layout

\begin_layout Plain Layout

				correlationMap[points[i].getType()][points[j].getType()]->getAllCorrelation(
\end_layout

\begin_layout Plain Layout

					points[i],
\end_layout

\begin_layout Plain Layout

					points[j], 
\end_layout

\begin_layout Plain Layout

					correlationMatrix, 
\end_layout

\begin_layout Plain Layout

					0.0,
\end_layout

\begin_layout Plain Layout

					config::matrixPositions[i],
\end_layout

\begin_layout Plain Layout

					config::matrixPositions[j],
\end_layout

\begin_layout Plain Layout

					false); 			
\end_layout

\begin_layout Plain Layout

			} 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	#pragma omp parallel for 
\end_layout

\begin_layout Plain Layout

	for(int i=correlationMatrix.getColumnSize()-1; i>0; i--){ 		
\end_layout

\begin_layout Plain Layout

		for(int j=i-1; j>=0; j--){ 			
\end_layout

\begin_layout Plain Layout

			correlationMatrix[i][j] = correlationMatrix[j][i]; 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Funktion createCorrelationMatrix hat genau drei Parameter.
 Der erste Parameter ist eine Referenz auf die eigentliche Korrelationsmatrix.
 Um unnötiges Kopieren zu vermeiden, wird eine Referenz verwendet, weil
 die Daten direkt in die Matrix geschrieben werden sollen.
 Da die Matrizen sehr groß werden können (20000x20000 sind keine Seltenheit)
 und während des Trainings sehr häufig gebildet werden müssen, können solche
 Überlegungen erhebliche Unterschiede in der Geschwindigkeit ausmachen.
\end_layout

\begin_layout Standard
Der Parameter Points vom Typ Point (Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLPoint"

\end_inset

) ist ein eindimensionaler Vektor, welcher alle Member/Stützstellen beinhaltet.
 
\end_layout

\begin_layout Standard
CorrelationMap ist eine zweidimensionale Hashtabelle, die beiden Indizes
 sind Integer und beschreiben die Typen (vgl.
 Attribut type aus Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLPoint"

\end_inset

) der entsprechenden Stützstellen.
 Durch diese Hashtabelle ist es möglich, jedem Paar von Stützstellen verschieden
e Korrelationsfunktionen zuzuordnen.
 Dies ist bei der weiteren Entwicklung des Verfahrens von großer Bedeutung,
 insbesondere für Variable Fidelity Models (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Andere-Kriging-Verfahren"

\end_inset

).
 Der Wert der Hashtabelle ist vom Typ CorrelationFunction (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

), dieser kann also durch jeden Subtyp der abstrakten Klasse CorrelationFunction
 überladen werden.
 Eine solche correlationMap könnte z.B.
 folgendermaßen aufgebaut sein:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typ1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typ2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CorrelationFunction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
correlationFunctionGauss
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
correlationFunctionSpline
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
correlationFunctionGauss
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Würde man mit dieser correlationMap z.B.
 folgenden Aufruf machen, so würde man die Methode getAllCorrelation des
 SubTyps CorrelationFunctionGauss (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

) aufrufen.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small},language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

correlationMap[0][0]->getAllCorrelation(...);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Genau diesen Aufruf findet man in den Zeilen 13 und 25.
 
\end_layout

\begin_layout Standard
In Zeile 7 und 8 wird eine neue Matrix vom Template Typ T allokiert und
 der Parameter correlationMatrix damit überschrieben.
 Der Wert config::numSamplesDerivatives beschreibt hier die Anzahl der Stützstel
len plus die Anzahl der gegebenen partiellen Ableitungen.
 
\end_layout

\begin_layout Standard
In den Zeilen 9 bis 11 wird eine doppelte for Schleife über alle Stützstellen
 gestartet, um die Korrelationen von allen Stützstellen zu allen Stützstellen
 zu berechnen.
 Das 
\begin_inset Quotes eld
\end_inset

#pragma omp parallel for
\begin_inset Quotes erd
\end_inset

 ist eine einfache Schleifenparallelisierung von OpenMP.
 Die Indizes werden automatisch in Bereiche eingeteilt und dann in einzelnen
 Threads abgearbeitet.
 Die Anzahl der maximalen Threads wird direkt zu Anfang über ein Parameterfile
 festgelegt.
 Der zusätzliche Befehl 
\begin_inset Quotes eld
\end_inset

schedule(dynamic)
\begin_inset Quotes erd
\end_inset

 gibt an, wie der OpenMP Scheduler die Arbeit auf die Threads verteilt,
 es gibt prinzipiell drei Varianten:
\end_layout

\begin_layout Itemize

\shape italic
static
\shape default
: Jede Teilschleife besitzt eine feste Anzahl von Durchläufen, diese Durchläufe
 werden dann reihum an die Threads verteilt.
 Dieses Vorgehen ist, bei gleicher Lastverteilung der Teilschleifen optimal.
 Im Normalfall gibt es soviele Teilschleifen wie Anzahl Threads.
\end_layout

\begin_layout Itemize

\shape italic
dynamic
\shape default
: Hier werden die Teilschleifen dynamisch an die Threads verteilt, um das
 zu erreichen, werden die Teilschleifen kleiner gewählt als z.B.
 bei static.
 Dies ist sinnvoll, wenn die Last stark variiert, allerdings ist der Verwaltungs
aufwand für die OpenMP Laufzeitumgebung höher.
\end_layout

\begin_layout Itemize

\shape italic
guided
\shape default
: Bei diesem Fall werden die Teilschleifen während der Laufzeit exponentiell
 von groß zu klein verändert.
 Dies ist ein Spezialfall von 
\shape italic
dynamic 
\shape default
und reduziert den Verwaltungsaufwand.
\end_layout

\begin_layout Standard
Welche der drei Varianten für einen Fall geeignet ist, lässt sich oftmals
 nur durch Testen gut bestimmen.
 Bei der Belegung der Korrelationsmatrix scheint zuerst die Option 
\shape italic
static
\shape default
 sinnvoller zu sein, da der Aufwand für einen Schleifendurchlauf in etwa
 gleich bleibt.
 Allerdings war die Option 
\shape italic
dynamic
\shape default
 in Tests ca.
 10
\begin_inset space ~
\end_inset

% schneller.
 Das könnte durch interne Compiler Optimierungen und die Verwendung des
 If- Else Blocks innerhalb der Schleife zu erklären sein.
 
\end_layout

\begin_layout Standard
Der If- Else Block ist dazu da, um zwischen der Berechnung der Korrelation
 zwischen zwei gleichen Stützpunkten und der Berechnung der Korrelation
 zwischen zwei verschiedenen Punkten zu unterscheiden.
 Dies ist sinnvoll, da sich die Korrelation zwischen zwei gleichen Stützpunkten
 durch Vereinfachungen der mathematischen Formulierung deutlich schneller
 berechnen lässt.
 Eine solche Vereinfachung wird im nächsten Abschnitt genauer beschrieben.
 Zusätzlich kann auf die Diagonalelemente der Matrix, ein Diagonalaufschlag
 addiert werden (Zeile 21-22).
 Dies wird verwendet um die Matrix für die Invertierung numerisch stabiler
 zu machen, in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

 wird der Diagonalaufschlag genauer erläutert.
 
\end_layout

\begin_layout Standard
Innerhalb des If- Else Blocks wird die Methode getAllCorrelation der entsprechen
den Subklasse von CorrelationFunction (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

) aufgerufen.
 Zwei wichtige Parameter dieses Methodenaufrufs sind 
\begin_inset Quotes eld
\end_inset


\shape italic
config::matrixPositions[i]
\shape default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Newline newline
\end_inset


\begin_inset Quotes eld
\end_inset


\shape italic
config::matrixPositions[j]
\shape default

\begin_inset Quotes erd
\end_inset

, diese Arrays enthalten eine Tabelle, welche zu einer gegebenen Membernummer
 die entsprechende Position der Member in der Korrelationsmatrix zurückgeben
 soll.
 Da ein Member in der Korrelationsmatrix durch eine kleinere Submatrix beschrieb
en wird, stellt die Position immer die erste Zeile bzw.
 Spalte der Submatrix in der Korrelationsmatrix dar.
 Die Methode getAllCorrelation wird im folgenden Abschnitt genauer erläutert.
\end_layout

\begin_layout Standard
Da die Korrelationsmatrix symmetrisch ist, wird nur die rechte obere Dreiecksmat
rix belegt und in den Zeilen 37-43 wird diese dann auf die linke untere
 kopiert.
 Dadurch wird die Geschwindigkeit des Algorithmus nochmals erhöht.
\end_layout

\begin_layout Subsection*
Die Methode getAllCorrelation
\begin_inset CommandInset label
LatexCommand label
name "subsec:Die-Methode-getAllCorrelation"

\end_inset


\end_layout

\begin_layout Standard
Die Methode getAllCorrelation, welche in Subklassen des Typs CorrelationFunction
 (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

) definiert ist, soll alle Korrelationswerte zwischen zwei Stützstellen
 berechnen.
 Diese werden in die Korrelationsmatrix eingetragen und von der Funktion
 createCorrelationMatrix (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Die-Methode-CreateCorrelationMat"

\end_inset

) aufgerufen.
 Das folgende Listing zeigt den Originalcode in C++.
 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

template <class T,class B>
\end_layout

\begin_layout Plain Layout

inline void CorrelationFunctionGauss<T,B>::getAllCorrelation(
\end_layout

\begin_layout Plain Layout

		Point<T,B> &point1,
\end_layout

\begin_layout Plain Layout

 		Point<T,B> &point2,
\end_layout

\begin_layout Plain Layout

 		T &corrMatrix,
\end_layout

\begin_layout Plain Layout

 		B diag,
\end_layout

\begin_layout Plain Layout

 		size_t iMatrix,
\end_layout

\begin_layout Plain Layout

 		size_t jMatrix,
\end_layout

\begin_layout Plain Layout

 		bool equalMember){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	typename map<size_t, B>::iterator derIt;
\end_layout

\begin_layout Plain Layout

	typename map<size_t, B>::iterator derItCol;
\end_layout

\begin_layout Plain Layout

	size_t freevarNr=0, freevarNr2=0;
\end_layout

\begin_layout Plain Layout

	if(equalMember){
\end_layout

\begin_layout Plain Layout

		 corrMatrix[iMatrix][jMatrix]= 1.0;
\end_layout

\begin_layout Plain Layout

		 for(size_t i=0; i<point2.getNumPartDerivatives();i++){
\end_layout

\begin_layout Plain Layout

			freevarNr=i;
\end_layout

\begin_layout Plain Layout

			corrMatrix[iMatrix+i+1][jMatrix+i+1] = fmath::expd(thetas[0][freevarNr]);
\end_layout

\begin_layout Plain Layout

		 }
\end_layout

\begin_layout Plain Layout

	}else{
\end_layout

\begin_layout Plain Layout

		corrMatrix[iMatrix][jMatrix] = calcSimpleGauss(point1, point2);
\end_layout

\begin_layout Plain Layout

		size_t i=0;
\end_layout

\begin_layout Plain Layout

		size_t j=0;
\end_layout

\begin_layout Plain Layout

		for(derItCol=point2.getAllPartDervsRef().begin();
\end_layout

\begin_layout Plain Layout

					derItCol!=point2.getAllPartDervsRef().end();derItCol++){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			freevarNr=derItCol->first;
\end_layout

\begin_layout Plain Layout

			corrMatrix[iMatrix][jMatrix+i+1] = calcGEKPartialDerivative(point1, point2,
\end_layout

\begin_layout Plain Layout

 											 		corrMatrix[iMatrix][jMatrix], freevarNr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			i++;
\end_layout

\begin_layout Plain Layout

		} 		 	
\end_layout

\begin_layout Plain Layout

		if(corrMatrix.getRowSize()>1){
\end_layout

\begin_layout Plain Layout

			i=0;
\end_layout

\begin_layout Plain Layout

			for(derItCol=point1.getAllPartDervsRef().begin();
\end_layout

\begin_layout Plain Layout

						derItCol!=point1.getAllPartDervsRef().end();derItCol++){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				freevarNr=derItCol->first;
\end_layout

\begin_layout Plain Layout

				corrMatrix[iMatrix+i+1][jMatrix] = -calcGEKPartialDerivative(point1,
 point2,
\end_layout

\begin_layout Plain Layout

														corrMatrix[iMatrix][jMatrix], freevarNr);
\end_layout

\begin_layout Plain Layout

				i++; 
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			i=0; 			 			
\end_layout

\begin_layout Plain Layout

			for(derItCol=point1.getAllPartDervsRef().begin();
\end_layout

\begin_layout Plain Layout

 					derItCol!=point1.getAllPartDervsRef().end(); derItCol++){
\end_layout

\begin_layout Plain Layout

				freevarNr=derItCol->first;
\end_layout

\begin_layout Plain Layout

				j=0;
\end_layout

\begin_layout Plain Layout

				for(derIt=point2.getAllPartDervsRef().begin();
\end_layout

\begin_layout Plain Layout

					derIt!=point2.getAllPartDervsRef().end();derIt++){ 					
\end_layout

\begin_layout Plain Layout

							
\end_layout

\begin_layout Plain Layout

					freevarNr2 = derIt->first;
\end_layout

\begin_layout Plain Layout

					if(i==j) 						 						
\end_layout

\begin_layout Plain Layout

						corrMatrix[iMatrix+i+1][jMatrix+j+1]=calcGEKPartialDerivative2(point1,
\end_layout

\begin_layout Plain Layout

																point2,
\end_layout

\begin_layout Plain Layout

																corrMatrix[iMatrix][jMatrix], 
\end_layout

\begin_layout Plain Layout

																freevarNr);
\end_layout

\begin_layout Plain Layout

					else
\end_layout

\begin_layout Plain Layout

						corrMatrix[iMatrix+i+1][jMatrix+j+1] = calcGEKPartialDerivative2(point1,
\end_layout

\begin_layout Plain Layout

																	point2,
\end_layout

\begin_layout Plain Layout

																	corrMatrix[iMatrix][jMatrix],
\end_layout

\begin_layout Plain Layout

																	freevarNr,   
\end_layout

\begin_layout Plain Layout

																	freevarNr2);
\end_layout

\begin_layout Plain Layout

					j++;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				i++;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Methode wird mit sieben Parametern aufgerufen.
 Die ersten beiden Parameter sind Referenzen auf zwei Objekte vom Typ Point.
 Zwischen diesen beiden Stützstellen sollen alle entsprechenden Korrelationswert
e berechnet werden.
 Der nächste Parameter corrMatrix ist eine Referenz auf die Korrelationsmatrix,
 in welche die entsprechenden Korrelationswerte geschrieben werden sollen.
 Wie bereits im vorherigen Abschnitt ist der Parameter diag, ein Diagonalaufschl
ag für die Korrelationsmatrix.
 Dieser wird auf die Hauptdiagonale der Matrix addiert und kann für die
 numerische Stabilität der Invertierung von Bedeutung sein, in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

 wird der Diagonalaufschlag genauer erläutert.
 Die nächsten beiden Parameter iMatrix und jMatrix geben an, bei welchen
 Indizes in der Korrelationsmatrix die neuen Korrelationen eingefügt werden
 sollen.
 
\end_layout

\begin_layout Standard
Der letzte Parameter equalMember ist ein bool'scher Wert und gibt an, ob
 es sich bei den beiden Stützstellen um dieselben Punkte handelt.
 Ist dies der Fall, kann die Berechnung der Korrelationswerte stark vereinfacht
 werden.
 
\end_layout

\begin_layout Standard
In den Zeilen 11-13 werden einige Variablen deklariert.
 Insbesondere zwei Iteratoren, welche zum iterieren über die partiellen
 Ableitungen der beiden Stützstellen dienen.
 Dies ist nötig, da die partiellen Ableitungen als map gespeichert sind
 und eine map in C++ nur über Iteratoren durchlaufen werden kann.
 
\end_layout

\begin_layout Standard
Die Zeilen 14-19 werden ausgeführt, wenn die beiden Stützstellen identisch
 sind.
 Dann vereinfachen sich die Korrelationswerte für eine Gauss Korrelation
 wie sie in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Korrelationsfunktionen"

\end_inset

 beschrieben wurde zu:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
c\left(\vec{x}_{1},\vec{x}_{1}\right)=1
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\frac{\partial c\left(\vec{x}_{1},\vec{x}_{1}\right)}{\partial x_{1}^{p}}=0
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\frac{\partial c\left(\vec{x}_{1},\vec{x}_{1}\right)}{\partial x_{1}^{p}\partial x_{1}^{j}}=\begin{cases}
0 & p\neq j\\
e^{\theta_{k}} & p=j
\end{cases}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Übertragen auf das Beispiel aus Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:FinalCorrMat"

\end_inset

, vereinfacht sich die entsprechende Korrelationsmatrix dann zu:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
R=\left[\begin{array}{c|cccc}
 & Z\left(\vec{x}_{1}\right) & \frac{\partial Z\left(\vec{x}_{1}\right)}{\partial x_{1}^{1}} & Z\left(\vec{x}_{2}\right) & \frac{\partial Z\left(\vec{x}_{2}\right)}{\partial x_{1}^{1}}\\
\hline Z\left(\vec{x}_{1}\right) & 1 & 0 & c\left(\vec{x}_{1},\vec{x}_{2}\right) & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{2}^{1}}\\
\frac{\partial Z\left(\vec{x}_{1}\right)}{\partial x_{1}^{1}} & 0 & e^{\theta_{k}} & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{1}^{1}\partial x_{2}^{1}}\\
Z\left(\vec{x}_{2}\right) & c\left(\vec{x}_{2},\vec{x}_{1}\right) & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{1}\right)}{\partial x_{1}^{1}} & 1 & 0\\
\frac{\partial Z\left(\vec{x}_{2}\right)}{\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{1}\right)}{\partial x_{2}^{1}} & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{1}\right)}{\partial x_{2}^{1}\partial x_{1}^{1}} & 0 & e^{\theta_{k}}
\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Diese Vereinfachung gilt nur für die Gauss Korrelationsfunktion, für andere
 Korrelationsfunktionen ergeben sich aber ähnliche Vereinfachungen.
\end_layout

\begin_layout Standard
Handelt es sich bei den beiden Stützstellen allerdings nicht um dieselben,
 wird der else-Fall ab Zeile 21 aufgerufen.
 In dieser Zeile wird dann der einfache Korrelationswert der Matrix gebildet
 und in die gesamte Korrelationsmatrix eingetragen.
 Der Code für die private Methode calcSimpleGauss ist identisch mit dem
 Code für die Gauss Korrelationsfunktion aus Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Korrelationsfunktionen"

\end_inset

.
 
\end_layout

\begin_layout Standard
In den Zeilen 24-32 wird die Ableitung der Korrelationsfunktion zwischen
 den Stützstellen gebildet, abgeleitet wird nach den Parametern der zweiten
 Stützstelle.
 Die Schleife geht alle freien Variablen durch, an denen es eine partielle
 Ableitung gibt.
 Die eigentlichen Korrelationswerte werden in der privaten Methode calcGEKPartia
lDerivative berechnet und danach in die gesamte Korrelationsmatrix geschrieben,
 in der oberen Beispielmatrix würde das dem Wert 
\begin_inset Formula $\frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{2}^{1}}$
\end_inset

 aus der rechten oberen Ecke entsprechen, da es in dem Beispiel nur eine
 freie Variable gibt.
 Der Methode calcGEKPartialDerivative werden anschließend die beide Punkte
 übergeben.
 Der genaue Funktionsablauf soll hier aus Platzgründen nicht weiter aufgeführt
 werden.
 
\end_layout

\begin_layout Standard
Die Abfrage in Zeile 33 prüft, ob es sich bei der Korrelationsmatrix um
 einen Vektor handelt.
 Ist dies der Fall, sind nachfolgenden Berechnungen nicht notwendig.
\end_layout

\begin_layout Standard
In den Zeilen 35-42 wird wie bereits in den Zeilen 24-32 die Ableitung der
 Korrelationsfunktion berechnet.
 In diesem Fall allerdings für die erste Stützstelle, dies würde in der
 Beispielmatrix dem Wert 
\begin_inset Formula $\frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{1}^{1}}$
\end_inset

 entsprechen.
 
\end_layout

\begin_layout Standard
In den Zeilen 44-66 werden die zweiten Ableitungen der Korrelationsfunktion
 gebildet.
 Dafür muss über die freien Variablen von beiden Stützstellen iteriert werden,
 an denen sich partielle Ableitungen befinden.
 Die Berechnung der Ableitungen findet in der privaten Methode calcGEKpartialDer
ivative2 statt.
 Es gibt zwei verschiedene Implementationen der Methode, einmal eine für
 den Fall, dass die freien Variablen, nach denen abgeleitet wird für beide
 Punkte gleich sind und einmal für den Fall, dass sich diese unterscheiden.
 In der Beispielmatrix würde die Ableitung dem Wert 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $\frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{1}^{1}\partial x_{2}^{1}}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang ngerman
 entsprechen.
 Zudem besitzen die beiden Punkte jeweils nur eine freie Variable und auch
 nur jeweils eine partielle Ableitung.
 Daher ist die Nummer der freien Variablen nach denen abgeleitet wird, in
 beiden Fällen eins und damit würde die entsprechende Implementation aus
 den Zeilen 52-56 aufgerufen werden.
 
\end_layout

\begin_layout Standard
Diese Methode stellt einen recht allgemeingültigen Algorithmus auf, welcher
 alle notwendigen Korrelationswerte zwischen zwei Stützstellen in die korrekten
 Positionen einer Korrelationsmatrix einfügt.
 Im UML Diagramm 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

 wurde zusätzlich zur Methode getAllCorrelation eine Methode getAllCorrelationPa
rtialDer gelistet.
 Diese soll die Ableitungen der Korrelationsfunktion nach den Hyperparametern
 zurückgeben.
 Dies ist für das Training, welches in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Minimierungsverfahren"

\end_inset

 erklärt wird, wichtig.
 Die eigentliche Methode ist der Methode getAllCorrelation allerdings relativ
 ähnlich und soll daher nicht näher dargestellt werden.
 
\end_layout

\begin_layout Subsection
Bestimmung der Korrelationen bei Verwendung der Kovarianzmatrix und Co-Kriging
\end_layout

\begin_layout Standard
Für einige Anwendungen ist es notwendig die reale Korrelation zwischen zwei
 beliebigen Samples zu kennen.
 Im Co-Kriging hat man natürlich das Problem, dass diese erst einmal unbekannt
 sind, da mit der Kovarianzmatrix 
\end_layout

\begin_layout Subsection
Bestimmung der Hyperparameter durch die Maximum Likelihood Methode
\begin_inset CommandInset label
LatexCommand label
name "chap:Likelihood"

\end_inset


\end_layout

\begin_layout Standard
Wie in den vorherigen Kapiteln gezeigt wurde, hängen die einzelnen Korrelationsw
erte der Korrelationsmatrix maßgeblich von den verwendeten Hyperparametern
 ab und damit die Güte des Kriging Modells.
 Ziel eines Kriging Trainings ist es daher, die optimalen Hyperparameter
 zu finden.
 Um dies zu erreichen, wird die Maximum Likelihood Methode verwendet.
 
\end_layout

\begin_layout Standard
Im ersten Teil des Kapitels soll die Maximum Likelihood Methode anhand eines
 simplen Beispiels erklärt werden.
 Im Anschluss daran wird die Umsetzung dieser Methode für das hier verwendete
 Kriging Modell gezeigt.
 
\end_layout

\begin_layout Standard
Der letzte Abschnitt behandelt dann die softwaretechnische Umsetzung dieser
 Methode.
\end_layout

\begin_layout Subsection
Likelihood
\end_layout

\begin_layout Standard
Um den Likelihood Term und seine partiellen Ableitungen zu bilden, wird
 eine eigene Klasse vorgesehen.
 Da mehrere Likelihood Funktionen denkbar wären, wird eine abstrakte Klasse
 namens DensityFunction eingeführt.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLDensity"

\end_inset

 zeigt die Umsetzung der Klasse als UML Diagramm, Getter und Setter Methoden
 wurden hier aus Platzgründen ausgelassen.
 Bisher ist nur die Likelihood Funktion umgesetzt (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Maximum-Likelihood-für"

\end_inset

).
 Der Likelihood Term (Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:VereinfachterLikelihoodTerm"

\end_inset

) wird in der Methode calcDensity() berechnet und die entsprechende Ableitung
 (Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:AbleitungLikelihood"

\end_inset

) in calcDensityDerivative().
 Denkbar wären allerdings auch andere Likelihood Funktionen, welche auf
 anderen Verteilungen basieren.
 
\end_layout

\begin_layout Standard
Ziel der Klassenstruktur ist es, die beiden Gleichungen 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:VereinfachterLikelihoodTerm"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:AbleitungLikelihood"

\end_inset

 so effizient wie möglich zu lösen.
 Die dort verwendeten Matrizen sind in der Regel sehr groß und voll besetzt,
 was eine effiziente Berechnung sehr wichtig macht.
 Allerdings sind die Matrizen symmetrisch und positiv definit, was wiederum
 einige Optimierungen zulässt.
 Zur Vereinfachung werden einige Terme der Gleichungen zusammengefasst:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\vec{R}_{f} & =\mathbf{R}^{-1}\overrightarrow{F}\label{eq:Rf}
\end{align}

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Formula 
\begin{align}
f_{rf} & =\vec{F}^{T}\vec{R}_{f}\label{eq:frf}
\end{align}

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Formula 
\begin{align}
\overrightarrow{e} & =(\vec{y}_{s}-\beta*\overrightarrow{F})\label{eq:e}
\end{align}

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Formula 
\begin{equation}
\overrightarrow{d}=\mathbf{R}^{-1}\overrightarrow{e}\label{eq:dvec}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Die Terme werden in diese Form auch in der entsprechenden Klasse (ReducedNormalD
istribution) einmal berechnet und dann gespeichert.
 Da diese sehr häufig wiederverwendet werden, muss man diese Termen nur
 einmal berechnen und eine Änderung ist nur notwendig, wenn die Hyperparameter
 verändert wurden.
 Über die Attribute corrMatUpdate und vecUpdate wird festgelegt, ob die
 Matrizen und Vektoren neu berechnet werden müssen oder nicht.
 Sie werden nur dann neu berechnet, wenn die Hyperparameter verändert wurden.
 Da die Hyperparameter nur über Getter und Setter Methoden zugänglich sind,
 kann man bei jedem Setter Zugriff auf die Hyperparameter die Attribute
 corrMatUpdate und vecUpdate auf true setzen.
 
\end_layout

\begin_layout Standard
Viele der Attributnamen entsprechen den hier verwendeten Bezeichnungen für
 die Vektoren/Matrizen, z.B.
 der Vektor 
\begin_inset Formula $\vec{R}_{f}$
\end_inset

 entspricht dem Attribut rf.
 Das Attribut logDeterminantR entspricht dem Logarithmus der Determinante
 der Korrelationsmatrix 
\begin_inset Formula $\log\left(\det(\mathbf{R})\right)$
\end_inset

.
 Aufgrund dieser Ähnlichkeit werden daher nicht alle einzeln aufgeführt.
 
\end_layout

\begin_layout Standard
Wie bereits in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:MatrixKlasse"

\end_inset

 beschrieben, lässt sich die Determinante durch eine Cholesky Zerlegung
 sehr effizient berechnen.
 Insbesondere da die Zerlegung ebenfalls für die Invertierung der Matrix
 sinnvoll ist.
 Die Korrelationsmatrix wird in der Methode createAndInvertCorrelmat aufgestellt
, zerlegt und dann invertiert.
 Die zerlegte Matrix wird in decomposedMatrix gespeichert, die invertierte
 Matrix in inverseCorrMatrix.
 Die benötigten Vektoren werden in der Methode calcVectors() berechnet und
 in den Attributen der Klasse gespeichert.
 Die Methoden predict() und predictVariance() berechnen dann unter Vorgabe
 eines Ortsvektors eine Schätzung der gesuchten Funktion 
\begin_inset Formula $y^{*}\left(\vec{x}_{0}\right)$
\end_inset

 (siehe Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:GewichtetSumme"

\end_inset

) und der Varianz (Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KrigingVarianzSchätzung"

\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
Mittwoch
\begin_inset Graphics
	filename ../images/UMLDensityFunction.PNG
	lyxscale 50
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:UMLDensity"

\end_inset

UML Diagramm der abstrakten Superklasse DensityFunction und der Subklasse
 ReducedNormalDistribution
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Schritte für die Berechnung eines Likelihood Terms:
\end_layout

\begin_layout Standard
In diesem Abschnitt soll die Methode zur Berechnung des Likelihood Terms
 (calcDensity()) nochmals genauer erklärt werden.
 Das folgende Listing zeigt die Methode im Originalcode:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

template <class T, class B> 
\end_layout

\begin_layout Plain Layout

B ReducedNormalDistribution<T,B>::calcDensity(){
\end_layout

\begin_layout Plain Layout

	try{ 		
\end_layout

\begin_layout Plain Layout

		if(this->corrMatUpdate){
\end_layout

\begin_layout Plain Layout

			this->createAndInvertCorrelMat(); 			
\end_layout

\begin_layout Plain Layout

			this->corrMatUpdate = false; 		
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

		if(this->vecUpdate){
\end_layout

\begin_layout Plain Layout

			this->calcVectors();
\end_layout

\begin_layout Plain Layout

			this->vecUpdate = false;
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

	catch(ChodecNotPosDef& e){
\end_layout

\begin_layout Plain Layout

		cout <<"calcDensity() MatrixExceptions:"<<e.what()<<endl;
\end_layout

\begin_layout Plain Layout

		config::diagonalAddition = log(2.0*exp(config::diagonalAddition)); 		
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		this->getCorrelationMatrixRef().saveAsAscii("corrMatFailed"); 		
\end_layout

\begin_layout Plain Layout

		this->getInverseCorrelationMatrixRef().saveAsAscii("corrMatInverseFailed");
 		
\end_layout

\begin_layout Plain Layout

		return  (config::numSamples*1000.0); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	catch(...){ 		
\end_layout

\begin_layout Plain Layout

		cout <<"calcDensity() Exception"<<endl; 		
\end_layout

\begin_layout Plain Layout

		cout <<"--------------------------------"<<endl;
\end_layout

\begin_layout Plain Layout

		return  (config::numSamples*1000.0); 	
\end_layout

\begin_layout Plain Layout

	}  		
\end_layout

\begin_layout Plain Layout

	return 0.5*(log(sSqr)*config::numSamples + logDeterminantR + config::numSamples
 );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Zeile 4 wird zuerst überprüft, ob die Korrelationsmatrix neu aufgestellt
 werden muss oder nicht.
 Dies geschieht, wie bereits beschrieben, mit dem Attribut corrMatUpdate-
 Ist dieses true, dann wird die Korrelationsmatrix wie in Zeile 5 über die
 Methode createAndInvertCorrMat() erzeugt, eine Cholesky Zerlegung durchgeführt
 und dann invertiert.
 Nach erfolgreichem Aufruf der Methode wird das Attribut corrMatUpdate wieder
 auf false gesetzt.
 Ansonsten werden die Matrizen im Puffer verwendet, also correlationMatrix,
 decomposedMatrix und inverseCorrMat.
 
\end_layout

\begin_layout Standard
Auf dieselbe Weise wird mit den Vektoren (Gleichungen 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Rf"

\end_inset

-
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dvec"

\end_inset

) in den Zeilen 8-10 verfahren.
 Diese werden durch die Methode calcVectors erzeugt und dann in den Attributen
 der Klasse gespeichert.
 Durch die verwendete Matrix Klasse ist die Berechnung der einzelnen Vektoren/Ma
trizen sehr simpel.
 Das folgende Listing zeigt dies exemplarisch an der Methode zur Erzeugung
 von Vektor 
\begin_inset Formula $\vec{d}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},tabsize=4"
inline false
status open

\begin_layout Plain Layout

template <class T, class B>
\end_layout

\begin_layout Plain Layout

void ReducedNormalDistribution<T,B>::calcDVec(){
\end_layout

\begin_layout Plain Layout

	dVec = inverseCorrelationMatrix.matrixMultiplicationTranspose(eVec); 	
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Die Methode ist Mitglied der Klasse ReducedNormalDistribution (siehe Abbildung
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLDensity"

\end_inset

) und wird durch die Methode calcVectors() aufgerufen.
 Das Attribut inverseCorrelationMatrix ist vom Typ Matrix und beinhaltet
 die inverse Korrelationsmatrix.
 Diese wird mit dem transponierten Vektor 
\lang english

\begin_inset Formula $\overrightarrow{e}=(\vec{y}_{s}-\beta*\overrightarrow{F})$
\end_inset


\lang ngerman
 multipliziert, die Transposition wird innerhalb der Multiplikation vorgenommen.
 Die anderen Methoden zur Berechnung der Dichtefunktionswerte usw.
 beinhalten prinzipiell nur andere Matrix Operationen und werden daher nicht
 alle aufgeführt.
\end_layout

\begin_layout Standard
Die Methode InitAllThetas() der Klasse DensityFunction und deren Subklassen
 soll alle Hyperparameter mit möglichst sinnvollen Werten initialisieren.
 Die verschiedenen Intialisierungsmöglichkeiten und deren Umsetzung werden
 in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

 noch genauer erläutert.
\end_layout

\begin_layout Standard
Da die Cholesky Zerlegung nur für positiv definite symmetrische Matrizen
 funktioniert, kann es bei der Zerlegung zu einer Exception vom Typ ChodecNotPos
Def kommen, dies wird in Zeile 13 abgefangen.
 Ist diese Exception aufgetreten, wird der Diagonalaufschlag (siehe Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

) erhöht und ein sehr hoher Likelihood Wert zurückgegeben (Zeile 19), damit
 dieser in der Minimierung nicht mehr berücksichtigt wird.
 
\end_layout

\begin_layout Standard
Zusätzlich wird innerhalb der Matrix Klasse nach erfolgreicher Invertierung
 eine kurze Überprüfung der invertierten Matrix gemacht.
 Dies wird durch folgende Gleichung erreicht:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\textrm{Spur}\left(RR^{-1}\right) & =n
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Das Produkt der Inversen und der Korrelationsmatrix, ergibt die Einheitsmatrix.
 Da die Einheitsmatrix n Diagonalelemente besitzt, welche alle den Wert
 1.0 haben, muss die Spur der multiplizierten Matrizen n ergeben.
 Gibt es numerische Ungenauigkeiten innerhalb der Invertierung, wird dieser
 Wert wahrscheinlich von n abweichen.
 Dies wird überprüft und bei Überschreitung eines Grenzwertes wird ebenfalls
 eine Exception geworfen.
 Diese wird mit allen anderen unbekannten Exceptions in Zeile 21 gefangen
 und als Reaktion ein sehr hoher Likelihood Wert zurückgegeben.
 
\end_layout

\begin_layout Standard
Nachdem alle Vektoren und Werte berechnet sind, wird in Zeile 26 die eigentliche
 Likelihood Funktion berechnet (siehe Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Likelihood Funktion"

\end_inset

) und zurückgegeben.
 
\end_layout

\begin_layout Section
Minimierungsverfahren/Training
\begin_inset CommandInset label
LatexCommand label
name "chap:Minimierungsverfahren"

\end_inset


\end_layout

\begin_layout Standard
Im Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Maximum-Likelihood-für"

\end_inset

 wurde die Maximum Likelihood Methode vorgestellt.
 Als Ergebnis dieses Kapitels erhielt man zwei Gleichungen zur Berechnung
 des Likelihood Terms und der dazugehörigen Ableitung.
 Ziel ist es, für den Likelihood Term die optimalen Hyperparameter zu finden.
 Dieser Vorgang ist das eigentliche Training des Modells.
 Zu diesem Zweck werden zwei numerische Minimierungsverfahren vorgestellt.
 Beide Minimierungsverfahren waren bereits in einer institutseigenen Bibliothek
 vorhanden.
 Die entwickelte Minimierungsklasse sollte beide Verfahren nutzen können.
 Hierfür wurde ein spezielles Klassenmodell unter Benutzung von Boost Funktionso
bjekten entwickelt.
\end_layout

\begin_layout Standard
Das Training bringt einige zusätzliche Probleme mit sich, z.B.
 müssen die Hyperparameter anfangs initialisiert werden.
 Zudem kann die Korrelationsmatrix schlecht konditioniert sein, für beide
 Probleme wurden Lösungsansätze entwickelt, welche hier vorgestellt werden.
 
\end_layout

\begin_layout Subsection
Vermeidung negativer Hyperparameter 
\end_layout

\begin_layout Standard
In diesem Abschnitt soll darauf eingegangen werden, welche Probleme negative
 Hyperparameter hervorrufen und wie man diese vermeiden kann.
 
\end_layout

\begin_layout Standard
Zudem wurde in vorherigen Kapiteln bereits ein Diagonalaufschlag erwähnt,
 dieser wird auf die Diagonalelemente der Korrelationsmatrix addiert und
 soll die Kondition der Matrix verbessern.
 Die genaue Vorgehensweise soll in diesem Abschnitt erläutert werden.
\end_layout

\begin_layout Subsection*
Negative Hyperparameter
\begin_inset CommandInset label
LatexCommand label
name "subsec:Negative-Hyperparameter"

\end_inset


\end_layout

\begin_layout Standard
Während der Minimierung der Likelihood Funktion kann es je nach gewähltem
 Minimierungsverfahren oftmals dazu kommen, dass die Hyperparameter negativ
 werden können.
 Bei der Gauss Korrelationsfunktion würde dies dazu führen, dass bei großen
 Abständen zwischen den Membern auch große Korrelationen vorhergesagt werden
 würden.
 Die Korrelationen könnten so auch einen Wert über Eins erhalten, was keinen
 Sinn macht.
 Daher sind negative Hyperparameter bei der Gauss Funktion zwingend zu vermeiden.
 
\end_layout

\begin_layout Standard
Eine einfache Möglichkeit dies zu tun, wäre während der Minimierung die
 Hyperparameter nach unten zu begrenzen.
 Dies kann bei einigen Minimierungsverfahren allerdings zu schwerwiegenden
 Problemen führen, sodass diese nicht mehr konvergieren würden.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
c\left(\vec{x}_{1},\vec{x}_{2}\right) & =e^{-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(\theta_{l}\left|x_{1l}-x_{2l}\right|^{2}\right)}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Wünschenswert wäre es also, dass der gesamte Bereich der reellen Zahlen
 verwendet werden könnte.
 Um dies zu erreichen, wurde als erstes versucht, das Quadrat der Hyperparameter
 zu verwenden:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
c\left(\vec{x}_{1},\vec{x}_{2}\right) & =e^{-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(\theta_{l}^{2}\left|x_{1l}-x_{2l}\right|^{2}\right)}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Diese Formulierung führte allerdings zu einem unerwünschten Verhalten und
 zwar sieht die partielle Ableitung dieser Funktion wie folgt aus:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\frac{\partial c}{\partial\theta_{l}} & =c\left(\vec{x}_{1},\vec{x}_{2}\right)\left(-\theta_{l}\left|x_{1l}-x_{2l}\right|^{2}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Das Problem hierbei ist, dass wenn der Hyperparameter während der Optimierung
 Null wird, auch die entsprechende partielle Ableitung Null wird.
 Während eines Minimierungsverfahrens kann es also passieren, dass die partielle
n Ableitungen der Hyperparameter alle zu Null werden und die Minimierung
 als beendet angesehen wird.
 Um dieses Problem zu vermeiden, wurde die Exponentialfunktion verwendet:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
c\left(\vec{x}_{1},\vec{x}_{2}\right) & =e^{-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(e^{\theta_{l}}\left|x_{1l}-x_{2l}\right|^{2}\right)}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\frac{\partial c}{\partial\theta_{l}} & =c\left(\vec{x}_{1},\vec{x}_{2}\right)\left(-\frac{1}{2}e^{\theta_{l}}\left|x_{1l}-x_{2l}\right|^{2}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Diese Formulierung der Gauss Korrelationsfunktion hat sich bisher als vorteilhaf
t herausgestellt, da der gesamte Raum der reellen Zahlen verwendet werden
 kann.
 Zudem ist die Funktion stetig und differenzierbar.
\end_layout

\begin_layout Subsection
Regularisierungsterm und Nugget für alle Kriging Modelle
\end_layout

\begin_layout Subsection*
Diagonalaufschlag einstellen über eine maximale Konditionszahl
\end_layout

\begin_layout Standard
Während des Trainings kann es passieren, dass Hyperparameter eingestellt
 werden, die eine schlechte Konditionierung der Korrelationsmatrix hervorrufen.
 Dies kann bei der Cholesky Zerlegung problematisch werden.
 Um die Konditionszahl zu verbessern, wird ein Diagonalaufschlag auf die
 Hauptdiagonale der Matrix addiert.
 Die Gauss Korrelationsfunktion würde sich damit wie folgt ändern (
\begin_inset Formula $\delta_{i,j}$
\end_inset

 beschreibt hier das Kronecker Delta und 
\begin_inset Formula $\lambda$
\end_inset

 den Diagonalaufschlag):
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
c\left(\vec{x}_{i},\vec{x}_{j}\right) & =e^{-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(e^{\theta_{l}}\left|x_{i,l}-x_{j,l}\right|^{2}\right)}+e^{\lambda}\delta_{i,j}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Es stellt sich allerdings die Frage, wie groß dieser Diagonalaufschlag im
 Einzelfall sein muss und inwiefern dieser das Ergebnis beeinflusst bzw.
 die Kondition verbessert.
 Grundsätzlich sollte dieser so klein wie möglich gewählt werden, um die
 Ursprungsmatrix so wenig wie möglich zu verändern.
 Um einen optimalen Wert zu ermitteln, gibt es zwei verschiedene Möglichkeiten.
 
\end_layout

\begin_layout Standard
Die erste Möglichkeit wäre, die Likelihood Funktion (siehe Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Likelihood Funktion"

\end_inset

) nach dem Diagonalaufschlag zu differenzieren.
 Die Ableitung ist in diesem Fall sehr simpel, da alles außer dem Diagonalaufsch
lag wegfällt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\frac{\partial c\left(\vec{x}_{i},\vec{x}_{j}\right)}{\partial\lambda} & =e^{\lambda}\delta_{i,j}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Die Ableitung der Korrelationsmatrix nach dem Diagonalaufschlag ergibt also
 eine Einheitsmatrix multipliziert mit dem Diagonalaufschlag:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathbf{\frac{\partial R}{\partial\lambda}} & =e^{\lambda}\mathbf{E}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Damit ergibt sich die Ableitung der Likelihood Funktion nach dem Diagonalaufschl
ag zu:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\frac{\partial L}{\partial\lambda} & =\frac{e^{\lambda}}{2}\left[\textrm{Spur}\left(\mathbf{R}^{-1}\right)-\frac{1}{\sigma^{2}}(\vec{y}_{s}-\beta*\overrightarrow{F})^{T}\mathbf{R}^{-1}\mathbf{R}^{-1}(\vec{y}_{s}-\beta*\overrightarrow{F})\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Mit dieser Formel wäre es nun möglich, den Diagonalaufschlag einfach als
 zusätzlichen Hyperparameter zu minimieren.
 Allerdings bedeutet dies natürlich einen zusätzlicher Aufwand.
 Es soll daher nach einer einfacheren Methode gesucht werden.
 
\end_layout

\begin_layout Standard
Ein anderer möglicher Ansatz ist die Konditionszahl der Matrix.
 Diese ist definiert als Quotient aus maximalem und minimalem Eigenwert
 der Korrelationsmatrix:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\kappa & =\left|\frac{\Xi_{max}\left(\mathbf{R}\right)}{\Xi_{min}\left(\mathbf{R}\right)}\right|
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Überlegt man sich nun, welche Korrelationsmatrix am schlechtesten konditioniert
 wäre, kommt man auf die Einsmatrix:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathbf{R} & =\left[\begin{array}{ccc}
1 & ... & 1\\
... & ... & ...\\
1 & ... & 1
\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Die minimalen und maximalen Eigenwerte der Einsmatrix sind bekannt:
\begin_inset Formula 
\begin{align*}
\Xi_{min}\left(\mathbf{R}\right) & =0
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\Xi_{max}\left(\mathbf{R}\right) & =n
\end{align*}

\end_inset

Dies würde einer unendlichen Konditionszahl entsprechen:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\kappa & =\infty
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Addiert man nun den Diagonalaufschlag, bekommt man folgende Korrelationsmatrix:
 
\begin_inset Formula 
\begin{align*}
\mathbf{R} & =\left[\begin{array}{ccc}
1+e^{\lambda} & ... & 1\\
... & ... & ...\\
1 & ... & 1+e^{\lambda}
\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Daraus ergeben sich die folgenden neuen maximalen und minimalen Eigenwerte:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\Xi_{min}\left(\mathbf{R}\right) & =e^{\lambda}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\Xi_{max}\left(\mathbf{R}\right) & =e^{\lambda}+n
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Und die entsprechende Konditionszahl verbessert sich zu:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\kappa & =\left|\frac{e^{\lambda}+n}{e^{\lambda}}\right|
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Da die Matrix positiv definit sein muss und damit nur positive Eigenwerte
 hat, kann der Betrag weggelassen werden:
\begin_inset Formula 
\begin{align*}
\kappa & =\frac{e^{\lambda}+n}{e^{\lambda}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Wählt man nun für die Konditionszahl eine obere Grenze, bekommt man eine
 Untergrenze für den Diagonalaufschlag:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\kappa_{max} & >\frac{e^{\lambda}+n}{e^{\lambda}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
e^{\lambda} & >\frac{n}{\left(\kappa_{max}-1\right)}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Eine geeignete Grenze für die obere Grenze der Konditionszahl ist aus der
 Erfahrung bekannt und liegt bei ca.
 
\begin_inset Formula $10^{9}$
\end_inset

, dieser Wert kann im Einzelfall natürlich angepasst werden.
 Der daraus resultierende Diagonalaufschlag würde bei einer üblichen Matrixgröße
 von 5000x5000, 
\begin_inset Formula $5*10^{-6}$
\end_inset

 betragen und es ist davon auszugehen, dass dieser so gut wie keinen Einfluss
 auf das Endergebnis haben sollte.
 
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
Diese Art der Berechnung des Diagonalaufschlags wird momentan im Code verwendet.
 Die entsprechende Ableitung der Likelihood Funktion ist im Code bereits
 umgesetzt, wird momentan allerdings nicht verwendet, da bisherige Tests
 dafür noch keine Notwendigkeit zeigten.
\end_layout

\begin_layout Subsection*
Diagonalaufschlag als Faktor
\end_layout

\begin_layout Standard
Multipliziert man nun den Diagonalaufschlag, bekommt man folgende Korrelationsma
trix: 
\begin_inset Formula 
\begin{align*}
\mathbf{R} & =\left[\begin{array}{ccc}
1\lambda & ... & 1\\
... & ... & ...\\
1 & ... & 1\lambda
\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Daraus ergeben sich die folgenden neuen maximalen und minimalen Eigenwerte:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\Xi_{min}\left(\mathbf{R}\right) & =1
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\Xi_{max}\left(\mathbf{R}\right) & =\lambda+n-1
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Und die entsprechende Konditionszahl verbessert sich zu:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\kappa & =\left|\frac{\lambda+n-1}{\lambda-1}\right|
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Da die Matrix positiv definit sein muss und damit nur positive Eigenwerte
 hat, kann der Betrag weggelassen werden:
\begin_inset Formula 
\begin{align*}
\kappa & =\frac{\lambda+n-1}{\lambda-1}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Wählt man nun für die Konditionszahl eine obere Grenze, bekommt man eine
 Untergrenze für den Diagonalaufschlag:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\kappa_{max} & >\frac{\lambda+n-1}{\lambda-1}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\lambda & >\frac{n-1+\kappa_{max}}{\left(\kappa_{max}-1\right)}
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Initialisierung der Hyperparameter für alle Kriging Modelle 
\begin_inset CommandInset label
LatexCommand label
name "sec:Initialisierung-der-Hyperparamet"

\end_inset


\end_layout

\begin_layout Standard
Um einen Minimierungsalgorithmus starten zu können, ist eine geeignete Initialis
ierung der Hyperparameter von großer Bedeutung.
 Diese kann die Konvergenz und auch die Stabilität der Minimierung stark
 beeinflussen.
 Innerhalb dieser Arbeit wurden mehrere Ansätze entwickelt, um eine geeignete
 Initialisierung zu finden.
 
\end_layout

\begin_layout Subsection*
Abschätzung konstanter Hyperparameter 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Const"

\end_inset


\end_layout

\begin_layout Standard
Eine sehr einfache und schnelle Möglichkeit die Hyperparameter für eine
 Gauss Verteilung zu schätzen, wäre einen Erwartungswert für die Einträge
 in der Korrelationsmatrix zu wählen.
 Da die Korrelation grundlegend zwischen Eins und Null liegen sollte, ist
 dies recht einfach.
 Angenommen der Mittelwert der Korrelationsfunktion soll bei einem Wert
 von 
\begin_inset Formula $c_{erw}=\left\{ c_{erw}\in\mathbb{R}|0\leq c_{erw}\leq1\right\} $
\end_inset

 liegen.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
c_{erw} & =\frac{1}{n^{2}}\underset{i=1}{\overset{i<n}{\sum}}\underset{j=1}{\overset{j<n}{\sum}}e^{-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(e^{\theta_{l}}\left|x_{i,l}-x_{j,l}\right|^{2}\right)}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Nimmt man weiterhin an, dass die einzelnen Korrelationswerte nahezu identisch
 sind:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
c_{erw} & =e^{-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(e^{\theta_{l}}\left|x_{i,l}-x_{j,l}\right|^{2}\right)}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\left(\vec{x}_{i},\vec{x}_{j}\right)\right) & =-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(e^{\theta_{l}}\left|x_{i,l}-x_{j,l}\right|^{2}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Nimmt man ferner an, dass 
\begin_inset Formula $x$
\end_inset

 eine Realisierung einer Zufallsvariablen ist und bildet den Erwartungswert:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\left(\vec{x}_{i},\vec{x}_{j}\right)\right) & =E\left[-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(e^{\theta_{l}}\left|x_{i,l}-x_{j,l}\right|^{2}\right)\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Als weitere Vereinfachung sollen alle Hyperparameter den gleichen Wert haben:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\left(\vec{x}_{i},\vec{x}_{j}\right)\right) & =-\frac{1}{2}e^{\theta}E\left[\underset{l=1}{\overset{l<k}{\sum}}\left(\left|x_{i,l}-x_{j,l}\right|^{2}\right)\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Die beiden Variablen werden als Zufallsvariablen angenommen und der Betrag
 wird aufgrund des Quadrats vernachlässigt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\right) & =-\frac{1}{2}e^{\theta}E\left[\underset{l=1}{\overset{l<k}{\sum}}\left(x_{i,l}-x_{j,l}\right)^{2}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\right) & =-\frac{1}{2}e^{\theta}\underset{l=1}{\overset{l<k}{\sum}}\left(E\left[x_{i,l}^{2}\right]-E\left[2x_{i,l}x_{j,l}\right]+E\left[x_{j,l}^{2}\right]\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Nimmt man nun an, dass die Zufallsvariablen unabhängig sind, gilt 
\begin_inset Formula $E\left[2x_{i,l}x_{j,l}\right]=0$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\right) & =-\frac{1}{2}e^{\theta}\underset{l=1}{\overset{l<k}{\sum}}\left(E\left[x_{i,l}^{2}\right]+E\left[x_{j,l}^{2}\right]\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Die Varianz einer Zufallsvariable 
\begin_inset Formula $X$
\end_inset

 ist definiert durch 
\begin_inset Formula $\textrm{var}\left(X\right)=E\left[X^{2}\right]-E\left[X\right]^{2}$
\end_inset

.
 Die im Modell verwendeten Daten werden grundsätzlich auf einen Erwartungswert
 von Null und eine Standardabweichung von Eins normiert.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
E\left[X\right] & =0
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\textrm{var}\left[X\right] & =1
\end{align*}

\end_inset

Daraus ergibt sich folgende Formel für das verwendete Modell für die Varianz
 der Stützstellen:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\textrm{var}\left[X\right]=E\left[X^{2}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Also
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
E\left[x_{i,l}^{2}\right] & =\textrm{var}\left[x_{i,l}^{2}\right]=1
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
und analog dazu:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
E\left[x_{j,l}^{2}\right] & =\textrm{var}\left[x_{j,l}^{2}\right]=1
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Daraus folgt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\right) & =-\frac{1}{2}e^{\theta}\underset{l=1}{\overset{l<k}{\sum}}\left(1+1\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\right) & =-\frac{1}{2}e^{\theta}2k
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\log\left(-\frac{\log\left(c_{erw}\right)}{k}\right) & =\theta\label{eq:ConstThetaSchatzung}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Mit dieser Formel hat man nun eine Möglichkeit die Hyperparameter zu schätzen.
 Aufgrund der vielen Annahmen und Vereinfachungen ist dieses Verfahren als
 heuristisch einzustufen.
 Die Hyperparameter haben dann allerdings alle denselben Initialwert.
 Zudem ist der erwartete Korrelationswert 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $c_{erw}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang ngerman
 unbekannt, dies kann leicht durch einfaches Ausprobieren gelöst werden,
 da der Wertebereich bekannt ist.
 Man würde also 
\begin_inset Formula $c_{erw}$
\end_inset

 von 0 bis 1 variieren, damit einen Hyperparameter erhalten und mit diesem
 Hyperparameter die Likelihood Funktion berechnen.
 Letztlich wählt man den Hyperparameter, welcher den besten Likelihood Wert
 aufweist.
 
\end_layout

\begin_layout Subsection*
Zufällige Initialisierung der Hyperparameter
\begin_inset CommandInset label
LatexCommand label
name "subsec:Reduktion-der-Stützstellen"

\end_inset


\end_layout

\begin_layout Standard
Eine weitere Möglichkeit eine Initialisierung für die Hyperparameter zu
 finden ist, diese zufällig zu Erzeugen und die entsprechende Likelihood
 Funktion zu berechnen.
 Es würden die Hyperparameter gewählt, welche die beste Likelihood Funktion
 haben.
 Die zufällige Erzeugung ist extrem zeitaufwendig, da für jeden Satz zufälliger
 Hyperparameter die Likelihood Funktion ausgewertet werden muss.
 Um diesen Aufwand zu reduzieren, kann man einfach Stützstellen weglassen.
 Die Likelihood Funktion sollte sich im Vergleich zumindest ähnlich verhalten.
 Statt einer zufälligen Veränderung der Hyperparameter kann man auch ein
 Minimierungsverfahren mit reduzierter Stützstellenzahl verwenden.
 Dies wurde im Code auch umgesetzt.
 Die möglichen Minimierungsverfahren sind dieselben wie sie für das eigentliche
 Training verwendet werden und werden im nächsten Abschnitt beschrieben.
 
\end_layout

\begin_layout Standard
Reduziert man die Anzahl der Stützstellen wird die Korrelationsmatrix dementspre
chend kleiner.
 Dadurch sinkt der Aufwand für die Invertierung und die Matrix Multiplikationen
 erheblich.
 Tests zeigten, dass die Initialisierung durch solch ein Verfahren zwar
 langsamer ist, allerdings konvergiert das Minimierungsverfahren durch die
 bessere Initialisierung deutlich schneller.
 Da bei dem Minimierungsverfahren wieder die volle Anzahl der Stützstellen
 notwendig ist und zusätzlich noch die Ableitungen der Korrelationsmatrix
 berechnet werden müssen, bietet dieses Verfahren durch die bessere Initialisier
ung für das gesamte Training betrachtet eine deutliche Beschleunigung.
 
\end_layout

\begin_layout Standard
Allerdings konnte auch beobachtet werden, dass die Initialisierung häufiger
 zu lokalen Minima führt.
 Eine Begründung für dieses Verhalten wurde noch nicht gefunden und sollte
 weitergehend untersucht werden.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Ein geeignetes Initialisierungverfahren für Ordinary-, Gradient Enhanced-
 und CO-Kriging zu finden ist keine leichte Aufgabe, dennoch kann eine Initialis
ierung das Trainingsergebnis enorm beeinflussen.
 Dies ist insbesondere von großer Bedeutung bei der Verwendung von gradientenbas
ierten Trainingsverfahren wie dem Quasi-Newton.
 Das CO-Kriging stellt hier die größte Herausforderung dar, da bei diesem
 Verfahren nicht nur die Hyperparameter der Korrelationsfunktionen bestimmt
 werden müssen, sondern auch die Prozessvarianz für jede Fidelity des Krigingmod
ells und die Diagonalaufschläge ebenfalls für jede Fidelity.
 
\end_layout

\begin_layout Standard
Eine zufällige Initialisierung der Hyperparameter ist sicherlich ein gutes
 Verfahren zur Initialisierung.
 Der Vorteil bei diesem Verfahren liegt darin, dass während einer Optimierung
 Variation in die Modelle gelangt.
 Dies ist wünschenswert, daes bei einem konstanten Initialisierungsverfahren
 durchaus passieren kann, dass man durchgängig schlechte Modelle hat.
 Dies passiert insbesondere bei hochdimensionalen Parameterräumen.
 Für eine zufällige Initialisierung müssen allerdings Grenzen für die Hyperparam
eter gewählt werden, um den Suchraum zu verkleinern.
 
\end_layout

\begin_layout Standard
Für die minimale Grenze der Hyperparameter eignet sich das in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

 vorgestellte Verfahren, für den Erwartungswert der Korrelationen sollte
 man hier einen hohen Wert wählen, bspw.
 0.99 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\log\left(-\frac{\log\left(0.99\right)}{k}\right) & =\theta_{min}\label{eq:ConstThetaSchatzung-1}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Die maximale Grenze bedarf einer kleinen Änderung, da man in diesem Fall
 wissen möchte, wie groß ein dominierendes 
\begin_inset Formula $\theta$
\end_inset

 ist.
 Nimmt man einen geringen Erwartungswert für die Korrelation an von z.B.
 0.01, so wäre der Schätzwert für ein dominierendes 
\begin_inset Formula $\theta$
\end_inset

 größer, als wenn man annimmt, alle 
\begin_inset Formula $\theta$
\end_inset

 seien gleich.
 Die Formel ändert sich dadurch zu:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\log\left(-\log\left(0.01\right)\right) & =\theta_{max}\label{eq:ConstThetaSchatzung-1-1}
\end{align}

\end_inset


\end_layout

\begin_layout Subsection*
Initialisierung auf Basis bereits vorhandener Kriging Modelle
\end_layout

\begin_layout Standard
Das Kriging Modell wird in der Regel innerhalb einer Optimierung verwendet.
 In der Regel wird mit jedem neuen konvergierten Member ein neues Training
 gestartet und so die Hyperparameter neu bestimmt.
 Grundsätzlich wäre es natürlich äußerst sinnvoll die Hyperparameter aus
 den letzten trainierten Modellen zur Initialisierung zu verwenden.
 Als einfacher Ansatz wäre es z.B.
 möglich einfach immer die Hyperparameter aus dem letzten Training zu Initialisi
erung zu verwenden.
 In folgenden Fällen, kann dies allerdings zu Problemen führen:
\end_layout

\begin_layout Enumerate
Das letzte Modell befindet sich in einem lokalen Minimum der Likelihood
 Funktion
\end_layout

\begin_layout Enumerate
Die Hyperparameter der Kovarianz Funktion(en) sind noch nicht richtig eingestell
t
\end_layout

\begin_layout Standard
Im ersten Fall besteht die Gefahr, dass das Training durch die ungünstige
 Initialisierung im lokalen Minimum bleibt und so nicht die optimalen Hyperparam
eter findet.
 Das wiederum führt zu schlechten Vorhersagen.
 Im Extremfall kann es sogar passieren, dass das lokale Minimum während
 der gesamten Optimierung nicht mehr verlassen wird.
 
\end_layout

\begin_layout Standard
Der zweite Fall ist insbesondere am Anfang der Optimierung interessant,
 denn am Anfang hat man in der Regel nur wenig Samples zur Verfügung und
 damit ist es dem Kriging Training noch nicht möglich die richtigen Hyperparamet
er für die Kovarianzfunktion zu schätzen.
 Diese Fälle treten erfahrungsgemäß leider sehr häufig auf, deshalb sollte
 man auf diese Art der Initialisierung verzichten.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Eine rein zufällige Initialisierung hat allerdings den Nachteil, dass die
 Trainingszeit enorm steigt und die Modelle im Laufe der Optimierung sehr
 unterschiedlich ausfallen können.
 Eine andere Möglichkeit der Initialisierung ist eine Mischform zwischen
 zufälliger Initialisierung und der Verwendung alter Modelle.
 In diesem Fall soll ein Kriterium darüber entscheiden, ob ein altes Kriging
 Modell verwendet werden soll oder eine zufällige Initialisierung durchgeführt
 werden soll.
 Zudem ist es sinnvoll nicht nur das letzte Kriging Modell zu betrachten,
 sondern noch weitere Modelle die während der Optimierung entstanden sind.
 Dies macht insbesondere Sinn, da das Ausprobieren eines vorhandenen Hyperparame
ter Satz im Vergleich zum Training nur einen Bruchteil der Zeit benötigt
 und man so einzelne 
\begin_inset Quotes eld
\end_inset

Ausreißer
\begin_inset Quotes erd
\end_inset

 in den Modellen nicht den weiteren Optimierungsverlauf gefährden.
 Der in AutoOpti verwendete Algorithmus sieht wie folgt aus:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

bestKrigingFile = None
\end_layout

\begin_layout Plain Layout

vector<string> krigingFiles = getLastKrigingFiles(20);
\end_layout

\begin_layout Plain Layout

if(krigingFiles.size() < 20){
\end_layout

\begin_layout Plain Layout

	initType = random;
\end_layout

\begin_layout Plain Layout

	end()
\end_layout

\begin_layout Plain Layout

} 				
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for(i=0; i < krigingFiles.size() ; i++){
\end_layout

\begin_layout Plain Layout

	oldLikelihood = getLikelihood(krigingFiles[i])
\end_layout

\begin_layout Plain Layout

	newLikelihood = calculateLikelihood(krigingFiles[i])
\end_layout

\begin_layout Plain Layout

	if( (newLikelihood < bestLikelihood) 
\end_layout

\begin_layout Plain Layout

	and (newLikelihood < oldLikelihood) 
\end_layout

\begin_layout Plain Layout

	and (newLikelihood < -numberSamples/4.0) ){
\end_layout

\begin_layout Plain Layout

			bestLikelihood =newLikelihood
\end_layout

\begin_layout Plain Layout

			bestKrigingFile = krigingFiles[i]
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(bestKrigingFile==None)
\end_layout

\begin_layout Plain Layout

	initType = random;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Algorithmus startet mit dem Speichern der Dateinamen der letzten 20
 Kriging Modelle aus der laufenden Optimierung (Zeile 2).
 Sind noch keine 20 Kriging Modelle erzeugt worden, soll die Initialisierung
 zufällig erfolgen (Zeile 3-6).
 In der darauffolgenden for Schleife erfolgt nun die Bewertung der einzelnen
 Kriging Modelle.
 Für die Bewertung muss zuerst der alte Likelihood Wert ausgelesen werden,
 dies geschieht in Zeile 10.
 Im nächsten Schritt muss der Likelihood mit der aktuellen Datenbasis neu
 berechnet werden, in der Regel sind an dieser Stelle einige Member zur
 Datenbasis hinzugekommen.
 Dieser Schritt ist numerisch auch der aufwendigste, allerdings muss keine
 Invertierung 
\begin_inset Formula $\mathcal{O\left(\mathrm{n^{3}}\right)}$
\end_inset

 durchgeführt werden, sondern jeweils nur ein Gleichungssystem gelöst werden
 
\begin_inset Formula $\mathcal{O\left(\mathrm{n^{2}}\right)}$
\end_inset

.
 In der darauffolgenden If Abfrage geht es zum einen darum das beste Modell
 der 20 eingelesenen Kriging Modelle zu finden.
 Hierfür wird einfach der kleinste Likelihood verwendet (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Likelihood"

\end_inset

).
 Zudem ist eine weitere Bedingung, dass der neu berechnete Likelihood kleiner
 sein muss, als der bereits eingelesene aus dem vorhergehenden Modell.
 Die Überlegung hierbei ist, dass wenn ein neues Sample eingefügt wird und
 dieses nicht in die angenommene Verteilung passt, die Hyperparameter vollständi
g neu eingestellt werden müssen.
 Im umgekehrten Fall, sollte der Likelihood kleiner werden, da dieser linear
 mit der Sample Anzahl sinkt.
 
\end_layout

\begin_layout Standard
Als letzte Bedingung ist eine absolute Grenze für den Likelihood Wert angegeben,
 diese basiert rein auf Erfahrungswerten und soll sicherstellen, dass grundsätzl
ich zu schlechte Modelle zufällig initialisiert werden.
 Dies ist meistens am Anfang einer Optimierung der Fall, wenn noch nicht
 genügend Daten vorhanden sind, um die Kovarianzfunktion ausreichend gut
 zu schätzen.
 In diesem Fall ist eine zufällige Initialisierung ebenfalls günstiger.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../images/UltraRestart/Vergleich.png
	scale 25

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:RestartRandomLikelihood"

\end_inset

Vergleich verschiedener Initialisierungsverfahren und deren Auswirkung auf
 eine Testoptimierung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../images/UltraRestart/VergleichTrainingsZeit.png
	scale 25

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:RestartRandomTrainingTime"

\end_inset

Vergleich verschiedener Initialisierungsverfahren und deren Auswirkung auf
 eine Testoptimierung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Minimierungsverfahren 
\end_layout

\begin_layout Standard
Innerhalb des Kriging Modells wurden zwei verschiedene mehrdimensionale
 Minimierungsverfahren eingesetzt.
 Beide Verfahren waren bereits in einer institutseigenen Software Bibliothek
 verfügbar.
 
\end_layout

\begin_layout Subsection*
Minimierungsverfahren angelehnt an Resilient Backpropagation
\begin_inset CommandInset label
LatexCommand label
name "subsec:RPROP"

\end_inset


\end_layout

\begin_layout Standard
Das erste hier verwendete Minimierungsverfahren ist angelehnt an ein Trainingsve
rfahren für Neuronale Netzwerke, genannt RPROP (Resilient Backpropagation)
 
\begin_inset CommandInset citation
LatexCommand cite
key "riedmiller1993direct,NNSchiffmann"

\end_inset

 und ist ein Verfahren erster Ordnung.
 Besonderheit des Verfahrens ist, dass es nur das Vorzeichen der partiellen
 Ableitungen verwendet und nicht den Wert selbst.
 
\end_layout

\begin_layout Standard
Die Änderung der Hyperparameter 
\begin_inset Formula $\theta_{i}$
\end_inset

 für den nächsten Iterationsschritt 
\begin_inset Formula $t+1$
\end_inset

 ergibt sich aus der Schrittweite 
\begin_inset Formula $\gamma_{i}$
\end_inset

.
 Diese wird für jeden Hyperparameter einzeln bestimmt und in jeder Iteration
 geändert.
 Die Änderung hängt nur von dem Vorzeichen der entsprechenden partiellen
 Ableitung 
\begin_inset Formula $\frac{\partial f}{\partial\theta_{i}}$
\end_inset

 zum Zeitpunkt t der zu minimierenden Funktion 
\begin_inset Formula $f$
\end_inset

 ab.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\theta_{i}^{t+1} & =\theta_{i}^{t}-\gamma_{i}^{t}\textrm{sgn}\left(\left(\frac{\partial f}{\partial\theta_{i}}\right)^{t}\right)
\end{align*}

\end_inset

 
\end_layout

\begin_layout Standard
Die Schrittweite wird in jedem Iterationsschritt für jeden Hyperparameter
 einzeln angepasst.
 Dies wird über zwei Multiplikatoren erzielt 
\begin_inset Formula $\eta^{+}=\left\{ \eta^{+}\in\mathbb{R}|1<\eta^{+}\right\} $
\end_inset

 und 
\begin_inset Formula $\eta^{-}=\left\{ \eta^{-}\in\mathbb{R}|1>\eta^{-}\right\} $
\end_inset

.
 Ist die entsprechende partielle Ableitung aus dem letzten Schritt multipliziert
 mit dem jetzigen Schritt größer als Null, wird die Schrittweite erhöht,
 indem die Schrittweite 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $\gamma_{i}^{t}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang ngerman
 multipliziert wird mit 
\begin_inset Formula $\eta^{+}$
\end_inset

.
 Wenn die partielle Ableitung aus dem letzten Schritt multipliziert mit
 dem jetzigen Schritt kleiner als Null ist, dann wird die Schrittweite verkleine
rt durch Multiplikation mit 
\begin_inset Formula $\eta^{-}$
\end_inset

.
 Für die Schrittweite wird zudem eine Unter- und Obergrenze (
\begin_inset Formula $\gamma_{min},\gamma_{max}$
\end_inset

) festgelegt.
 
\begin_inset Formula 
\begin{align*}
\gamma_{i}^{t+1} & =\begin{cases}
\min\left(\gamma_{i}^{t}\eta^{+},\gamma_{max}\right) & wenn\left(\frac{\partial f}{\partial\theta_{i}}\right)^{t}\left(\frac{\partial f}{\partial\theta_{i}}\right)^{t-1}>0\\
\max\left(\gamma_{i}^{t}\eta^{-},\gamma_{min}\right) & wenn\left(\frac{\partial f}{\partial\theta_{i}}\right)^{t}\left(\frac{\partial f}{\partial\theta_{i}}\right)^{t-1}<0\\
\gamma_{i}^{t} & sonst
\end{cases}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Bei sehr flachen Bereichen der zu minimierenden Funktion, wo die partiellen
 Ableitungen nur sehr klein sind, würden andere Gradientenverfahren nur
 sehr langsam bis gar nicht mehr vorwärts kommen.
 Da dieses Verfahren allerdings die Größe der Gradienten überhaupt nicht
 berücksichtigt, kann dies nicht passieren.
 Das ist bei der Likelihood Funktion von besonderem Vorteil, da diese bereits
 durch Ihre Definition sehr viele flache Gebiete aufweist.
 
\end_layout

\begin_layout Subsection*
Verbessertes Minimierungsverfahren angelehnt an Resilient Backpropagation
\begin_inset CommandInset label
LatexCommand label
name "subsec:RPROP2"

\end_inset


\end_layout

\begin_layout Standard
Ein sehr großes Problem bei dem RPROP Verfahren ist, dass es relativ viele
 Iterationen benötigt bis es konvergiert.
 In jedem Iterationsschritt muss zum einen der Dichtefunktionswert der Likelihoo
d Funktion berechnet werden und zum anderen die partiellen Ableitungen nach
 den Hyperparametern.
 Die Berechnung der Likelihood Funktion sowie die Berechnung einer partiellen
 Ableitung ist von der Komplexität 
\begin_inset Formula $\mathcal{O}\left(n^{2}\right)$
\end_inset

.
 Es müssen allerdings 
\begin_inset Formula $o$
\end_inset

 partielle Ableitungen gebildet werden, aus diesem Grund kann der numerische
 Aufwand stark variieren.
\end_layout

\begin_layout Standard
Die Lernraten 
\begin_inset Formula $\eta^{+},\eta^{-}$
\end_inset

 sind im RPROP Verfahren konstant, insbesondere bei den anfänglichen Iterationss
chritten führt dies zu einem relativ langsamen Anpassen der Deltas 
\begin_inset Formula $\gamma_{i}^{t}$
\end_inset

.
 Es wäre daher wünschenswert die Lernraten ebenfalls anzupassen.
 Eine gute Möglichkeit ist es verschiedene Lernraten einfach auszuprobieren.
 Der folgende Pseudo Programmcode zeigt die Umsetzung des neuen Verfahrens:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

density = RPROPDensity(eta_plus, eta_minus)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Teste kleinere und größere Lernraten für eta_plus
\end_layout

\begin_layout Plain Layout

for(eta_plusFact=0.9; eta_plusFact<=1.1; eta_plusFact+=0.2){
\end_layout

\begin_layout Plain Layout

	newEtaPlus = eta_plus*eta_plusFact
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if(newEtaPlus<1.2)
\end_layout

\begin_layout Plain Layout

				newEtaPlus=1.2
\end_layout

\begin_layout Plain Layout

	if(newEtaPlus>2.0)
\end_layout

\begin_layout Plain Layout

				newEtaPlus=2.0
\end_layout

\begin_layout Plain Layout

	if(eta_plus==newEtaPlus)
\end_layout

\begin_layout Plain Layout

				continue
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	newDensity = RPROPDensity(newEtaPlus, eta_minus)
\end_layout

\begin_layout Plain Layout

	if(newDensity<density)
\end_layout

\begin_layout Plain Layout

		eta_plus=newEtaPlus
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Teste kleinere und größere Lernraten für eta_minus
\end_layout

\begin_layout Plain Layout

for(eta_minusFact=0.9; eta_minusFact<=1.1; eta_minusFact+=0.2){
\end_layout

\begin_layout Plain Layout

	newEtaMinus = eta_minus*eta_minusFact
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if(newEtaMinus<0.4)
\end_layout

\begin_layout Plain Layout

				newEtaMinus=0.4
\end_layout

\begin_layout Plain Layout

	if(newEtaMinus>0.7)
\end_layout

\begin_layout Plain Layout

				newEtaMinus=0.7
\end_layout

\begin_layout Plain Layout

	if(eta_minus==newEtaMinus)
\end_layout

\begin_layout Plain Layout

				continue
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	newDensity = RPROPDensity(eta_plus, newEtaMinus)
\end_layout

\begin_layout Plain Layout

	if(newDensity<density)
\end_layout

\begin_layout Plain Layout

		eta_minus=newEtaMinus
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In einem Iterationsschritt, wird dann zuerst der Dichtefunktionswert  mit
 den bisherigen Lernraten 
\begin_inset Formula $\eta^{+},\eta^{-}$
\end_inset

 berechnet.
\end_layout

\begin_layout Standard
Danach wird dann zuerst 
\begin_inset Formula $\eta^{+}$
\end_inset

 leicht erhöht oder verringert und überprüft, ob es im Bereich von 
\begin_inset Formula $2.0>\eta^{+}>1.2$
\end_inset

 liegt (diese Werte sind reine Erfahrungswerte).
 Sollte sich das neue 
\begin_inset Formula $\eta^{+}$
\end_inset

 nicht geändert haben, so wird sich die Berechnung der Dichtefunktion gespart.
 Gewählt wird die Lernrate mit dem geringsten Dichtefunktionswert.
 Für die Lernrate 
\begin_inset Formula $\eta^{-}$
\end_inset

 gilt im Prinzip dasselbe.
 
\end_layout

\begin_layout Standard
Für diese Art der Lernratenregelung sind maximal 4 neue Dichtefunktionsauswertun
gen notwendig, im Gegenzug hat man allerdings eine deutliche Verringerung
 der Iterationsanzahl und muss somit deutlich weniger partielle Ableitungen
 bestimmen.
 Diese sollte insbesondere für das CO-Kriging von großem Vorteil sein.
\end_layout

\begin_layout Standard
Um das Verfahren zu validieren, wurde eine Datenbasis aus einer aktuellen
 Optimierung für einen gegenläufigen Rotor verwendet (
\color red
Referenz
\color inherit
).
 Es gab ca.
 113 freie Parameter und für das CO-Kriging somit 228 Hyperparameter (130*2
 und 2x die Prozessvarianzen der Kovarianzfunktionen) und die Datenbasis
 enthielt zu diesem Zeitpunkt 373 Member.
 Das CO-Kriging wurde mit zufälligen Hyperparametern initialisiert und 10x
 mit dem RPROP Verfahren trainiert und 10x mit dem neuen RPROP2 Verfahren.
 Die Vorhersagen der fertig trainierten Ersatzmodelle wurden dann anhand
 einer Testdatenbasis validiert und ein mittlerer Vorhersagefehler bestimmt.
 Die folgenden Tabellen zeigen die Ergebnisse beider Verfahren:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RPROP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mittelwert
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Standardabweichung
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainingszeit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
346.3s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100.9s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mittlerer Fehler
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0201
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00565
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainingsiterationen
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
781
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
165
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RPROP2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mittelwert
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Standardabweichung
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainingszeit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
186s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50.29s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mittlerer Fehler
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0149
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0031
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainingsiterationen
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
398
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
86
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Man kann sehen, dass das RPROP Verfahren in diesem Beispiel die 1.86 fache
 Zeit benötigt um Konvergenz zu erreichen.
 Dies wird hauptsächlich durch die deutlich geringere Iterationsanzahl erreicht.
 Die mittleren Fehler sind in etwa vergleichbar, die etwas geringeren Fehler
 beim RPROP2 sind mit hoher Wahrscheinlichkeit zufälliger Natur.
 
\end_layout

\begin_layout Standard
Die folgende Abbildung zeigt nochmal den gemittelten Trainingsverlauf beider
 Verfahren.
 Die rote und schwarze Kurve stellt den mittleren Dichtefunktionswert über
 den Iterationsschritten dar.
 Die Fehlerbalken sind die Standardabweichungen der verschiedenen Trainings.
 Auch hier lässt sich gut erkennen, dass das RPROP2 Verfahren eine deutlich
 schnelleren Konvergenzverlauf hat, insbesondere am Anfang.
 Dies wird durch die schneller eingestellten Deltas erreicht.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../images/RPROP2/Vergleich.png
	scale 25

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Natürlich bleibt zu beachten, dass das Verfahren bei einer sehr geringen
 Anzahl von Hyperparametern auch durchaus langsamer sein kann.
 
\end_layout

\begin_layout Subsection*
Quasi Newton
\begin_inset CommandInset label
LatexCommand label
name "subsec:Quasi-Newton"

\end_inset


\end_layout

\begin_layout Standard
Das zweite implementierte Minimierungsverfahren ist ein Verfahren höherer
 Ordnung namens Quasi Newton.
 Basis für diese Art der mehrdimensionalen Minimierung ist eine Taylor Approxima
tion zweiten Grades, wobei 
\begin_inset Formula $t$
\end_inset

 der Iterationsschritt ist und 
\begin_inset Formula $\mathbf{H}$
\end_inset

 die Hesse Matrix: 
\begin_inset Formula 
\begin{align*}
f\left(\vec{\theta}\right) & \approx f\left(\vec{\theta}_{t}\right)+\left(\vec{\theta}-\vec{\theta}_{t}\right)^{T}\nabla f\left(\vec{\theta}_{k}\right)+\frac{1}{2}\left(\vec{\theta}-\vec{\theta}_{t}\right)^{T}\mathbf{H}\left(\vec{\theta}_{t}\right)\left(\vec{\theta}-\vec{\theta}_{t}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Die entsprechende Ableitung dieser Funktion muss im Minimum oder Maximum
 der Funktion Null ergeben:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\nabla f\left(\vec{\theta}\right) & \approx\nabla f\left(\vec{\theta}_{t}\right)+\mathbf{H}\left(\vec{\theta}_{t}\right)\left(\vec{\theta}-\vec{\theta}_{t}\right)=0
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Besonderheit bei der Quasi Newton Methode ist, dass die Hesse Matrix 
\begin_inset Formula $\mathbf{H}$
\end_inset

, nicht direkt berechnet werden muss, sondern sukzessive über die Gradienten
 angenähert wird.
 Vorteil des Verfahrens ist, dass es deutlich schneller konvergiert als
 das bereits vorgestellte Verfahren erster Ordnung.
 Allerdings ist es weniger robust und kann in flachen Gebieten der Funktion
 langsam bis gar nicht konvergieren.
 Die exakte Umsetzung des Algorithmus und weitere Details können in 
\begin_inset CommandInset citation
LatexCommand cite
key "press2007numerical,gill1981practical,gill2007numerical"

\end_inset

 gefunden werden.
\end_layout

\begin_layout Subsection
Softwaretechnische Umsetzung
\begin_inset CommandInset label
LatexCommand label
name "sec:MinimierungSoftwaretechnische-Umsetzung"

\end_inset


\end_layout

\begin_layout Subsection*
Klasse für die Steuerung des Trainings
\end_layout

\begin_layout Standard
In diesem Abschnitt soll der Ablauf und die dazugehörige Klasse für ein
 Training eines Kriging Modells erklärt werden.
 Das UML Diagramm 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLTrainer"

\end_inset

 zeigt die Klasse Trainer, welche das Training steuern und verwalten soll.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/UMLTrainer.PNG
	scale 34

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:UMLTrainer"

\end_inset

UML Diagramm der Trainer Klasse, welche das Training des Kriging Modells
 steuert
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Methoden und auch Attribute der Trainer Klassen sollen am Ablauf des
 Trainings erläutert werden.
 Ein Training besteht im Wesentlichen aus den folgenden Schritten:
\end_layout

\begin_layout Enumerate
Der erste Schritt besteht aus der Erzeugung eines Trainer Objekts.
 Dem Konstruktor müssen drei Parameter übergeben werden: Der Name der Konfigurat
ionsdatei (configFile), der Name der Datenbankdatei (DataBaseFile) und die
 zu trainierende Funktion.
 Der Parameter objectString gibt an, welcher der Funktionswerte aus der
 Datenbankdatei verwendet werden soll, diese kann zu einem Variablensatz
 mehrere verschiedene Funktionen beinhalten.
 Innerhalb des Konstruktors werden dann einige Schritte ausgeführt, um das
 Kriging Modell zu initialisieren.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Einlesen der Datenbankdatei.
\end_layout

\begin_layout Enumerate
Einlesen der Konfigurationsdatei durch die Methode readConfig(), an dieser
 Stelle werden auch die zu verwendenden Korrelationsfunktionen gesetzt (Attribut
 correlationMap, siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Korrelationsfunktionen"

\end_inset

 ).
 Zudem wird ein DensityFunktion Objekt erzeugt und in dem Attribut densityFuncti
on gespeichert, siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Maximum-Likelihood-für"

\end_inset

.
\end_layout

\begin_layout Enumerate
Normalisierung der Stützstellen und der dazugehörigen Funktionswerte (mit
 der Methode normalizeData())
\end_layout

\begin_layout Enumerate
Initialisierung der Hyperparameter, siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Starten der train() Methode des Trainer Objekts.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Erzeugung eines Minimierer Objekts, je nach gewähltem Minimierer Typ.
 Die entsprechende Klassenstruktur wird im nächsten Abschnitt behandelt
\end_layout

\begin_layout Enumerate
Starten des Minimierers
\end_layout

\end_deeper
\begin_layout Enumerate
Nach erfolgreichem Training wird eine XML Datei geschrieben, in der im Wesentlic
hen alle Ergebnisse des Trainings stehen.
 Es werden die gefundenen Hyperparameter, die Korrelationsmatrix, einige
 Vektoren usw.
 gespeichert um bei einer späteren Vorhersage diese Werte nicht mehr berechnen
 zu müssen.
 Diese XML Datei beinhaltet also ein fertiges Kriging Modell.
\end_layout

\begin_layout Subsection*
Klassenstruktur zur Steuerung der Minimierungsverfahren
\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLMinimizer"

\end_inset

 wird das UML Diagramm der Klassenstruktur für die Minimierungsverfahren
 gezeigt.
 Es gibt eine abstrakte Superklasse MinimizerInterface, welche hier als
 Interface zu verstehen ist.
 Diese schreibt die notwendigen Methoden für die Subklassen vor.
 Die Subklassen sollen dann die konkreten Minimierungsverfahren realisieren.
 Die einzige öffentliche Methode callMinimizer ist dazu da, um von außen
 den entsprechenden Minimierer aufzurufen und die Minimierung zu starten.
 In der Methode function muss die zu minimierende Funktion berechnet werden.
 Die Rückgabe des berechneten Funktionswertes wird über eine Referenz des
 Parameters functionValue gemacht, eine Referenz wird aus Performancegründen
 verwendet.
 Der Parameter variables vom Typ vector, soll die entsprechenden Variablen
 beinhalten.
 Zu diesen Variablen wird dann der Funktionswert berechnet.
 Wie die Berechnung vor sich geht und was genau berechnet wird, ist den
 einzelnen Subklassen überlassen, diese müssen sich nur an die Interface
 Spezifikation halten.
 
\end_layout

\begin_layout Standard
Die Methode functionDerivative soll den Gradienten des Funktionswertes abgeleite
t nach den Variablen berechnen.
 Der Gradient wird über die Referenz auf den Parameter derivatives zurückgegeben.
 Zusätzlich soll es möglich sein, Nebenbedingungen für die Minimierung vorzugebe
n.
 Dies wird über die Methode constraintFunction umgesetzt.
 Die Nebenbedingung muss so formuliert werden, dass diese bei einem Wert
 größer oder gleich Null eingehalten wird und unter Null nicht eingehalten
 wird.
 Zudem muss der Gradient der einzelnen Nebenbedingungsfunktionen bereitgestellt
 werden und zwar über die Methode constraintFunctionDerivative.
 
\end_layout

\begin_layout Standard
Um die Konvergenz des Verfahrens festzustellen, wird die Methode convergenceChec
k verwendet.
 Der Methode müssen drei Parameter übergeben werden, der erste Parameter
 ist ein vector mit den Funktionswerten der bisher durchgeführten Iterationen.
 Der zweite Parameter ist ein mehrdimensionaler vector, welcher alle Variablenwe
rte der bisherigen Iterationen beinhaltet und der letzte Parameter der Methode
 ist die Nummer der aktuellen Iteration.
 Das entsprechende Konvergenzkriterium muss dann innerhalb der Funktion
 umgesetzt werden.
 Beispielsweise könnte man das Verfahren als konvergiert ansehen, wenn die
 Funktions- und Parameterwerte sich seit einigen Iterationen nicht mehr
 verändert haben oder die Veränderung unterhalb einer bestimmten Schwelle
 liegt.
\end_layout

\begin_layout Standard
Die Methode saveFunction stellt eine Art von Rettungsfunktion dar.
 Diese soll aufgerufen werden, wenn das Verfahren in irgendeiner Form numerisch
 instabil wird.
 Beispielsweise könnte eine einfache Maßnahme sein, die Funktionswerte zufällig
 zu verändern, in der Hoffnung auf ein anderes (globaleres) Minimum zu treffen.
\end_layout

\begin_layout Standard
Die jeweiligen Subklassen implementieren in diesem Fall noch ein Attribut
 vom Typ DensityFunction, da diese die LikeliHood Funktion minimieren sollen
 und die Klasse DensityFunction alle nötigen Methoden für die Berechnung
 dieser liefert, siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Likelihood"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/UMLMinimizer.PNG
	scale 34

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:UMLMinimizer"

\end_inset

UML Diagramm der Klassenstruktur der Minimierungsalgorithmen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das folgende Listing zeigt die Umsetzung der Methode function in der Subklasse
 MinimizerInterfaceRPROP.
 Die Methode ist in diesem Fall vereinfacht dargstellt, einige Ausgabefunktionen
 wurden aus Platzgründen entfernt.
 Die wichtigen Teile der Methode sind allerdings unverändert.
 Der Methodenkopf entspricht dem aus dem UML Diagramm.
 In Zeile 5 werden die aktuellen Variablen (in diesem Fall die Hyperparameter)
 dem Objekt densityFunction zu Berechnung der Likelihood Funktion übergeben.
 In den Zeilen 7-18 wird dann die eigentliche Likelihood Funktion innerhalb
 eines try-catch Blocks berechnet, um eventuelle Exceptions fangen zu können.
 Wird eine Exception geworfen, so wird eine Fehlermeldung ausgegeben und
 eine -1 als zurückgegeben.
 Zusätzlich kann wie in Zeile 15 die entsprechende Korrelationsmatrix bei
 Auftreten einer Exceptions ausgegeben werden, in diesem Fall wird die Matrix
 in eine Datei geschrieben.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int MinimizerInterfaceRPROP<T,B>::function(	vector<double> &hyperparameter,
 
\end_layout

\begin_layout Plain Layout

												double &likelihood, 
\end_layout

\begin_layout Plain Layout

												size_t *iteration){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	densityFunction->setAllHyperparameter(hyperparameter);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	try{
\end_layout

\begin_layout Plain Layout

		likelihood = densityFunction->calcDensity();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	catch(InvCholNotIdentity &e){
\end_layout

\begin_layout Plain Layout

		cout <<"RPROP Func (InvCholNotIdentity):"<<endl;
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	catch(ChodecNotPosDef &Exception){
\end_layout

\begin_layout Plain Layout

		densityFunction->getCorrelationMatrixRef().saveAsAscii("CorrMatFailed_sav");
\end_layout

\begin_layout Plain Layout

		cout <<"RPROP Func (ChodecNotPosDef):"<<endl;
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ein zusätzliches Problem bei der Implementierung der Minimierungsverfahren
 war, dass diese in einer externen Bibliothek in Form von C Funktionen vorlagen
 und diese Funktionen Funktionspointer als Parameter erwarten.
 Die zu übergebenden Funktionen entsprechen den Funktionen aus der MinimizerInte
rface Klasse, also z.B.
 function oder functionDerivative.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},tabsize=4"
inline false
status open

\begin_layout Plain Layout

	quasiNewton(nrHyperparam,
\end_layout

\begin_layout Plain Layout

				nrConstraints, 
\end_layout

\begin_layout Plain Layout

				variables,
\end_layout

\begin_layout Plain Layout

				function(),
\end_layout

\begin_layout Plain Layout

				functionDerivatives(),
\end_layout

\begin_layout Plain Layout

				constraintFunction(),
\end_layout

\begin_layout Plain Layout

				constrainFunctionDerivative(),
\end_layout

\begin_layout Plain Layout

				convergenceCheck())
\end_layout

\end_inset


\begin_inset listings
lstparams "basicstyle={\scriptsize},tabsize=4"
inline false
status open

\begin_layout Plain Layout

	rprop(  	nrHyperparam,
\end_layout

\begin_layout Plain Layout

				nrConstraints, 
\end_layout

\begin_layout Plain Layout

				variables, 
\end_layout

\begin_layout Plain Layout

				variablesLowerLimit,
\end_layout

\begin_layout Plain Layout

				variablesUpperLimit,
\end_layout

\begin_layout Plain Layout

				function(),
\end_layout

\begin_layout Plain Layout

				functionDerivatives(),
\end_layout

\begin_layout Plain Layout

				constraintFunction(),
\end_layout

\begin_layout Plain Layout

				constrainFunctionDerivative(),
\end_layout

\begin_layout Plain Layout

				convergenceCheck())
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Schwierigkeit ergibt sich in diesem Fall dadurch, dass die Funktionspointer
 in C++ eine Zuordnung zu dem entsprechenden Objekt zu dem die Funktionen
 gehören, benötigen.
 Das folgende Listing soll das Problem verdeutlichen: 
\begin_inset listings
lstparams "basicstyle={\scriptsize},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

MinimizerInterfaceRPROP testObject;
\end_layout

\begin_layout Plain Layout

int (MinimizerInterfaceRPROP::*ptr2)(vector<double> &, double &, size_t
 *) = 
\end_layout

\begin_layout Plain Layout

											&MinimizerInterfaceRPROP::function;
\end_layout

\begin_layout Plain Layout

(testObject.*ptr2)(variables, functionValue, iteration);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Zeile 1 wird ein Test Objekt vom Typ MinimizerInterfaceRPROP erzeugt
 (der Konstruktoraufruf wurde hier absichtlich vereinfacht).
 In den Zeilen 2-3 wird ein Funktionspointer namens ptr2 erzeugt, dieser
 zeigt auf eine Methode der Klasse MinimizerInterfaceRPROP mit den entprechenden
 Parametern der Methode function.
 Zusätzlich erfolgt in diesen Zeilen eine Zuweisung des Pointers der Methode
 durch 
\shape italic

\begin_inset Quotes eld
\end_inset

&MinimizerInterfaceRPROP::function
\shape default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
In Zeile 4 wird ein beispielhafter Aufruf des Funktionspointers auf dem
 Objekt testObject gemacht.
 Dieses Beispiel würde so funktionieren.
 Das eigentliche Problem besteht aber nun darin, dass man in Zeile 2 statt
 der Subklasse MinimizerInterfaceRPROP die abstrakte Klasse MinimizerInterface
 verwenden möchte.
 Da diese Funktionspointer Parameter einer Funktion darstellen, wäre dieses
 Verhalten sehr wichtig, weil so alle Methodenpointer der Subtypen von Minimizer
Interface angenommen werden würden.
 Andernfalls müsste man die Funktion rprop oder quasiNewton für jeden Subtypen
 von MinimizerInterface neu implementieren.
 Leider sind die Möglichkeiten polymorpher Programmierung in C++ stark begrenzt
 und solch ein Konstrukt wird von der Sprache nicht unterstützt.
 
\end_layout

\begin_layout Standard
Um dieses Problem zu umgehen, werden Funktionsobjekte 
\begin_inset CommandInset citation
LatexCommand cite
key "boostfunction"

\end_inset

 der Boost Bibliothek verwendet.
 Mit dieser Bibliothek ist es möglich, die entsprechenden Methoden als Objekt
 an die entsprechenden externen Funktionen (z.B.
 rprop und quasiNewton) zu übergeben.
 Das folgende Listing soll die prinzipielle Funktionsweise von Boost Funktionsob
jekten erklären:
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

class X {
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

 int foo(int); 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

boost::function<int (X*, int)> f;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

X x;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f = &X::foo;
\end_layout

\begin_layout Plain Layout

f(&x, 10);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In diesem Beispiel soll ein Funktionsobjekt der Methode foo der Klasse X
 erzeugt werden.
 Zu diesem Zweck wird ein Funktionsobjekt in Zeile 6 initialisiert, wobei
 innerhalb der eckigen Klammern zuerst der Rückgabewert int und danach die
 Parameter der Funktion (X*, int) übergeben werden.
 Der Parameter X* muss vorhanden sein, da innerhalb C++ der erste Parameter
 einer Methode immer das Objekt selbst ist.
 Im Normalfall wird dies jedoch automatisch umgesetzt und ist daher unsichtbar
 für den Programmierer.
 Die Zuweisung der Methode auf das Funktionsobjekt erfolgt dann in Zeile
 10.
 Der Aufruf des Funktionsobjekts erfolgt nach normaler C++ Syntax, siehe
 Zeile 11.
\end_layout

\begin_layout Standard
Für die Klasse MinimizerInterfaceRPROP würde ein solches Funktionsobjekt
 wie folgt aussehen:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},tabsize=4"
inline false
status open

\begin_layout Plain Layout

boost::function<int (MinimizerInterfaceRPROP*, vector<double> &, double
 &, size_t *)> fPointer;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Problem dass das Funktionsobjekt unabhängig vom Subtyp der Klasse MinimizerI
nterface sein soll, bleibt allerdings bestehen.
 Um dies nun zu umgehen, kann man boost::bind verwenden.
 Mit dieser Funktionalität ist es möglich, Parameter von Funktionen zu verändern.
 
\end_layout

\begin_layout Standard
Das nächste Listing soll dies verdeutlichen, es handelt sich hier um ein
 stark vereinfachtes Beispiel um die grundlegende Funktionalität zu erklären.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void external_rprop(boost::function<int (vector<double> &, double &, size_t
 *)> fPointer){...}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class MinimizerInterfaceRPROP: public MinimizerInterface{
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

	void callMinimizer(){
\end_layout

\begin_layout Plain Layout

		boost::function<int (vector<double> &, double &, size_t *)> fPointer;
\end_layout

\begin_layout Plain Layout

		fPointer = boost::bind(&MinimizerInterfaceRPROP::function, (*this), _1,
 _2, _3);
\end_layout

\begin_layout Plain Layout

		external_rprop(fPointer);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

private:
\end_layout

\begin_layout Plain Layout

	int function(vector<double> &vars, double &f, size_t *it) {...}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Zeile 1 ist eine Funktion definiert, welche einer externen Bibliotheksfunktio
n entspricht, beispielsweise einem externen RPROP Algorithmus.
 Dieser Algorithmus benötigt nun ein Funktionsobjekt, mit dem er die zu
 minimierende Funktion berechnen kann.
 Wie man sehen kann, benötigt das hier definierte Funktionsobjekt als ersten
 Parameter nicht mehr das aufrufende Objekt selbst.
 
\end_layout

\begin_layout Standard
Analog zum Originalcode wird als nächstes ist die Subklasse MinimizerInterfaceRP
ROP definiert, welche Subklasse der abstrakten Klasse MinimizerInterface
 ist.
 Diese Klasse besitzt nun eine öffentliche Methode namens callMinimizer.
 Diese Methode soll von irgendeinem Clienten ausgeführt werden können, um
 den Minimierungsalgorithmus starten.
 
\end_layout

\begin_layout Standard
Der erste Schritt innerhalb der Methode callMinimizer ist die Erzeugung
 eines boost Funktionsobjekts, auch hier ist der erste Parameter nicht mehr
 das aufrufende Objekt selbst (also MinimizerInterfaceRPROP*).
 In Zeile 7, wird nun ein Funktionsobjekt mit boost bind erzeugt.
 Mit bind ist es Möglich, die Methodenparameter zu verändern.
 Dies wird dazu verwendet das Funktionsobjekt quasi unabhängig von der aufgerufe
nen Klasse zu machen.
 Dem ersten Parameter für bind wird der Funktionspointer übergeben, der
 zweite Parameter ist das Objekt selbst.
 Mit boost bind ist es nun möglich, das Objekt einfach standardmäßig über
 den this Zeiger fest zu binden.
 Dieser taucht im kreierten Funktionsobjekt nicht mehr auf und man hat die
 gewünschte Unabhängigkeit erreicht.
 Die nächsten drei Parameter _1,_2,_3 sind Platzhalter für die später nötigen
 Parameter des Funktionsobjekts (also vector<double> &, double &, size_t
 *).
\end_layout

\begin_layout Standard
In der nächsten Zeile wird das Funktionsobjekt an die externe Bibliotheksfunktio
n übergeben und diese kann die Funktion nun nach belieben verwenden.
 
\end_layout

\begin_layout Subsection
Renormalisierung der Hyperparameter 
\end_layout

\begin_layout Standard
Möchte man mit bestehenden Hyperparametern, aber einer neuen oder erweiterten
 Datenbasis Vorhersagen treffen, so ändern sich die Erwartungswerte der
 zu trainierenden Funktion und deren Parametern.
 Da das alte Training und damit auch die Daten des Trainings mit den alten
 Erwartungswerten und Standartabweichungen normalisiert worden sind, müssen
 die Hyperparameter ebenfalls renormalisiert werden.
 Ansonsten würde man für die Kovarianz zwischen 2 Membern unterschiedliche
 Werte bekommen.
\end_layout

\begin_layout Standard
Daraus ergibt sich folgende notwendige Bedingung:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
cov\left(\vec{x}_{1alt},\vec{x}_{2alt}\right) & =cov\left(\vec{x}_{1neu},\vec{x}_{2neu}\right)\label{eq:RenormCovBedingung}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Wobei 
\begin_inset Formula $x_{real}$
\end_inset

 den unnormierten Parameter darstellt, 
\begin_inset Formula $\mu_{alt}$
\end_inset

 und 
\begin_inset Formula $\sigma_{alt}$
\end_inset

 stellen den alten Erwartungswert sowie die Standartabweichung der Parameter
 dar.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\vec{x}_{1alt} & =\left[\begin{array}{c}
\frac{x_{1,1real}-\mu_{1alt}}{\sigma_{1alt}}\\
\vdots\\
\frac{x_{1,nreal}-\mu_{nalt}}{\sigma_{nalt}}
\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Für 
\begin_inset Formula $\vec{x}_{2alt}$
\end_inset

, sowies 
\begin_inset Formula $\vec{x}_{1neu}$
\end_inset

 gilt analoges.
\end_layout

\begin_layout Standard
Die Bedingung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:RenormCovBedingung"

\end_inset

 soll anhand eines Beispiels erläutert werden, es wird hierfür eine Gauss
 Korrelationsfunktion mit einem Hyperparameter verwendet:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & \sigma_{KriAlt}^{2}e^{-\frac{1}{2}e^{\theta_{alt}}\left|\frac{x_{1real}-\mu_{alt}}{\sigma_{alt}}-\frac{x_{2real}-\mu_{alt}}{\sigma_{alt}}\right|^{2}}=\sigma_{KriNeu}^{2}e^{-\frac{1}{2}e^{\theta_{neu}}\left|\frac{x_{1real}-\mu_{neu}}{\sigma_{neu}}-\frac{x_{2real}-\mu_{neu}}{\sigma_{neu}}\right|^{2}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & \sigma_{KriAlt}^{2}e^{-\frac{1}{2}e^{\theta_{alt}}\frac{1}{\sigma_{alt}^{2}}\left|x_{1real}-x_{2real}\right|^{2}}=\sigma_{KriNeu}^{2}e^{-\frac{1}{2}e^{\theta_{neu}}\frac{1}{\sigma_{neu}^{2}}\left|x_{1real}-x_{2real}\right|^{2}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Geht man nun davon aus, dass die Kriging Varianz sich nicht ändert:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\sigma_{KriAlt}^{2} & =\sigma_{KriNeu}^{2}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Wobei diese Bedingung im Code unbedingt erfüllt sein muss.
 Im Code ist es so umgesetzt, dass zuerst die Kovarianzmatrix mit der alten
 Krigingvarianz erzeugt wird und danach der Likelihood Schätzer für die
 Krigingvarianz aufgerufen wird, siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:sSqrLikelihoodOrdinary"

\end_inset

.
\end_layout

\begin_layout Standard
Dieser Schätzer sollte im Normalfall allerdings auf eine neue Krigingvarianz
 kommen, wodurch es im weiteren Verlauf zu großen Problemen kommen kann.
 Insbesondere bei der Vorhersage, wo für den Kovarianzvektor 
\begin_inset Formula $\vec{c}$
\end_inset

 (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KoKrigingKovarianzVorhersage"

\end_inset

) dann die neue Krigingvarianz verwendet werden würde.
 Kovarianzmatrix und Vektor würden dann nicht mehr zusammen passen.
\end_layout

\begin_layout Standard
Die Formel lässt sich damit weiterhin vereinfachen:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & e^{-\frac{1}{2}e^{\theta_{alt}}\frac{1}{\sigma_{alt}^{2}}\left|x_{1real}-x_{2real}\right|^{2}}=e^{-\frac{1}{2}e^{\theta_{neu}}\frac{1}{\sigma_{neu}^{2}}\left|x_{1real}-x_{2real}\right|^{2}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & e^{\theta_{alt}}\frac{1}{\sigma_{alt}^{2}}\left|x_{1real}-x_{2real}\right|^{2}=e^{\theta_{neu}}\frac{1}{\sigma_{neu}^{2}}\left|x_{1real}-x_{2real}\right|^{2}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & e^{\theta_{alt}}\frac{1}{\sigma_{alt}^{2}}=e^{\theta_{neu}}\frac{1}{\sigma_{neu}^{2}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & e^{\theta_{alt}}\frac{\sigma_{neu}^{2}}{\sigma_{alt}^{2}}=e^{\theta_{neu}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & \log\left(e^{\theta_{alt}}\frac{\sigma_{neu}^{2}}{\sigma_{alt}^{2}}\right)=\theta_{neu}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & \theta_{alt}+\log\left(\frac{\sigma_{neu}^{2}}{\sigma_{alt}^{2}}\right)=\theta_{neu}
\end{align*}

\end_inset


\end_layout

\begin_layout Section
Algorithmische Effizienz steigern
\end_layout

\begin_layout Subsection
Filtern von unwichtigen Samples
\end_layout

\begin_layout Standard
Insbesondere beim Gradient-Enhanced-Kriging sind sehr hohe Matrixgrößen
 von über 10000x10000 schnell erreicht.
 Aus diesem Grund ist es sinnvoll nur Samples auszusuchen, welche der Optimierun
g einen wirklichen Zugewinn bringen.
 Den Einfluss eines Samples auf den Optimierungsverlauf zu berechnen ist
 sehr schwierig, aus diesem Grund wäre es auch aktzeptabel die Samples herauszuf
iltern, welche nur einen kleinen Einfluss auf das Ersatzmodell haben.
 Eine einfach Möglichkeit wäre die Korrelationsmatrix selbst, in dieser
 stehen die Korrelationen zwischen allen Samples untereinander.
 Samples mit sehr hohen Korrelationen haben folglich nur einen sehr kleinen
 Abstand zueinander.
 Der Abstand wird allerdings über die im Kriging verwendeten Modell-Korrelations
funktionen bestimmt und diese sind sehr stark abhängig von den verwendeten
 Hyperparametern.
 Die Hyperparameter werden vom Training allerdings erst bei ausreichender
 Sample Anzahl vernünftig geschätzt.
 Dies kann im schlimmsten Fall dazu führen, dass man Samples aufgrund einer
 falsch geschätzten Metrik entfernt und den Optimierungsverlauf so empfindlich
 stört.
 
\end_layout

\begin_layout Standard
....
\end_layout

\begin_layout Standard
....
\end_layout

\begin_layout Standard
....
\end_layout

\begin_layout Subsection
Inverse durch Gleichungssysteme ersetzen 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Inverse-durch-Gleichungssysteme"

\end_inset


\end_layout

\begin_layout Standard
Mit Hilfe der Cholesky Zerlegung können lineare Gleichungssysteme sehr effizient
 gelöst werden.
 Dies kann man sich zunutze machen, um bei der Likelihood Berechnung auf
 die Bestimmung der Inversen verzichten.
 Die Methodik ist weit verbreitet und soll in dieser Arbeit daher nur kurz
 erläutert werden.
 
\end_layout

\begin_layout Standard
Der Likelihoodterm (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Maximum-LikelihoodCovariance"

\end_inset

) sieht wie folgt aus:
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\log(N)= & -\log\left(\det(\mathbf{\mathbf{Cov}})\right)-\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{Cov}}^{-1}\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Die Determinante der Kovarianzmatrix wird aus der Cholesky Zerlegung gewonnen
 (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Cholesky-Zerlegung"

\end_inset

).
 Der quadratische Term 
\begin_inset Formula $\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{Cov}}^{-1}\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)$
\end_inset

 beinhaltet allerdings noch die Inverse Kovarianzmatrix.
 Dieser kann mit Hilfe der Cholesky Zerlegung gewonnen werden, wir führen
 hierfür einen Hilfsvektor 
\begin_inset Formula $\vec{e}$
\end_inset

 ein:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)=\vec{e}
\]

\end_inset


\end_layout

\begin_layout Standard
Zusätzlich noch einen Hilfsvektor 
\begin_inset Formula $\vec{d}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbf{\mathbf{Cov}}^{-1}\vec{e}=\vec{d}
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
Bei der Cholesky Zerlegung wird die Matrix 
\begin_inset Formula $\mathbf{\mathbf{Cov}}$
\end_inset

 in ein Produkt aus einer unteren Dreicksmatrix und deren Transponierten
 zerlegt, die Dreiecksmatrix 
\begin_inset Formula $\mathbf{L}$
\end_inset

 gilt an dieser Stelle als bekannt:
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\mathbf{L}\mathbf{L}^{T} & =\mathbf{\mathbf{Cov}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Daraus folgt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbf{\mathbf{\left(\mathbf{L}\mathbf{L}^{T}\right)}}^{-1}\vec{e}=\vec{d}
\]

\end_inset


\begin_inset Formula 
\[
\vec{e}=\vec{d}\mathbf{\mathbf{\mathbf{L}\mathbf{L}^{T}}}
\]

\end_inset


\end_layout

\begin_layout Standard
Führt man nun folgende Substitution ein:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vec{d_{tmp}}=\vec{d}\mathbf{\mathbf{\mathbf{L}}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vec{e}=\vec{d_{tmp}}\mathbf{\mathbf{\mathbf{L}^{T}}}
\]

\end_inset


\end_layout

\begin_layout Standard
So kann dieses Gleichungssystem durch eine einfache Rückwärtssubstitution
 
\begin_inset Formula $\vec{d}_{tmp}$
\end_inset

gelöst werden.
 Danach kann direkt das folgende Gleichungssystem durch Vorwärtseinsetzen
 gelöst werden und der Vektor 
\begin_inset Formula $\vec{d}$
\end_inset

 ist hiermit bekannt.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vec{d_{tmp}}=\vec{d}\mathbf{\mathbf{\mathbf{L}}}
\]

\end_inset


\end_layout

\begin_layout Standard
Der Aufwand hierfür ist deutlich geringer als bei der Invertierung, da nur
 zwei Gleichungssysteme gelöst werden müssen anstatt 
\begin_inset Formula $n$
\end_inset

 Gleichungssysteme für die gesamte Invertierung.
\end_layout

\begin_layout Subsection
Vollständiger Verzicht auf die Inverse durch Likelihood Partielle Ableitungen
 durch Approximation der Spur 
\begin_inset CommandInset label
LatexCommand label
name "subsec:SpurApprox"

\end_inset


\end_layout

\begin_layout Standard
Bei der Bestimmung der partiellen Ableitungen nach den Hyperparametern des
 Likelihood Terms ist es deutlich schwieriger auf die Invertierung zu verzichten.
 Dies liegt an der Bestimmung der Ableitung der Determinante nach den Hyperparam
etern.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\frac{\partial L\left(\vec{h}\right)}{\partial h_{l}}= & -\frac{\partial}{\partial h_{l}}\left(\log\left(\det(\mathbf{\mathbf{Cov}})\right)\right)-\frac{\partial}{\partial h_{l}}\left(\left(\vec{y}_{s}-\beta\overrightarrow{F}\right)^{T}\mathbf{\mathbf{Cov}}^{-1}\left(\vec{y}_{s}-\beta\overrightarrow{F}\right)\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\frac{\partial L\left(\vec{h}\right)}{\partial h_{l}}= & -\frac{1}{\det(\mathbf{\mathbf{Cov}})}\frac{\partial}{\partial h_{l}}\left(\det(\mathbf{\mathbf{Cov}})\right)+\left(\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{\mathbf{Cov}}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\mathbf{\mathbf{Cov}}^{-1}\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\frac{\partial L\left(\vec{h}\right)}{\partial h_{l}}= & -\textrm{Spur}\left(\mathbf{\mathbf{Cov}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\right)+\left(\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{\mathbf{Cov}}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\mathbf{\mathbf{Cov}}^{-1}\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Spur schätzen 
\begin_inset CommandInset citation
LatexCommand cite
key "Avron2011,hutchinson1989stochastic,MarkGibbs1997"

\end_inset


\begin_inset Formula 
\[
Spur\left(R\right)=E\left[\vec{d}^{T}R\vec{d}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Spur\left(R\right)\approx\frac{1}{N}\sum\vec{d}^{T}R\vec{d}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vec{d}=\left[\begin{array}{c}
N\left(0,1\right)\\
\vdots\\
N\left(0,1\right)
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
Die Approximation benötigt leider einen sehr großen Zufallsvektor 
\begin_inset Formula $\vec{d}$
\end_inset

 um eine ausreichende Genauigkeit zu erhalten.
 Dies macht die Methode letztlich wieder ineffizient.
 Zudem bleibt immer eine Restunsicherheit in den partiellen Ableitungen
 die sich sehr negativ auf das Training auswirken kann.
 
\end_layout

\begin_layout Subsection
Vollständiger Verzicht auf die Inverse durch Rückwärtsdifferentiation der
 Cholesky Zerlegung
\end_layout

\begin_layout Standard
Wie in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SpurApprox"

\end_inset

 bereits erwähnt, ist es bei der Berechnung des Likelihood Terms möglich
 auf die Invertierung der Kovarianzmatrix zu verzichten.
 Bei der Bestimmung der partiellen Ableitungen des Likelihood Terms nach
 den Hyperparametern ist dies allerdings schwieriger.
 Die Bestimmung der partiellen Ableitungen folgt dem folgenden Berechnungsschema
:
\end_layout

\begin_layout Enumerate
Über alle benötigen Hyperparameter 
\begin_inset Formula $h_{l}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Bestimmung der Ableitung der Kovarianzmatrix
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset


\end_layout

\begin_layout Enumerate
Berechnung der Ableitung der quadratischen Form: 
\begin_inset Formula $\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{\mathbf{Cov}}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\mathbf{Cov}^{-1}\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Berechnung der Ableitung der Determinante: 
\begin_inset Formula $\textrm{Spur}\left(\mathbf{\mathbf{Cov}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Punkt a bedeutet vom Aufwand die Aufstellung der symmetrischen Matrix 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset

.
 Die Komplexität des Algorithmus liegt bei 
\begin_inset Formula $\mathcal{O}\left(n^{2}\right)$
\end_inset

 und kann zudem sehr gut parallelisiert werden.
 Die Bestimmung der einzelnen Ableitungen der Kovarianzmatrix hängt stark
 von dem verwendeten Kriging Modell und der verwendeten Korrelationsfunktion
 ab.
 Beim Gradient Enhanced Kriging können diese Einzelableitungen komplexer
 werden und damit auch vom numerischen Aufwand teurer.
 Dennoch können in der Regel sehr viele Teile aus der Aufstellung der Kovarianzm
atrix wiederverwendet werden, was den Aufwand erheblich reduziert und daher
 eher unerheblich macht.
 
\end_layout

\begin_layout Standard
Punkt b ist vom Aufwand her nahezu vernachlässigbar.
 In der Regel wurde der Vektor 
\begin_inset Formula $\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{\mathbf{Cov}}}^{-1}$
\end_inset

 bereits in der Likelihood Berechnung bestimmt und es muss nur noch eine
 Vektor Matrix Multiplikation durchgeführt werden.
\end_layout

\begin_layout Standard
Punkt c ist der aufwendigste Teil, da nur für diesen Teil die Inverse bestimmt
 werden muss.
 Die Inverse wird natürlich außerhalb dieser Schleife nur einmal berechnet,
 dennoch könnte man ohne diesen Teil vollständig auf die direkte Berechnung
 der Inversen verzichten.
 Ist die Inverse bestimmt, liegt die Komplexität zur Berechnung der Spur
 bei 
\begin_inset Formula $\mathcal{O}\left(n^{2}\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
Der Hauptaufwand liegt also in der Berechnung der Inversen.
 Der genaue Ablauf zur Bestimmung der Inversen folgt dem Schema aus Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Cholesky-Zerlegung"

\end_inset

.
 Grundlegend besteht dieses Schema aus zwei Schritten:
\end_layout

\begin_layout Enumerate
Cholesky Zerlegung der Kovarianzmatrix
\end_layout

\begin_layout Enumerate
Vorwärts- und Rückwärtssubstitution zur Bestimmung der Inversen
\end_layout

\begin_layout Standard
Der Aufwand beider Schritte liegt bei 
\end_layout

\begin_layout Enumerate
Ungefähr 
\begin_inset Formula $\frac{1}{6}n^{3}$
\end_inset

Multiplikationen/Additionen, 
\begin_inset Formula $\frac{1}{2}n^{2}$
\end_inset

 Divisionen, 
\begin_inset Formula $n$
\end_inset

 Wurzeloperationen 
\end_layout

\begin_layout Enumerate
Vorwärts- und Rückwärtseinsetzen insgesamt: 
\begin_inset Formula $n^{3}$
\end_inset

 Multiplikationen/Additionen
\end_layout

\begin_layout Standard
Der Hauptaufwand liegt also bei der Vorwärts- und Rückwärtssubstitution.
 Wobei sich diese für den Fall einer Invertierung hervorragend parallelisieren
 lässt.
 Da man das Vorwärts- und Rückwärtseinsetzen bei der Invertierung über 
\begin_inset Formula $n$
\end_inset

 Vektoren macht, kann man die Berechnung über die Vektoren parallelisieren.
 SIMD Routinen sind hier besonders effizient, da für jeden Vektor immer
 dieselbe Routine durchlaufen wird und nur die Daten sich ändern.
 Eine GPU, SSE oder AVX Beschleunigung ist hier also besonders anzustreben.
 Denkbar ist aber auch eine Parallelisierung auf Prozessebene, diese ließe
 sich nach demselben Schema aufteilen und die Teile dann natürlich auch
 über SIMD Befehle beschleunigen.
 Im Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Verteiltes-Rechnen"

\end_inset

 wird eine mögliche Umsetzung der prozessweiten Parallelisierung aufgezeigt.
 
\end_layout

\begin_layout Standard
Ein kompletter Verzicht auf die Vorwärts Rückwärtssubstitution wäre dennoch
 erstrebenswert, da diese den größten Teil des Aufwands ausmacht.
 In Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SpurApprox"

\end_inset

 wurde aufgezeigt, dass nur die Ableitung der Determinante der Kovarianzmatrix
 die Rückwärts- und Vorwärtssubstitution benötigt.
 Es gilt also eine andere Möglichkeit der analytischen Berechnung für diese
 Ableitung zu finden, die eine kürzere Laufzeit verspricht.
\end_layout

\begin_layout Standard
Einen interessanten Ansatz hierzu kann man in 
\begin_inset CommandInset citation
LatexCommand cite
key "toal2009adjoint"

\end_inset

 finden.
 Dieser bedient sich der algorithmischen Differentiation im Rückwärtsmodus,
 der interessierte Leser sei auf 
\begin_inset CommandInset citation
LatexCommand cite
key "Mader2008,Griewank2008"

\end_inset

 verwiesen, welche einen sehr guten Überblick über die algorithmische Differenti
ation bieten.
 Die grundlegende Idee in diesen Ansätzen ist es den gesamte Likelihood
 Term rückwärts zu differenzieren.
 Dieser Ansatz bietet die Möglichkeit auf die Vor- und Rückwärtssubstitution
 zu verzichten, allerdings werden rückwärtsdifferenzierte Algorithmen des
 Cholesky Algorithmus und auch der Vor- und Rückwärtssubstitution benötigt.
 Für diese Algorithmen gibt es keine performante Implementation über Bibliotheke
n.
 
\end_layout

\begin_layout Standard
Aus diesem Grund in 
\begin_inset CommandInset citation
LatexCommand cite
key "Toal2011"

\end_inset

 ein Algorithmus vorgeschlagen, welcher die Invertierung zwar benötigt,
 aber keine rückwärtsdifferenzierten Algorithmen.
 Ein Geschwindigkeitsvorteil wird hierbei bei der Aufstellung der partiellen
 Ableitungen der Kovarianzmatrix 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset

 erreicht.
 Diese muss bei dem verwendeten Algorithmus nicht mehr erzeugt werden.
\end_layout

\begin_layout Standard
Eine andere Möglichkeit bietet die alleinige Rückwärtsdifferentiation der
 Determinante der Kovarianzmatrix.
 Dieser Ansatz bietet in manchen Fällen Vorteile, wie sich im Weiteren herausste
llen wird.
 Es wird allerdings eine rückwärtsdifferenzierte Version des Cholesky Algorithmu
s benötigt.
 Es werden mehrere effiziente Implementierungen aufgezeigt.
 Der grundlegende Ansatz ist die Bestimmung der formellen Ableitung der
 gesuchten Ableitung:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & \frac{\partial\left(ln\left(det\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)}{\partial h_{l}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Wobei die Determinante das Produkt über alle quadrierten Diagonalelemente
 der Cholesky zerlegten Dreiecksmatrix 
\begin_inset Formula $LL^{T}$
\end_inset

 ist:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
ln\left(det\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right) & =ln\left(\prod_{i}L_{i,i}^{2}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Wobei folgende Form in der Regel bevorzugt wird, da diese numerisch stabiler
 ist:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & =2\sum ln\left(L_{i,i}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Daraus ergibt sich die folgende Verkettung, welche die Cholesky Zerlegung
 berücksichtigt 
\begin_inset Formula $f_{chol}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & \frac{\partial\left(ln\left(det\left(f_{chol}\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)\right)}{\partial h_{l}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Die bestehenden Abbildungen sehen wie folgt aus;
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathbf{\mathbf{\mathbf{Cov}}}:\mathbb{R}\longmapsto\mathbb{R}^{n^{2}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
f_{chol}:\mathbb{R}^{n^{2}}\longmapsto\mathbb{R}^{n^{2}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
det:\mathbb{R}^{n^{2}}\longmapsto\mathbb{R}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
ln:\mathbb{R}\longmapsto\mathbb{R}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Der Logarithmus der Determinante wird als 
\begin_inset Formula $f_{lndet}$
\end_inset

 zusammengefasst
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & \frac{\partial\left(f_{lndet}\left(f_{chol}\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)}{\partial h_{l}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
f_{lndet}:\mathbb{R}^{n^{2}}\longmapsto\mathbb{R}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
es gilt also
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
f_{lndet}\circ f_{chol}\circ\mathbf{\mathbf{\mathbf{Cov}}} & :\mathbb{R}\longmapsto\mathbb{R}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
daraus resultieren die Jacobi Matrizen 
\begin_inset Formula $D_{cov}$
\end_inset

 der Größe 
\begin_inset Formula $n^{2}\times1$
\end_inset

, 
\begin_inset Formula $D_{chol}$
\end_inset

 der Größe 
\begin_inset Formula $n^{2}\times n^{2}$
\end_inset

 und 
\begin_inset Formula $D_{flndet}$
\end_inset

 der Größe 
\begin_inset Formula $1\times n^{2}$
\end_inset

 wobei 
\begin_inset Formula $\mathbf{\mathbf{C_{i,j}}}$
\end_inset

 einen Eintrag der Matrix 
\begin_inset Formula $\mathbf{\mathbf{\mathbf{Cov}}}$
\end_inset

 bedeutet.
\end_layout

\begin_layout Standard
Damit wird die gesamte Ableitung zu:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\frac{\partial\left(f_{lndet}\left(f_{chol}\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)}{\partial h_{l}} & =D_{flndet}D_{chol}D_{cov}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\frac{\partial\left(f_{lndet}\left(f_{chol}\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)}{\partial h_{l}} & =\sum_{i}\sum_{_{j<=i}}\sum_{k}\sum_{_{m<=k}}\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{i,j}}}}}\frac{\partial\mathbf{\mathbf{\mathbf{L_{i,j}}}}}{\partial\mathbf{\mathbf{\mathbf{C_{k,m}}}}}\frac{\partial\mathbf{\mathbf{C_{k,m}}}}{\partial h_{l}}\label{eq:KettenregelCholesky}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Es gilt nun sich zu überlegen, wie man die hier gezeigte mehrdimensionale
 Kettenregel möglichst effizient bestimmen kann.
 Berechnet man die vollständige Summe, dann wäre die Komplexität für die
 Berechnung der Ableitung bei 
\begin_inset Formula $\mathcal{O}\left(n^{4}\right)$
\end_inset

.
 Der Aufwand wäre also deutlich größer als über die Bestimmung der Inversen.
 Benötigt wird also ein Algorithmus, welcher die notwendigen Terme der mehrdimen
sionalen Kettenregel ohne große Matrizen berechnen kann.
 Als erste Vereinfachung kann man sich versuchen die einzelnen Jacobi Vektoren
 zu bestimmen.
 Der Vektor 
\begin_inset Formula $D_{cov}$
\end_inset

 entspricht einfach nur allen Einträgen der Matrix 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset

 und ist im Kriging daher bekannt.
 Als nächstes kann man den Vektor 
\begin_inset Formula $D_{flndet}$
\end_inset

 bestimmen, da man die Funktion 
\begin_inset Formula $f_{lndet}$
\end_inset

 kennt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
D_{flndet}^{T} & =\left(\begin{array}{c}
\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{1,1}}}}}\\
\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{2,1}}}}}\\
\vdots\\
\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{n-1,n}}}}}\\
\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{n,n}}}}}
\end{array}\right)=\left(\begin{array}{c}
\frac{\partial2\sum ln\left(L_{i,i}\right)}{\partial\mathbf{\mathbf{\mathbf{L_{1,1}}}}}\\
\frac{\partial2\sum ln\left(L_{i,i}\right)}{\partial\mathbf{\mathbf{\mathbf{L_{2,1}}}}}\\
\vdots\\
\frac{\partial2\sum ln\left(L_{i,i}\right)}{\partial\mathbf{\mathbf{\mathbf{L_{n-1,n}}}}}\\
\frac{\partial2\sum ln\left(L_{i,i}\right)}{\partial\mathbf{\mathbf{\mathbf{L_{n,n}}}}}
\end{array}\right)=\left(\begin{array}{c}
\frac{2}{L_{1,1}}\\
0\\
\vdots\\
0\\
\frac{2}{L_{n,n}}
\end{array}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Die Bestimmung dieses Vektors kann auch als Diagonalmatrix interpretiert
 werden welche sehr schnell aus der Cholesky zerlegten Matrix bestimmt werden
 kann.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\bar{D}_{flndet}= & \left[\begin{array}{ccc}
\frac{2}{L_{1,1}} & \cdots & 0\\
\vdots & \ddots & \vdots\\
0 & \cdots & \frac{2}{L_{n,n}}
\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Auffällig ist hierbei, das der Großteil des Jacobi Vektors aus 0 Einträgen
 besteht, mit dieser Information lässt sich Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KettenregelCholesky"

\end_inset

 stark vereinfachen, da nur noch die Einträge 
\begin_inset Formula $\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{i,j}}}}}\neq0\left|i=j\right.$
\end_inset

 sind:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\frac{\partial\left(f_{lndet}\left(f_{chol}\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)}{\partial h_{l}} & =\sum_{i}\sum_{k}\sum_{_{m<=k}}\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}\frac{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}{\partial\mathbf{\mathbf{\mathbf{C_{k,m}}}}}\frac{\partial\mathbf{\mathbf{C_{k,m}}}}{\partial h_{l}}\label{eq:KettenregelCholeskyReduced}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Die Komplexität liegt somit nur noch bei 
\begin_inset Formula $\mathcal{O}\left(n^{3}\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
Als nächsten Schritt muss man sich nun überlegen, wie man den mittleren
 Teil der Kettenregel (
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}{\partial\mathbf{\mathbf{\mathbf{C_{k,m}}}}}$
\end_inset

) bestimmen kann.
 Hierfür gibt es prinzipiell zwei Möglichkeiten:
\end_layout

\begin_layout Enumerate
Man geht von den Werten 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{C_{k,m}}}}{\partial h_{l}}$
\end_inset

 aus und bestimmt ausgehend von diesen die Einträge von 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}{\partial h_{l}}$
\end_inset

 über eine vorwärts differenzierte Cholesky Zerlegung
\end_layout

\begin_layout Enumerate
Man geht von den Werten 
\begin_inset Formula $\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}$
\end_inset

 aus und bestimmt ausgehend von diesen die Einträge von 
\begin_inset Formula $\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{C_{k,m}}}}}$
\end_inset

über eine rückwärts differenzierte Cholesky Zerlegung
\end_layout

\begin_layout Standard
Grundsätzlich sollten beide Vorgehensweise vom numerischen Aufwand gleichwertig
 sein.
 Da man allerdings für jeden der 
\begin_inset Formula $o$
\end_inset

-Hyperparameter 
\begin_inset Formula $h_{l}$
\end_inset

 die Matrix 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{C_{k,m}}}}{\partial h_{l}}$
\end_inset

 bestimmen muss und damit wiederum 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}{\partial\mathbf{\mathbf{\mathbf{C_{k,m}}}}}$
\end_inset

, muss man also die vorwärts differenzierte Cholesky Zerlegung 
\begin_inset Formula $o$
\end_inset

-mal aufrufen.
 In Fall 2 ist dies nicht so, denn die Berechnung ist unabhängig von der
 Anzahl der Hyperparameter.
 Aus diesem Grund verspricht der rückwärtsdifferenzierte Fall einen Vorteil
 bei der Bestimmung der partiellen Ableitungen der Hyperparameter.
\end_layout

\begin_layout Standard
Der numerische Aufwand für einen solchen rückwärtsdifferenzierten Cholesky
 Algorithmus liegt bei dem ungefähr doppelten Aufwand einer normalen Cholesky
 Zerlegung 
\begin_inset CommandInset citation
LatexCommand cite
key "Smith1995"

\end_inset

.
 Das ist immer noch deutlich schneller als eine Vor- und Rückwärtssubstitution.
 Der in 
\begin_inset CommandInset citation
LatexCommand cite
key "Smith1995"

\end_inset

 beschriebene Algorithmus ist allerdings nur schwer parallelisierbar und
 auch für SIMD Architekturen nur schlecht geeignet.
 Im Folgenden soll der Originalalgorithmus gezeigt werden und eine parallelisier
te und SSE beschleunigte Variante.
 In der Arbeit von 
\begin_inset CommandInset citation
LatexCommand cite
key "Murray2016"

\end_inset

 wurde noch eine modernere Variante präsentiert, welche es ermöglicht Standard
 Level 3 BLAS Routinen zu verwenden.
 Hierdurch wird es möglich auch GPUs zur Berechnung zu verwenden.
 
\end_layout

\begin_layout Paragraph
Algorithmus nach Smith 
\begin_inset CommandInset citation
LatexCommand cite
key "Smith1995"

\end_inset


\end_layout

\begin_layout Standard
sdfykljg
\end_layout

\begin_layout Paragraph
Symbolische Differenzierung
\end_layout

\begin_layout Standard
in 
\begin_inset CommandInset citation
LatexCommand cite
key "Sarkka2013"

\end_inset

 
\end_layout

\begin_layout Paragraph
Alternative Herleitung der symbolischen Differenzierung
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\frac{\partial\left(ln\left(det\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)}{\partial h_{l}}= & \textrm{Spur}\left(\mathbf{\mathbf{Cov}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\phi_{ij}^{L}\left(A\right)= & \begin{cases}
A_{ij} & i>j\\
0.5A_{ij} & i=j\\
0 & i<j
\end{cases}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\phi_{ij}^{U}\left(A\right)= & \begin{cases}
0 & i>j\\
0.5A_{ij} & i=j\\
A_{ij} & i<j
\end{cases}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\textrm{Spur}\left(\mathbf{\mathbf{Cov}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\right) & =\textrm{Spur}\left(\left(\phi^{U}\left(\mathbf{\mathbf{Cov}}^{-1}\right)+\phi^{L}\left(\mathbf{\mathbf{Cov}}^{-1}\right)\right)\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & =\textrm{Spur}\left(\phi^{U}\left(\mathbf{\mathbf{Cov}}^{-1}\right)\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}+\phi^{L}\left(\mathbf{\mathbf{Cov}}^{-1}\right)\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & =\textrm{Spur}\left(\phi^{U}\left(\mathbf{\mathbf{Cov}}^{-1}\right)\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\right)+\textrm{Spur}\left(\phi^{L}\left(\mathbf{\mathbf{Cov}}^{-1}\right)\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Da 
\begin_inset Formula $\mathbf{\mathbf{Cov}}^{-1}$
\end_inset

 und 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset

 symmetrisch sind gilt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & =2\textrm{Spur}\left(\phi^{L}\left(\mathbf{\mathbf{Cov}}^{-1}\right)\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Dies ist nun exakt dasselbe Ergebnis der symbolischen Differenzierung.
 
\end_layout

\begin_layout Section
Verwendung von GPGPU
\end_layout

\begin_layout Standard
General Purpose Computation on Graphics Processing Unit blablabla#
\end_layout

\begin_layout Subsection
Adjoint Matrix
\end_layout

\begin_layout Paragraph
Level 3 BLAS Umsetzung
\end_layout

\begin_layout Paragraph
Benchmarks
\end_layout

\begin_layout Standard
Einzelne Rückwärts Cholesky
\end_layout

\begin_layout Standard
Komplettes GTraining mit verschiedenen Matrixgrößen
\end_layout

\begin_layout Standard

\size larger
Mehrere Korrelationsfunktionen GEK und CO-Kriging sind hier sehr problematisch
\size default
 (SICHER?), da sich die Ableitung des Likelihood nach den Hyperparametern
 komplexer gestaltet und Softwaretechnisch nur noch schlecht zu lösen sind.
 
\end_layout

\begin_layout Standard
- Rverse Vorwärts und Rückwärts und Reverse Choelsky muss durchlaufen werden,
 ansonsten sehr elegant und schneller als die normale Implmentierung
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset citation
LatexCommand cite
key "Toal2011"

\end_inset

 wird dieser Ansatz nochmals verändert und mithilfe der linearen Algebra
 Ansätze von 
\begin_inset CommandInset citation
LatexCommand cite
key "Giles2008"

\end_inset

 auf eine Form gebracht, die auf die Rückwärtsdifferenzierung des Cholesky
 Algorithmus und der Vor- und Rückwärtssubstitution verzichtet.
 Allerdings wird hierfür die Inverse der Kovarianzmatrix benötigt, also
 auch die Vor- und Rückwärtssubstitution.
 Dieser Umstand wird in 
\begin_inset CommandInset citation
LatexCommand cite
key "Toal2011"

\end_inset

 als Vorteil angesehen, da masn Standardbibliotheken für lineare Algebra
 ohne Probleme weiterverwenden kann und die Bestimmung der Likelihood Ableitunge
n etwas .
 
\end_layout

\begin_layout Standard
Eine andere Möglichkeit ist die Bestimmung ....
\begin_inset Newline newline
\end_inset

-Trugschluss da Reverse Cholesky nur 2x Aufwand von Cholesky also immer
 nopch viel schneller als Vor und R+ückwärts
\end_layout

\begin_layout Standard
-Reverse Vor und Rück wird sowieso nicht benötigt, wenn nur die ableitung
 nach Determinante
\end_layout

\begin_layout Standard
- Reverse Cholesky wird nur eine effizienze Implementierung verwendet, hier
 wird eine aufgezeigt welche von 8sec auf 0.2sec bei 20 CPUs und SSE runter
 ist.
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Murray2016"

\end_inset

 wird auch eine Implementierung gezeugt, welche die Verwendung von Standardblibi
otheksunftionen ermöglicht.
 
\begin_inset Newline newline
\end_inset

– - - - - - - - - - - - - - - - – - - - - - - - - - - - - - - - – - - -
 - - - - - - - - - - - - – - - - - - - - - - - - - - - - 
\end_layout

\begin_layout Standard
– - - - - - - - - - - - - - - - – - - - - - - - - - - - - - - - – - - -
 - - - - - - - - - - - - – - - - - - - - - - - - - - - - 
\end_layout

\begin_layout Standard
– - - - - - - - - - - - - - - - – - - - - - - - - - - - - - - - – - - -
 - - - - - - - - - - - - – - - - - - - - - - - - - - - - 
\end_layout

\begin_layout Standard
In wird ein Verfahren dargestellt, welches die gesamte Likelihood Berechnung
 rückwärts differenziert.
 Für dieses Verfahren ist es allerdings notwendig die komplette Vor- und
 Rückwärtssubstitution zu durchlaufen, zudem muss dieses Verfahren für jede
 neue Korrelationsfunktion umgeschrieben werden, was es softwaretechnisch
 kompliziert macht.
 Der Aufwand der Vor- und Rückwärtssubstitution würde dadurch ebenfalls
 nicht wegfallen oder vermindert werden.
 Würde eine Beschleunigung in der Bestimmung der partiellen Ableitungen
 der Kovarianzmatrix bringen.
 Der Nachteil liegt jedoch darin, dass man eine Reverse Version der Cholesky
 Zerlegung und der Vorwärts- und Rückwärtssubstition benötigt.
 Dies würde eine Benutzung von Libraries wie CUDA oder der Intel MKL verhindern.
 Die Beschleunigung durch CUDA oder MKL wird von uns als deutlich höher
 eingeschätzt als der Zugewinn durch die adjungierte Kovarianzmatrix.
 Aus diesem Grund wird darauf verzichtet.
\end_layout

\begin_layout Standard
Grundlegend ist es nicht nötig die gesamte Likelihood Berechnung rückwärts
 zu differenzieren, denn der einzig wirklich problematische Term ist 
\begin_inset Formula $\frac{\partial}{\partial h_{l}}\left(\log\left(\det(\mathbf{\mathbf{Cov}})\right)\right)$
\end_inset

.
 Für diesen Term ist es zwingend notwendig die Inverse der Kovarianzmatrix
 zu berechnen.
 Es ist also ausreichend, nur diesen Term rückwärts zu differenzieren.
 
\end_layout

\begin_layout Standard
In wird die Cholesky Zerlegung rückwärts differenziert, mithilfe dieses
 Algorithmus ist es möglich die Ableitung der Determinante ohne vorherige
 Invertierung der Kovarianzmatrix zu erhalten.
 
\end_layout

\begin_layout Standard

\size larger
Code Optimierung vergleich, zwischen dem Originalcode und dem optimierten,
 Native & SSE !!!!!!
\end_layout

\begin_layout Standard
Der Code wird deutlich unleserlicher und schwerer zu pflegen, deswegen nur
 für feste Code Bestandteile sinnvoll
\end_layout

\begin_layout Standard
_mm_load_pd(*adress) ist aligned und daher extrem schnell (wenn ich auf
 einer geraden Anzahl bin vom Array)
\end_layout

\begin_layout Standard
_mm_loadu_pd(double,double) is unaligned und daher sehr langsam(wenn ich
 auf einer ungeraden Anzahl bin vom Array)
\end_layout

\begin_layout Standard
Benchmark: alte Version bereits mit SSE und Parallelisierung, Gleichungssysteme
 stattt Inverse benutzt, nur für RPunkt die Inverse
\end_layout

\begin_layout Standard
Nur die chodecReverse und invertierung verlgiehcen, da der Rest prinzipiell
 gleich ist
\end_layout

\begin_layout Standard
asd
\end_layout

\begin_layout Standard
Erklären wie SSE durch den Speicher geht, also Speicher in 4er Blöcken aligned
 und wenn man außerhalb davon zugreift, liest die CPU die nächsten 2 Adressen
 und die 2te ist dann woanders.
 Das führt danndazu, mdass das Betriebssystem meckert und dem Prozess nicht
 erlaubt den Bereich zu lesen-> Speicherzugriffsfehöer
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	register int i; 
\end_layout

\begin_layout Plain Layout

	int n = this->getColumnSize(); 
\end_layout

\begin_layout Plain Layout

	if(this->getColumnSize() != this->getRowSize()){ 	  cout <<"Matrix nicht
 quadratisch!
\backslash
n"; 	  return false; 	} 	if(this->getColumnSize() <=0){ 	  cout <<"Matrix
 Größe <= 0!
\backslash
n"; 	  return false; 	} 
\end_layout

\begin_layout Plain Layout

	adjointMat.setSymmetric(true);
\end_layout

\begin_layout Plain Layout

        // Set Seed Matrix #pragma omp parallel for         for(int i=0;
 i<n; i++){             adjointMat[i][i] = 2.0/(*this)[i][i];         } 
                          for(int k=n-1; k>=0; k--){             for(int
 j=k+1; j<n;j++){                 for(int i=j; i<n;i++){               
          adjointMat[i][k]  -=  adjointMat[i][j]*(*this)[j][k];        
                 adjointMat[j][k]  -=  adjointMat[i][j]*(*this)[i][k]; 
                }             }                          for(int j=k+1;
 j<n;j++){                 adjointMat[j][k] /=  (*this)[k][k];         
        adjointMat[k][k] -=  adjointMat[j][k]*(*this)[j][k];           
  }             adjointMat[k][k]=0.5*adjointMat[k][k]/(*this)[k][k];    
     }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	adjointMat.setSymmetric(true); 
\end_layout

\begin_layout Plain Layout

	return true;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Blocked Algorithmus
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 GFlops (double FMA)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Straßenpreis (8.8.2016)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
max.
 Leistung
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Watt/GFlop
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GFlops/Euro
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E7-8890v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
844.8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7600€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
165W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.111
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E5-4669v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
774.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7500€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
135W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.103
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E5-2699v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
662.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3830€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
145W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.173
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E5-2650v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
422.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1200€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
105W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.352
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E5-2650v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
368
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1200€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
105W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.307
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E5-2695-v2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
230.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2100€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
115W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.11
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
sdfgsdf
\end_layout

\begin_layout Standard
sdf
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 GFlops (double FMA)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Straßenpreis (8.8.2016)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPU RAM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
max.
 Leistung
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Watt/GFlop
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GFlops/Euro
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tesla P100 NVLink
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unbekannt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16GB (HBM)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unbekannt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tesla P100 PCIe
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4700
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unbekannt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16GB (HBM)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
250W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tesla K80
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2900
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5800€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24GB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tesla K40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1430
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4400€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12GB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.325
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quadro K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1732@901Mhz, 1152@600Mhz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5000€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12GB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.286-0.23
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GTX1080
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
277
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12GB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.347
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Intel
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="7">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 GFlops (double FMA)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Straßenpreis (8.8.2016)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPU RAM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Leistung
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Watt/GFlop
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GFlops/Euro
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tesla P100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4700
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unbekannt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16GB (HBM)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unbekannt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tesla K80
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2900
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5800€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24GB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tesla K40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1430
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4400€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12GB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.325
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quadro K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1732@901Mhz, 1152@600Mhz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5000€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12GB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.286-0.23
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GTX1080
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
277
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12GB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.347
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
K80 = 2 GPUs erwähnen 
\end_layout

\begin_layout Subsection*
Cholesky Zerlegung
\begin_inset CommandInset label
LatexCommand label
name "subsec:Cholesky-Zerlegung"

\end_inset


\end_layout

\begin_layout Standard
\noindent
Die Methode chodec() stellt eine Cholesky Zerlegung für positiv definite
 und symmetrische Matrizen bereit, für die Matrix 
\begin_inset Formula $\mathbf{R}$
\end_inset

 muss also gelten:
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\mathbf{R}=\mathbf{R}^{T}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
und 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\mathbf{\overrightarrow{v}*R*\overrightarrow{v}}>0 & \,\,für\,alle\,Vektoren\,\overrightarrow{v}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Bei der Cholesky Zerlegung wird die Matrix 
\begin_inset Formula $\mathbf{R}$
\end_inset

 in ein Produkt aus einer unteren Dreicksmatrix und deren Transponierten
 zerlegt:
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\mathbf{L}\mathbf{L}^{T} & =\mathbf{R}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Die Zerlegung kann nun verwendet werden, um durch Vor- und Rückwärtseinsetzen
 lineare Gleichungssysteme in der Form 
\begin_inset Formula $\mathbf{R}\overrightarrow{x}=b$
\end_inset

 zu lösen.
 Hierfür wird zuerst vorwärts eingesetzt:
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\mathbf{L}\overrightarrow{y} & =\overrightarrow{b}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
und dann durch Rückwärtseinsetzen kann der gesuchte Vektor 
\begin_inset Formula $\overrightarrow{x}$
\end_inset

 erhalten werden: 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\mathbf{L}^{T}\overrightarrow{x} & =\overrightarrow{y}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\Longrightarrow & \mathbf{R}\overrightarrow{x}=\mathbf{L}\mathbf{L}^{T}\overrightarrow{x}=\mathbf{L}\overrightarrow{y}=\overrightarrow{b}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
ersetzt man nun 
\begin_inset Formula $\overrightarrow{x}$
\end_inset

 durch 
\begin_inset Formula $\mathbf{R}^{-1}$
\end_inset

 und 
\begin_inset Formula $\overrightarrow{b}$
\end_inset

 durch die Einheitsmatrix 
\begin_inset Formula $\mathbf{E}$
\end_inset

, kann man mit der Zerlegung die Inverse der Matrix 
\begin_inset Formula $\mathbf{R}$
\end_inset

 berechnen.
 
\end_layout

\begin_layout Standard
\noindent
Nach diesem Schritt können die Vor- und Rückwärtssubstitutionen spaltenweise
 durchgeführt werden.
 Diese lassen sich sehr gut parallelisieren, da jede CPU einfach einen Vektor
 der Inversen berechnet.
\end_layout

\begin_layout Standard
\noindent
Ein weiterer Vorteil der Zerlegung ist, dass die Determinante der Matrix
 
\begin_inset Formula $\mathbf{R}$
\end_inset

 mit der Zerlegung einfach durch Multiplikation der Diagonalelemente der
 zerlegten Matrix gewonnen werden kann:
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
det\left(\mathbf{R}\right) & =\overset{n}{\underset{i=1}{\prod}}L_{i,i}^{2}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Der verwendete Algorithmus ist in 
\begin_inset CommandInset citation
LatexCommand citet
key "press2007numerical,gill2007numerical"

\end_inset

 nochmals detaillierter beschrieben.
\end_layout

\begin_layout Subsection*
Quadratische Form
\end_layout

\begin_layout Standard
Da bei dem Training eines Kriging Modells häufig quadratische Formen 
\begin_inset Formula $\vec{v^{T}}R\vec{v}$
\end_inset

 berechnet werden müssen, lohnt es sich diese zu beschleunigen.
 Dies wird dadurch gemacht, dass die Multiplikationen nicht nacheinander
 durchgeführt werden, sondern beide Multiplikationen in einer doppel-Schleife
 behandelt werden.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\overset{n}{\underset{i=1}{\sum}}\left(v_{i}\overset{n}{\underset{j=1}{\sum}}R_{i,j}*v_{j}\right) & =\vec{v}^{T}R\vec{v}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Der Algorithmus ist im folgenden Listing gezeigt:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize}"
inline false
status open

\begin_layout Plain Layout

#pragma omp parallel for reduction(+:ret)
\end_layout

\begin_layout Plain Layout

for(size_t row=0; row < matrix->getRowSize(); row++){
\end_layout

\begin_layout Plain Layout

	double sum=0.;
\end_layout

\begin_layout Plain Layout

	for(size_t col=0; col < matrix->getColumnSize(); col++){
\end_layout

\begin_layout Plain Layout

		sum += matrix[row][col] * vec[col];
\end_layout

\begin_layout Plain Layout

	} 			
\end_layout

\begin_layout Plain Layout

	sum *= vec[row];
\end_layout

\begin_layout Plain Layout

	result +=sum;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
In der ersten Zeile wird eine Schleifenparallelisierung über OpenMP initialisier
t, wobei das Aufsummieren von result nicht parallelisiert werden darf.
 Dies würde sonst zu unvorhersehbaren Fehlern führen, da mehrere Threads
 gleichzeitig in die Variable result schreiben möchten.
 
\end_layout

\begin_layout Section
Resourcenverteilung bei parallelen Trainings
\end_layout

\begin_layout Enumerate
Nur GPUs aufteilen, da CPUs immer identisch sind und die GPUs auch CPU Anteile
 verwenden die immer gleich sind von der Berechnung her.
\end_layout

\begin_layout Enumerate
Speicher auf den GPUs checken und schauen wieviele Krigings maximal auf
 eine GPU gehen.
 Damit wird der jeweilige Anteil limitiert.
\end_layout

\begin_layout Enumerate
Anteil berechnen
\end_layout

\begin_deeper
\begin_layout Enumerate
Abhängig von der Matrixgröße (Aufteilung über GFlops sinnvoll)
\end_layout

\begin_layout Enumerate
Abhängig von der Anzahl der gleichzeitigen Trainings
\end_layout

\end_deeper
\begin_layout Standard
2.
\end_layout

\begin_layout Standard
Der Speicherbedarf in Megabyte pro Matrix liegt bei 
\begin_inset Formula $\frac{64Bit*n^{2}}{8*1024*2014}=r$
\end_inset

.
 Während eines Trainings werden maximal 2 dieser Matrizen auf einer GPU
 allokiert.
 
\end_layout

\begin_layout Standard
Scheduler, Resourcenverteilung, verschiedene Resourcen, passt alles in den
 RAM
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainings
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anteil GTX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anteil K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 Time GTX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 Time K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
156s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
156s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
130s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
143s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
143s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
133s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
132s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
133s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
191s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
128s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
191s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
133s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
133s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
113s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
121s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
121s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
122s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
119s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
122s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
187s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
113s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
187s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
96s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
96s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
101s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
85s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
101s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
142s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
83s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
142s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
178s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
82s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
178s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
72s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
72s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
98s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
71s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
98s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
123s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
66s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
123s
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Benchmark der besten Verteilung mehrerer Trainings mit 5000 Samples auf
 2 verschiedene GPUs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
1000x1000
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainings
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anteil GTX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anteil K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 Time GTX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 Time K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.5s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.8s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.8s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.8s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5s
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Benchmark der besten Verteilung mehrerer Trainings mit 1000 Samples auf
 2 verschiedene GPUs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
500x500
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="19" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainings
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anteil GTX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anteil K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 Time GTX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 Time K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17.7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.1s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12.31s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11.3s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.8s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7.7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.9s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.1s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.1s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Benchmark der besten Verteilung mehrerer Trainings mit 1000 Samples auf
 2 verschiedene GPUs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Analysesoftware von Krigingmodellen während der Laufzeit
\end_layout

\begin_layout Standard
Khon.py beschreiben
\end_layout

\end_body
\end_document
