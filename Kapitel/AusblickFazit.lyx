#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass dlrreport
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Zusammenfassung
\end_layout

\begin_layout Standard
Ziel dieser Arbeit war es ein industriell einsetzbares und erweiterbares
 Multifidelity-Optimierungsverfahren unter Berücksichtigung der Anforderungen
 im Bereich der Turbomaschinenauslegung und der Softwaretechnik zu entwickeln
 und zu testen.
 Die Herausforderungen bei der Optimierung von Turbomaschinen sind die Existenz
 mehrerer Zielfunktionen und zahlreicher Nebenbedingungen sowie hochdimensionale
 Suchräume und sehr laufzeitintensive Prozessketten, welche nicht immer
 Ergebnisse liefern.
 Das hier vorgestellte Multifidelity-Optimierungsverfahren sorgt dafür,
 dass hochdimensionale Suchräume effizienter abgetastet werden können und
 damit die Laufzeit der Optimierungen deutlich reduziert wird.
 Hierfür werden schnellere Prozessketten niedrigerer Güte herangezogen und
 mit Hilfe der dort enthaltenen Informationen die Anzahl an teuren Prozessketten
auswertungen reduziert.
 Die Anforderungen an das Multifidelity-Optimierungsverfahren umfassen die
 folgenden Punkte (vgl.
 Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Anforderungen-und-Zielsetzung"

\end_inset

):
\end_layout

\begin_layout Itemize
Entwicklung und Implementierung eines Multifidelity-Ersatzmodells
\end_layout

\begin_layout Itemize
Integration des Verfahrens in die bestehende Optimierungssoftware AutoOpti
\end_layout

\begin_layout Itemize
Unterstützung einer HPC-Rechnerarchitektur und GPUs
\end_layout

\begin_layout Itemize
Erweiterbare und objektorientierte Softwarestruktur 
\end_layout

\begin_layout Itemize
Hohe Effizienz des Optimierungsverfahrens, insbesondere des Ersatzmodells
\end_layout

\begin_layout Itemize
Hoher Automatisierungsgrad
\end_layout

\begin_layout Standard

\size largest
\color red
Zwichensatz und auf die Verallgemeinerungsfähigkeit verweisen
\end_layout

\begin_layout Paragraph
Entwicklung eines CO-Kriging-Ersatzmodells:
\end_layout

\begin_layout Standard
Ein wesentlicher Punkt dieser Arbeit bestand in der Entwicklung eines Co-Kriging
-Ersatzmodells, denn erst auf dessen Basis ist eine Multifidelity-Strategie
 effizient umsetzbar.
 Die theoretischen Hintergründe werden in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Die-Kriging-Verfahren"

\end_inset

 hergeleitet.
 Eine Besonderheit des hier entwickelten Verfahrens ist die Möglichkeit
 die Punkte der verschiedenen Gütestufen frei im Raum verteilen zu können
 (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:VergleicheCoKrigingAndere"

\end_inset

).
 
\end_layout

\begin_layout Standard
Weiterhin ist eine der zentralen Anforderungen die Nutzung einer erweiterbaren
 und objektorientierten Softwarestruktur.
 Dafür wurde eine moderne Interface-basierte Programmierung in der Programmiersp
rache C++ gewählt.
 Diese Art der Softwarearchitektur ermöglicht die effiziente Implementierung
 unterschiedlicher Verfahren, wie z.B.
 Ordinary-, Gradient-Enhanced-, Co-Kriging und Klassifikatoren wie z.B.
 Supporting-Vector Machines innerhalb eines Programms.
 Der Vorteil liegt darin, dass viele Softwaremodule geteilt werden können
 und so Redundanzen vermieden, die Übersichtlichkeit erhöht und die Fehleranfäll
igkeit reduziert werden.
 Weiterhin profitieren folgende Module besonders von dieser Architektur:
\end_layout

\begin_layout Itemize
Durch die Implementierung eines hier entwickelten Interfaces wird ein Netzwerkau
stausch von vollständigen Objekten ermöglicht.
 
\end_layout

\begin_layout Itemize
Mehrere Minimierungsverfahren wurden generalisiert und sind allgemein nutzbar.
\end_layout

\begin_layout Itemize
Die hier entwickelte Matrix-Klasse ist generalisiert auf unterschiedlichsten
 Architekturen (GPUs, Intel(c) MKL, OpenMP) nutz- und austauschbar.
\end_layout

\begin_layout Standard
Eine detaillierte Beschreibung aller Module ist in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Softwarearchitektur-und-Laufzeit"

\end_inset

 zu finden.
 
\end_layout

\begin_layout Standard
Neben der Softwarearchitektur spielt die Effizienz der Software eine entscheiden
de Rolle.
 Innerhalb einer Optimierung müssen die Ersatzmodelle einen höheren Zeitgewinn
 bringen als die Nutzung selbst erfordert.
 Dieses Verhältnis kann gesteigert werden, indem die Ersatzmodelle möglichst
 effizient gestaltet werden.
 Um dies zu erreichen sind die entwickelten Ersatzmodelle in der Lage viele
 moderne Hardwarebeschleunigungen zu nutzen.
 Besonders erwähnt seien hier Advanced-Vector-Extensions (siehe Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Streaming-SIMD-Extensions"

\end_inset

), GPU-Beschleunigung (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Verwendung-von-GPGPU"

\end_inset

) und OpenMP-Parallelisierung auf Thread-Ebene (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Matrixoperationen"

\end_inset

).
 
\end_layout

\begin_layout Standard
Weiterhin wurden zahlreiche Maßnahmen innerhalb des Verfahrens zur Beschleunigun
g des Trainings umgesetzt.
 Hierzu zählen: 
\end_layout

\begin_layout Itemize
Unterschiedliche Initialisierungsmethoden des Trainingsverfahrens (siehe
 Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

)
\end_layout

\begin_layout Itemize
Ein in dieser Arbeit entwickeltes RPROP-Trainingsverfahren, angepasst an
 das Co-Kriging (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Minimierungsverfahren"

\end_inset

)
\end_layout

\begin_layout Itemize
Die in dieser Arbeit entwickelte Matrix-Klasse mit zahlreichen Beschleunigungsve
rfahren und der Möglichkeit verschiedene Architekturen zu nutzen (siehe
 Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Matrixoperationen"

\end_inset

) 
\end_layout

\begin_layout Itemize
Eine effiziente Umsetzung der Kovarianzfunktionen (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SoftwaretechnKorrelationsfunktionen"

\end_inset

)
\end_layout

\begin_layout Itemize
Die automatisierte Reduktion von Stützstellen (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Reduktion-von-Stützstellen"

\end_inset

) auf Basis eines Kriging-Modells
\end_layout

\begin_layout Itemize
Zahlreiche Methoden zur effizienten Berechnung des Likelihood-Terms und
 dessen Ableitungen (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Ableitung-LikelihoodRueckMode"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SpurApprox"

\end_inset

)
\end_layout

\begin_layout Standard
Neben diesen Maßnahmen wurde zusätzlich eine unabhängige Softwarebibliothek
 entwickelt, welche die asynchrone Verteilung verschiedener Operationen
 auf mehrere Rechner erlaubt (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Verteiltes-Rechnen-1"

\end_inset

).
 Mit dieser Bibliothek konnten die wesentlichen Matrix-Operationen parallelisier
t werden.
 Das System ist vollständig asynchron und ermöglicht es auch, die Aufgaben
 auf unterschiedliche Archtitekturen zu verteilen, bspw.
 Server mit GPUs und CPUs oder auch verschieden starke Server im Mischbetrieb
 zu verwenden.
 Die dafür nötige Lastverteilung übernimmt ein Scheduler.
 Zudem kann das System Ausfälle einzelner Server kompensieren und die Aufgaben
 dann zeitnah an andere Server verteilen.
 Dies ist ein erheblicher Vorteil gegenüber den meisten MPI-basierten Systemen.
 
\end_layout

\begin_layout Paragraph
Erweiterung des bisherigen Optimierungsverfahrens:
\end_layout

\begin_layout Standard
Neben der Entwicklung des Ersatzmodells war auch die Integration des Multifideli
ty-Verfahrens innerhalb der bereits bestehen Software AutoOpti eine wichtige
 Aufgabe.
 Um dies zu verwirklichen, ist eine neue Schnittstelle in AutoOpti etabliert
 worden, welche die Anbindung und Nutzung unterschiedlicher Ersatzmodelle
 innerhalb von AutoOpti ermöglicht (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Softwarearchitektur-und-Laufzeit"

\end_inset

).
 Weiterhin sind zahlreiche Anpassungen innerhalb von AutoOpti vorgenommen
 worden.
 Die Datenbankhaltung und Prozesskettensteuerung mussten auf mehrere Gütestufen
 erweitert werden.
 Zudem mussten zahlreiche Anpassungen vorgenommen werden um den C99 und
 C++ Standard koppeln zu können.
 Alle weiteren Änderungen werden in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Änderungen-des-Optimierungsproze"

\end_inset

 aufgezählt.
 
\end_layout

\begin_layout Standard
Die Entwicklung einer automatisierten Entscheidungsfunktion (siehe Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Entscheidungsfunktion"

\end_inset

) war ebenfalls ein wesentlicher Punkt dieser Arbeit.
 Diese trifft während der Laufzeit einer Optimierung die Entscheidung, welche
 Gütestufe als nächstes berechnet werden soll.
 Die Entscheidung wird dabei so getroffen, dass diese den Optimierungsverlauf
 möglichst günstig beeinflusst.
 Hierfür werden Prozesskettenlaufzeiten, Trainings- und Optimierungszeiten,
 der lokale Informationsgehalt der Gütestufen und die Gewichtung der unterschied
lichen Nebenbedingungen mit einbezogen.
 
\end_layout

\begin_layout Standard
Neben dem eigentlichen Optimierungsverfahren wurde zusätzlich eine grafische
 Analyse-Software für die hier entwickelten Krigingmodelle entwickelt.
 Diese analysiert die während einer laufenden Optimierung erzeugten Krigingmodel
le und deren Vorhersagen und stellt die Ergebnisse in übersichtlicher und
 einfacher Form dar (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Laufzeit-Analysesoftware-für-Kri"

\end_inset

).
 Der Fokus liegt dabei auf der schnellen und einfachen Erkennung von möglichen
 Problemen für einen Optimierungsanwender.
 
\end_layout

\begin_layout Paragraph*
Testen des entwickelten Verfahrens:
\end_layout

\begin_layout Standard
Das Hauptziel dieser Arbeit war es, ein in einer industriellen Umgebung
 nutzbares Multifidelity-Verfahren zu entwickeln.
 Neben der eigentlichen Software-Entwicklung ist daher das Testen und die
 direkte Anwendung von zentraler Bedeutung.
 Erst dadurch ist es möglich eine Software zu entwickeln, welche die notwendige
 Stabilität und Benutzerfreundlichkeit bietet, um in einer Industrie- und
 Forschungsumgebung Anwendung finden zu können.
 Hierfür wurde die entwickelte Software in zahlreichen komplexen Anwendungen
 in Forschung und Industrie verwendet.
 Die gewonnenen Erkenntnisse und Erfahrungen wurden für die Weiterentwicklung
 des Verfahrens genutzt.
 Eine Übersicht aller Anwendungen ist in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Übersicht-der-bisherigen"

\end_inset

 zu finden.
 
\end_layout

\begin_layout Standard
Weiterhin sind in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Analytische-Optimierungsbeispiel"

\end_inset

 einige akademische Testfälle zu finden.
 Innerhalb dieser Testfälle sind insbesondere 
\begin_inset Quotes gld
\end_inset

Grenzfälle
\begin_inset Quotes grd
\end_inset

, wie z.B.
 ein Modell niedriger Güte ohne Informationsgehalt, erfolgreich überprüft
 worden.
 
\end_layout

\begin_layout Standard
Neben den akademischen Testfällen ist in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:CRISP-Testfall"

\end_inset

 eine aeromechanische Optimierungsreihe einer modernen Fanstufe zu finden.
 Innerhalb dieser Optimierungsreihe sollte der Geschwindigkeitsvorteil des
 hier entwickelten Multifidelity-Verfahrens gegenüber einer konventionellen
 Singlefidelity-Optimierung gezeigt werden.
 Hierfür wurden die Optimierungen mehrfach wiederholt, um Zufälligkeiten
 abzubilden und auch die Robustheit des Verfahrens messen zu können.
 Als Hauptergebnis konnte die gesamte Optimierungszeit durch das neue Verfahren
 in etwa halbiert werden.
 Neben der reinen Beschleunigung konnte auch beobachtet werden, dass die
 Multifidelity-Optimierungen alle zu demselben guten Ergebniss führten,
 während die Singlefidelity-Optimierungen stärkere Schwankungen zeigten.
 
\end_layout

\begin_layout Paragraph
Aktuelle Entwicklungen:
\end_layout

\begin_layout Standard
Auch nach Fertigstellung der vorliegenden Arbeit werden die hier entwickelten
 Methoden weiter verbessert und deren Anwendungsbereich erweitert.
 Bereits zum jetzigen Zeitpunkt sind einige dieser Entwicklungen besonders
 aussichtsreich.
 Insbesondere die Nutzung des Co-Kriging-Modells außerhalb von reinen Multifidel
ity-Optimierungen ist ein neues Feld und ermöglicht vielversprechende Ansätze,
 wie z.B.
 die Wiederverwendung von älteren Optimierungen.
 Eine typische Problemstellung in der Entwicklung von Turbomaschinen sind
 bspw.
 geänderte aerodynamische Randbedingungen oder eine geänderte Parametrisierung
 während eines Auslegungszyklus.
 Dies kann unter anderem dazu führen, dass komplette Optimierungen aufgrund
 kleinerer Veränderungen neu gestartet werden müssen, ohne dass die alten
 Daten verwendet werden können.
 Mithilfe des Co-Krigings können die Daten von älteren Optimierungen als
 niedrige Güte in einer neuen Optimierung weiterverwendet werden.
 Je nach Ähnlichkeit der Optimierungen kann der Zugewinn dabei sehr hoch
 sein ohne dabei ein großes Risiko einzugehen, da die Daten bereits vorhanden
 sind.
 
\end_layout

\begin_layout Standard
Eine weitere potentielle Nutzung des Co-Kriging Modells ist die Kopplung
 von komplexen, nicht statistischen Ersatzmodellen zur Verbesserung der
 Vorhersagegenauigkeit.
 Hier sind insbesondere Deep-Learning-Verfahren gemeint.
 Dabei handelt es sich um neuronale Netzwerke mit einem komplexen Aufbau
 und einer hohen Anzahl an Zwischenschichten.
 Mithilfe dieser neuronalen Netzwerke sollen komplette 3D-Strömungslösungen
 gelernt, verallgemeinert und damit Vorhersagen getroffen werden.
 Ein großer Vorteil liegt dabei in der Unabhängigkeit der Vorhersagen von
 den freien Optimierungsparametern.
 Dies ist möglich, da die Neuronalen-Netzwerke die gesamte 3D-Geometrie
 als Input verwenden.
 Erste Arbeiten zu diesem Thema sind in 
\begin_inset CommandInset citation
LatexCommand cite
key "aulich2019"

\end_inset

 zu finden.
 Diese tiefen neuronalen Netzwerke bieten bisher noch keine Unsicherheitsvorhers
age an, sodass ein 
\begin_inset Quotes gld
\end_inset

Expected Volume Gain
\begin_inset Quotes grd
\end_inset

 Algorithmus (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:EVG"

\end_inset

) nicht anwendbar ist.
  Eine mögliche Lösung hierfür bietet die Nutzung eines Co-Krigings.
 Die Vorhersagen des neuronalen Netzwerks könnten als niedrige Gütestufe
 verwendet und die Kriging-Vorhersagen damit verbessern.
 Dieses Verfahren befindet sich noch in einem sehr frühen Entwicklungsstadium.
 Es finden zwar erste Machbarkeitsstudien statt, allerdings ist zu diesem
 Zeitpunkt noch keine belastbare Aussage über den Nutzen möglich.
\end_layout

\begin_layout Standard
Zukünftig wird die in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Verteiltes-Rechnen-1"

\end_inset

 beschriebene Netzwerkbibliothek weiterentwickelt.
 Hier liegt das Ziel darin, die Bibliothek so zu erweitern, dass freie Rechnerka
pazitäten für größeren Anwendungen automatisch genutzt werden können.
 Zuerst innerhalb eines internen Netzwerkes und langfristig auch auf das
 Internet ausgedehnt, in Anlehnung an das SETI@home Programm (siehe 
\begin_inset CommandInset citation
LatexCommand cite
key "korpela2001seti"

\end_inset

).
 
\end_layout

\begin_layout Standard
Neben den bisher benannten Weiterentwicklungen sollen auch Multifidelity-Anwendu
ngen in Verbindung mit Vorauslegungsverfahren getestet werden.
 Insbesondere sind hier 2D-Strömungslöser interessant, welche innerhalb
 von Sekunden globale Performance-Daten liefern können.
 Hierbei muss allerdings untersucht werden, inwiefern die Funktionale durch
 die niedrige Güte abgebildet werden können und ob das Co-Kriging in der
 Lage ist, die ggf.
 komplexe Differenzfunktion abzubilden.
\end_layout

\end_body
\end_document
