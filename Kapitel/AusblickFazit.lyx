#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass dlrreport
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Zusammenfassung und Ausblick
\end_layout

\begin_layout Standard
Ziel dieser Arbeit ist es ein industriell einsetzbares und erweiterbares
 Multifidelity-Optimierungsverfahren zu entwickeln und zu testen.
 Weiterhin sollen die speziellen Anforderungen im Bereich der Turbomaschinenentw
icklung und der Softwaretechnik berücksichtigt werden.
 Die speziellen Herausforderungen bei der Optimierung von Turbomaschinen
 sind meist mehrere Zielfunktionen und Nebenbedingungen, hochdimensionale
 Suchräume und sehr laufzeitintensive Prozessketten, welche nicht immer
 Ergebnisse liefern.
 Das hier vorgestellte Multifidelity-Optimierungsverfahren soll dafür sorgen,
 dass die hochdimensionalen Suchräume effizienter abgetastet werden und
 damit die Laufzeit der Optimierungen deutlich reduziert werden kann.
 Hierfür werden schnellere Prozessketten niedrigerer Güte herangezogen und
 mit Hilfe der dort enthaltenen Informationen die Anzahl an teuren Prozessketten
auswertungen reduziert.
 Die Anforderungen an das Multifidelity-Optimierungsverfahren umfassen die
 folgende Punkte (vgl.
 Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Anforderungen-und-Zielsetzung"

\end_inset

):
\end_layout

\begin_layout Itemize
Integration des Verfahrens in die bestehende Optimierungssoftware AutoOpti
\end_layout

\begin_layout Itemize
Unterstützung einer HPC-Rechnerarchitektur und GPUs
\end_layout

\begin_layout Itemize
Offene objektorientierte Softwarestruktur 
\end_layout

\begin_layout Itemize
Hohe Effizienz des Optimierungsverfahrens, insbesondere des Ersatzmodells
\end_layout

\begin_layout Itemize
Hoher Automatisierungsgrad
\end_layout

\begin_layout Standard
Um diese zu erfüllen, werden am Anfang der Arbeit (vgl.
 Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Anforderungen-und-Zielsetzung"

\end_inset

) mehrere Ziele definiert:
\end_layout

\begin_layout Paragraph
Entwicklung eines CO-Kriging-Ersatzmodells
\end_layout

\begin_layout Standard
Ein wesentlicher Punkt dieser Arbeit ist die Entwicklung eines Co-Kriging
 Ersatzmodells, denn erst auf Basis eines solchen Ersatzmodells ist eine
 Multifidelity-Strategie sinnvoll umsetzbar.
 Die theoretischen Hintergründe werden in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Die-Kriging-Verfahren"

\end_inset

 zusammengefasst.
 Eine Besonderheit dieses Verfahrens, ist die Möglichkeit die Punkte der
 verschiedenen Gütestufen fire verteilen zu können (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:VergleicheCoKrigingAndere"

\end_inset

).
 
\end_layout

\begin_layout Standard
Eine zentrale Anforderung ist die Nutzung einer offenen und objektorientierten
 Softwarestruktur.
 Um dies umzusetzen wird eine moderne Interface-basierte Programmierung
 gewählt, wobei die verwendete Programmiersprache C++ ist.
 Die Nutzung dieser Softwarearchitektur ermöglicht die effiziente Implementierun
g von unterschiedlichen Verfahren wie z.B.
 Ordinary-, Gradient-Enhanced-, Co-Kriging und Klassifikatoren wie z.B.
 Supporting-Vector Machines innerhalb einer Software.
 Der Vorteil dabei liegt darin, dass viele Softwaremodule geteilt werden
 können und so Redundanzen vermieden, die Übersichtlichkeit erhöht und die
 Fehleranfälligkeit reduziert werden.
 Weiterhin profitieren folgende Module besonders von dieser Architektur:
\end_layout

\begin_layout Itemize
Durch die Implementierung eines definierten Interfaces wird ein Netzwerkaustausc
h von Objekten ermöglicht.
 
\end_layout

\begin_layout Itemize
Minimierungsverfahren sind generalisiert und allgemein nutzbar
\end_layout

\begin_layout Itemize
Matrixoperationen sind generalisiert auf unterschiedlichsten Architekturen
 (GPUs, Intel(c) MKL, OpenMP) nutz- und austauschbar
\end_layout

\begin_layout Standard
Eine detaillierte Beschreibung aller Module ist in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Softwarearchitektur-und-Laufzeit"

\end_inset

 zu finden.
 
\end_layout

\begin_layout Standard
Neben der Softwarearchitektur spielt die Effizienz der Software eine entscheiden
de Rolle.
 Innerhalb einer Optimierung müssen die Ersatzmodelle einen höheren Zeitgewinn
 bringen als die Nutzung selbst kostet.
 Dieses Verhältnis kann gesteigert werden, indem die Ersatzmodelle selbst
 möglichst effizient gestaltet werden.
 Um dies zu erreichen sind die entwickelten Ersatzmodelle in der Lage, viele
 moderne Hardwarebeschleunigungen nutzen zu können.
 Besonders erwähnt seien hier Advanced Vector Extensions (siehe Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Streaming-SIMD-Extensions"

\end_inset

), GPU-Beschleunigung (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Verwendung-von-GPGPU"

\end_inset

) und OpenMP-Parallelisierung auf Thread-Ebene (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Matrixoperationen"

\end_inset

).
 
\end_layout

\begin_layout Standard
Weiterhin sind zahlreiche Maßnahmen innerhalb des Verfahrens selbst zur
 Beschleunigung des Trainings umgesetzt.
 Hierzu zählen die Initialisierungsmethoden 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

, ein weiter entwickeltes RPROP-Trainingsverfahren, welches speziell an
 das Co-Kriging angepasst ist 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Minimierungsverfahren"

\end_inset

, die in dieser Arbeit entwickelte Matrix-Klasse mit zahlreichen Beschleunigungs
verfahren und der Möglichkeit verschiedene Architekturen zu nutzen (siehe
 Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Matrixoperationen"

\end_inset

), effiziente Umsetzung der Kovarianzfunktionen 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SoftwaretechnKorrelationsfunktionen"

\end_inset

, Reduktion von Stützstellen 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Reduktion-von-Stützstellen"

\end_inset

 auf Basis eines Kriging-Modells, zahlreiche Mehtoden zur effizienten Berechnung
 des Likelihood-Terms und dessen Ableitung 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Ableitung-LikelihoodRueckMode"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SpurApprox"

\end_inset

.
 
\end_layout

\begin_layout Standard
Neben diesen Maßnahmen wurde zusätzlich eine unabhängige Softwarebibliothek
 entwickelt, welche die asynchrone Verteilung von verschiedensten Operationen
 auf mehrere Rechner erlaubt (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Verteiltes-Rechnen-1"

\end_inset

).
 Mit dieser Bibliothek konnten die wesentlichen Matrix-Operationen parallelisier
t werden.
 Das System ist vollständig asynchron und ermöglicht es auch, die Aufgaben
 auf unterschiedliche Archtitekturen zu verteilen.
 Beispielsweise Server mit GPUs und CPUs oder auch verschieden starke Server
 im Mischbetrieb zu verwenden.
 Die dafür nötige Lastverteilung übernimmt ein Scheduler.
 Zudem kann das System Ausfälle einzelner Server kompensieren und die Aufgaben
 dann zeitnah an andere Server verteilen.
 Dies ist ein erheblicher Vorteil gegenüber z.B.
 den meisten MPI-basierten Systemen.
 
\end_layout

\begin_layout Paragraph
Erweiterung des bisherigen Optimierungsverfahrens
\end_layout

\begin_layout Standard
Neben der Entwicklung des Ersatzmodells ist auch die Integration des Multifideli
ty-Verfahrens innerhalb der bereits bestehen Software AutoOpti erfolgt.
 Um dies zu verwirklichen ist eine neue Schnittstelle in AutoOpti etabliert
 worden, welche die Anbindung und Nutzung von unterschiedlichen Ersatzmodellen
 innerhalb von AutoOpti ermöglicht (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Softwarearchitektur-und-Laufzeit"

\end_inset

).
 Weiterhin sind zahlreichen Anpassungen innerhalb von AutoOpti vorgenommen
 worden.
 Diese umfassen bswp.
 die Datenbankhaltung und Prozesskettensteuerung welche auf mehrere Gütestufen
 erweitert worden sind, alle weiteren Änderungen sind in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Änderungen-des-Optimierungsproze"

\end_inset

 aufgezählt.
 
\end_layout

\begin_layout Standard
Die Entwicklung einer automatisierten Entscheidungsfunktion (siehe Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Entscheidungsfunktion"

\end_inset

) ist ebenfalls ein wesentlicher Punkt dieser Arbeit.
 Diese trifft während der Laufzeit einer Optimierung die Entscheidung, welche
 Gütestufe als nächstes berechnet werden soll.
 Die Entscheidung wird dabei möglichst optimal getroffen und bezieht Prozesskett
enlaufzeiten, Trainings- und Optimierungszeiten, den lokalen Informationsgehalt
 der Gütestufen und die Gewichtung der unterschiedlichen Nebenbedingungen
 mit ein.
 Der theoretische Hintergrund hierzu wird in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Entscheidungsfunktion"

\end_inset

 beschrieben und die softwaretechnische Umsetzung ist in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Umsetzung-der-Entscheidungsfunkt"

\end_inset

 zu finden.
\end_layout

\begin_layout Standard
Neben dem eigentlichen Optimierungsverfahren wurde zusätzlich eine grafische
 Analyse-Software für die hier entwickelten Kriging-Modelle geschrieben.
 Diese analysiert die während einer laufenden Optimierung erzeugten Kriging-Mode
lle und deren Vorhersagen und stellt die Ergebnisse in übersichtlicher und
 einfacher Form dar (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Laufzeit-Analysesoftware-für-Kri"

\end_inset

).
 Der Fokus liegt dabei auf der schnellen und einfachen Erkennung von möglichen
 Problemen.
 
\end_layout

\begin_layout Paragraph*
Testen des entwickelten Verfahrens 
\end_layout

\begin_layout Standard
Das wichtigste Ziel, ein in einer industriellen Umgebung einsetzbares Verfahren
 zu entwickeln ist gelungen.
 Dies lässt sich besonders an den sehr komplexen Anwendungen zeigen die
 das in dieser Arbeit entwickelte Verfahren gewinnbringend verwendet haben.
 Weiterhin konnten bereits einige Anwendungen in Forschung und Industrie
 vorgestellt werden, von denen viele auch im Rahmen dieser Arbeit betruet
 wurden und entscheidend zu der Entwicklung dieses Verfahren beigetragen
 haben.
 
\end_layout

\begin_layout Enumerate
Aufzählen von den Anwendungn
\end_layout

\begin_deeper
\begin_layout Enumerate
Siemens
\end_layout

\begin_layout Enumerate
asdsad
\end_layout

\end_deeper
\begin_layout Enumerate
Praktische Anwendbarkeit an industriellen Turbomaschinenoptimierung zeigen
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Industriell einsetzbares Mutlfideiltiy Verfahren für das Turbomaschinendesign,
 welches moderne Großrechner-Systeme unterstützt und verwenden kann.
\end_layout

\begin_layout Enumerate
Entscheidungsfunktion:
\end_layout

\begin_deeper
\begin_layout Enumerate
Konvergenzrate der Fidelities miteinbeziehen, diese kann ser unterschiedlich
 sein
\end_layout

\begin_layout Enumerate
Entscheidung auf einzelnen Prozesse ausweiten.
 CFD LF z.B.
 und FEM HF oder sowas.
 Dynamischer
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Enumerate
Grundlegende Zielsetzung, Entwicklu
\end_layout

\begin_layout Enumerate
ng eines an industriell einsetzbaren und erweiterbaren Multifidelity Optimierung
sverfahrens
\end_layout

\begin_deeper
\begin_layout Enumerate
Optimierungsverfahren stark ausgerichtet auf den Turbomaschinenbereich,
 bedeutet:
\end_layout

\begin_deeper
\begin_layout Enumerate
Viele Restriktionen
\end_layout

\begin_layout Enumerate
mehrere Zielfunktionen
\end_layout

\begin_layout Enumerate
hochdimensionale Räume
\end_layout

\begin_layout Enumerate
numerisch sehr rechenaufwendige Prozessketten
\end_layout

\begin_layout Enumerate
Prozessketten in verschiedenen Gütestufen
\end_layout

\begin_layout Enumerate
HPC Rechnerarchitektur mit GPUs, 
\end_layout

\end_deeper
\begin_layout Enumerate
Zukünftige Problemstellungn müssen auch bearbeitet werden können
\end_layout

\begin_deeper
\begin_layout Enumerate
GEK-CO Kriging
\end_layout

\begin_layout Enumerate
CO-Kriging fließénde Gütestufen
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Erreicht wird dies durch
\end_layout

\begin_deeper
\begin_layout Enumerate
Eigenes offenes Softwaredesign
\end_layout

\begin_deeper
\begin_layout Enumerate
Objektorientiertes Programm
\end_layout

\begin_deeper
\begin_layout Enumerate
Beinhaltet alle Kriging Verfahren (Gradient-Enhanced-, Co-, Ordinary-Kriging)
\end_layout

\begin_layout Enumerate
Erweiterbar
\end_layout

\end_deeper
\begin_layout Enumerate
Andere Kriging Verfahren müssen umgesetzt werden können
\end_layout

\begin_layout Enumerate
Danach noch Erweiterbar sein
\end_layout

\begin_layout Enumerate
Objektorientierung
\end_layout

\begin_layout Enumerate
Allgemeine Schnitstellen vom Ersatzmodell zum Optimierer
\end_layout

\begin_layout Enumerate
Unterschiedliche Programmiersprachen 
\end_layout

\end_deeper
\begin_layout Enumerate
Entwicklung und Validierung einer automatisierten Entscheidungsfunktion
\end_layout

\begin_layout Enumerate
Eigen entwickeltes CO-Kriging als Ersatzmodell
\end_layout

\begin_layout Enumerate
Erweiterung des bisherigen Optimierungsverfahren auf mehrere Fidelities,
 Entscheidungsfunktionen, Datenbasen usw.
\end_layout

\begin_layout Enumerate
Kriging Verfahren Hardwaremäßig
\end_layout

\begin_deeper
\begin_layout Enumerate
CPU-GPU Mixbetrieb muss möglich sein für das Optimierungsverfahren
\end_layout

\begin_layout Enumerate
Client / Server System, um Berechnungunge asynchron und dynamisch zu verteilen.
 Auch auf verschiedenen Architekturen (GPU/CPU)
\end_layout

\end_deeper
\end_deeper
\begin_layout Section*
Ausblick
\end_layout

\begin_layout Standard
So kurz wie möglich, ruhig was weglassen
\end_layout

\begin_layout Subsection
Netzwerkbibliothek
\end_layout

\begin_layout Standard
Erweitern wie SETI
\end_layout

\begin_layout Subsection
Wiederverwendung von älteren ähnlichen Optimierungen
\end_layout

\begin_layout Standard
Eine typische Problemstellung in der Entwicklung von Turbomaschinen, sind
 z.B.
 geänderte Randbedingungen oder geänderte Parametrisierung während der laufenden
 Entwicklung.
 Dies kann bspw.
 dazu führen, dass 
\end_layout

\begin_layout Standard
Die Option existiert bereits und wurde an einfachen Tests bereits erfolgreich
 angewandt.
 Allerdings sind noch weitere Tests nötig, um einschätzen zu können inwieweit
 eine Änderung der Randbedingungeun oder der Parametrisierung noch gewinnbringen
d sein kann.
\end_layout

\begin_layout Subsection
Vorauslegungsverfahren als Modell niedriger Güte testen
\end_layout

\begin_layout Standard
ACDC als Modell niedriger Güte.
 Extremer Zeitunterschied und möglicherweise hoher Informationsgehalt könnte
 die Optimierungen deutlich beschleunigen.
 
\end_layout

\begin_layout Subsection
Kopplung mehrerer Ersatzmodelle: Nutzung von Deep Learning Verfahren über
 CO-Kriging 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Kopplung-mehrerer-Ersatzmodelle:"

\end_inset


\end_layout

\begin_layout Standard

\color magenta
Sehr kurz, Marcel zitieren.
 DeepLeasrniong als Lowfi verwenden.
 Erste klweine Ansätze in unsere Optisuite getestet und sieht vielversprechend
 aus.
 Das wars
\end_layout

\begin_layout Standard
Im Rahmen dieser Arbeit wurde die Nutzung von Deep-Learning CFD-Vorhersagen
 in Kombination mit dem in dieser Arbeit vorgestellten Multifidelity-Verfahren
 getestet.
 Die Nutzung von Deep Learning Verfahren im Rahmen einer Turbomaschinenauslegung
 ist ein noch sehr junges Forschungsgebiet, aus diesem Grund gibt es noch
 sehr wenig an aktueller Forschungsliteratur.
 In 
\begin_inset CommandInset citation
LatexCommand cite
key "Bai2018"

\end_inset

 wurde ein erster Versuch unternommen mithilfe von Deep-Learning Verfahren
 Druckverteilungen von 2D-Profilschnitten vorherzusagen.
 Zu diesem Zweck wurden drei verschiedene Neuronale Netzwerke mit einer
 Datenbank von 60.000 Profilschnitten trainiert.
 Für zwei der Neuronalen Netzwerke wurden 
\begin_inset Quotes gld
\end_inset

Convolutional-Layer
\begin_inset Quotes grd
\end_inset

 verwendet und eins wurde voll vernetzt.
 Die 
\begin_inset Quotes gld
\end_inset

Convolutional
\begin_inset Quotes grd
\end_inset

 Netzwerke zeigten bei diesem Test eine bessere Vorhersagegenauigkeit.
 
\end_layout

\begin_layout Standard
Anf'nge im Rahmen dieser Arbeit und des wurden erste Versuche unternommen
 Vorhersagen der Hauptspannungen von Verdichterschaufeln mit Tensorflow
 basierten Neuronalen Netzen zu treffen.
 Die Ergebnisse waren vielversprechend, allerdings ist die Berechnung von
 Hauptspannungen bereits so schnell, dass sich solche Vorhersagen zeitlich
 nicht rentieren.
 
\end_layout

\begin_layout Standard
In der Arbeit von Aulich und Kueppers wurde aufbauend darauf die Vorhersage
 von CFD-Strömungslösungen getestet.
 Hierfür wurde ein 
\begin_inset Quotes gld
\end_inset

Bounding Box
\begin_inset Quotes grd
\end_inset

 Verfahren entwickelt, welches die CFD-Lösung in Form eines hochauflösenden
 Rechengitters auf ein festes Gitter von geringerer Auflösung konvertiert.
 Jeder Knotenpunkt dieses neuen Gitters entspricht einem Knoten der Input-Schich
t des zu trainierenden Neuronalen Netzwerks.
 Die Geometrie wird dann über die Aktivierung des entsprechenden Input-Knotens
 abgebildet.
 Ein Knoten welcher bspw.
 in der Geometrie liegt bekommt einen anderen Wert zugewiesen als Knoten
 außerhalb der Geometrie.
 Die entsprechende 
\end_layout

\begin_layout Standard
Diese daraus entstandenen NNs wurden dann in der hier geyeigten Optimierung
 als Low Fid Modelle getestet.
\end_layout

\begin_layout Standard
Bild von der Prozesskette mit Informationsdichte zeigen.
\end_layout

\begin_layout Standard
-> mit einem Member könnte bereist Information gelernt weden.
 Mit Kriging so nicht möglich.
\end_layout

\begin_layout Standard
-> Aber Probleme die NNs zu nutzen, daher über einen Multifidelity Ansatz
 am sinnvollsten
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../images/ErgebnissKapitel/NN_KrigingAblaufdiagramm.pdf
	BoundingBox 0bp 210bp 660bp 510bp
	clip

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Verschiedene-Prozessketten-am"

\end_inset

Verschiedene Prozessketten am Beispiel der Fanstufenoptimierung, mit jeweiliger
 Anzahl an Informationsgrößen.
 Mittig ist die Optimierungs-Prozesskette, links die Prozesskette für eine
 Vorhersage mit Neuronalen Netzwerken und rechts der Ablauf einer Kriging
 Vorhersage.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Einleitend, wo stehen wir?
\end_layout

\begin_layout Standard
Deep Learning, was verspricht man sich davon warum in der Turbomaschinenauslegun
g?
\end_layout

\begin_layout Standard
- Industrie in der Lage sehr komplexe Geometrien zu simulieren, allerdings
 die Parameteranzahl dadurch extrem hoch
\end_layout

\begin_layout Standard
- 3D Information unabhängig von der Parametrisierung
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Vor welchen Problemstellungen steht man, wenn man ein solches Deep_Learning
 Netz innerhalb einer Optimireung verwenden möchte?
\end_layout

\begin_layout Standard
- Vorhersagen sind sehr unpräzise durch die nötige Rasterung und die damit
 einhergehende schlechte Netzauflösung (Fabian zitieren)
\end_layout

\begin_layout Standard
- Das Vertrauensniveau ist recht niedrig, da man keine Fehlerinformationen
 hat, Keine statistischen Vorhersagen
\end_layout

\begin_layout Standard
- Vorhersagen selbst zu aufwendig in einer EVG Prozesskette
\end_layout

\begin_layout Standard
- Fehler (noch) sehr hoch, pysikalische Gesetze (z.B.
 Massenerhaltung, Totalgrößen, Wirkungsgrade unter 1) wird nicht eingehalten.
 Könnte man aber teilweise mittrainieren
\end_layout

\begin_layout Standard
- Das Training dauert sehr lange
\end_layout

\begin_layout Standard
- Vorhersagen dauern lange, durch Bounding Box (Optimierungspotential vorhanden)
\end_layout

\begin_layout Standard
Die Verwendung für den Einsatz in Turbomaschinenoptimierungen von solchen
 Deep-Learning Netzen ist recht schwierig.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
-> Fazit: Kopplung über MF Strategie sinnvoll, da:
\end_layout

\begin_layout Standard
- statische Vorhersagen möglich sind.
\end_layout

\begin_layout Standard
- Optimierungsprozess über EVG möglich ohne Änderungeun
\end_layout

\begin_layout Standard
- Fehler können vielleicht korrigiert werden
\end_layout

\begin_layout Paragraph*
Die zentrale FRAGE, die hier beantwortet werden soll:
\end_layout

\begin_layout Standard
Eine erste Einschätzung, ob Deep Learning Netze mit einer MF Strategie Potential
 haben.
 Es soll noch keine optimale Strategie vorgestellt werden.
 Auch die Neuronalen Netzwerke stehen noch ganz am Anfang was Struktur,
 Lossfunktion usw.
 angeht.
\end_layout

\begin_layout Paragraph*
Kurz die NNs vorstellen:
\end_layout

\begin_layout Standard
- Marcel zitieren und Fabian zitieren: Netzstruktur und Box Generierung
\end_layout

\begin_layout Standard
- Framework: Tensorflow, 
\end_layout

\begin_layout Standard
- In dieser Arbeit wurde die Box Generierung verwendet und die voreingestellte
 Netzstruktur, die Variationen und .
 Das Training wurde dann wieder innerhalb dieser Arbeit durchgeführt und
 die Prozesskette usw.
 aufgesetzt.
 Das hier entwickelte MF Verfahren kam dann zum Einsatz mit der LF NN Kette.
 
\end_layout

\begin_layout Standard
Rasterung Zeigen
\end_layout

\begin_layout Standard
S1-Schnitte Vorhersagen zeigen
\end_layout

\begin_layout Standard
1D-Größen Vergleiche zeigen, die Probleme insbesondere, z.B.
 Massnstrom der Interfaces
\end_layout

\begin_layout Standard
.
 Struktur grob erklären, Lossfunktion
\end_layout

\begin_layout Standard
- jeweils ein NN pro OP
\end_layout

\begin_layout Standard
- Trainingsverlauf zeigen
\end_layout

\begin_layout Standard
- Vorhersagen grob vergleichen
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status open

\begin_layout Plain Layout
Vorhersagen zeigen.
 50% Schnitt Vorhersage und Real, 
\end_layout

\begin_layout Plain Layout
95% Schnitt Vorhersage und Real
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
- 1D Vorhersagen zeigen
\end_layout

\begin_layout Paragraph*
Optimierungssetup zeigen
\end_layout

\begin_layout Standard
NNs vorher trainiert mit 25 initialen Samples
\end_layout

\begin_layout Standard
NNs nicht mehr nachtrainiert
\end_layout

\begin_layout Standard
Optimierungsergebnisse zeigen
\end_layout

\begin_layout Standard
Kein Tensorflow auf dem Cluster, da ...
\end_layout

\begin_layout Standard
Daher wurden alle NN Vorhersagen auf einem lokalen Rechner gemacht.
 Prozesskette erklären
\end_layout

\begin_layout Paragraph*
Paretofronten - Irgendwie Zeilfunktionen zeigen und vergleichen
\end_layout

\begin_layout Standard
asdasd
\end_layout

\begin_layout Standard
z.B.
 bei 150 Member wie sehen die Paretofronten aus?
\end_layout

\begin_layout Paragraph*
Da besonders der Anfang der Optimierung wichtig ist, Reduktion der Nebenbedingun
gen zeigen
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
Reduktion der Nebenbedingung über Prozesskettenzeit
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Ergebnisse - Simulation des Beginns einer Optimierung
\end_layout

\begin_layout Standard
Unterschied zwischen RPROP & QN liegt an 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MF RPROP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MF QN
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
65TtOP0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.640 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.897
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.477
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
93mOP0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.975
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.037
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.406
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
96 piOp0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.009
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.013
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.011
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
168 mOP1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.425
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.211
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.816
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
171piOP1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.009
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.012
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.007
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
352AngleOP0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.499
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.735
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.632
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Scale On; 25HF + 488LF MeanError der Vorhersagen, 10 Trainings,Zufällige
 Initialisierung, 747 Crossval
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Weiterhin wurde während des Trainings für MF Modelle der LF-Rauschterm verwendet.
 Die Vorhersagen des Neuronalen Netzwerks werden also als verrauscht angesehen.
 Dennoch konnten fast alle Vorhersagen durch die Neuronalen-Netzwerke verbessert
 werden.
 Ein gewisses Potential scheint also vorhanden zu sein.
 
\end_layout

\begin_layout Paragraph*
Optimierung - Ergebnisse
\end_layout

\begin_layout Standard
VG Verlauf - Entscheidungsfunktion & Startdatenbasis
\end_layout

\begin_layout Standard
- Geht am Anfang sehr stark auf die Nebenbedingungen und dort ist flow_93
 sehr wichtig.
 Bei diesem bringen die NNs relativ viel, deswegen ist das Kriterium hoch.
 Gewichtung funktioniert also ganz gut.
 
\end_layout

\begin_layout Paragraph*
Fazit:
\end_layout

\begin_layout Standard
Hat es Potential gewinnbringend in einer 3D-CFD Turbomaschinenoptimierung
 eingesetzt werden zu können?
\end_layout

\begin_layout Standard
Bei jetzigem Stand konnte keine Beschleunigung erreicht werden.
 Die größten Schwierigkeiten sind:
\end_layout

\begin_layout Itemize
0D Vorhersagen sind sehr schlecht korreliert mit den CFD Simulationen
\end_layout

\begin_layout Itemize
Training dauert extrem lange, selbst auf Hochleistungshardware
\end_layout

\begin_layout Itemize
Physikalische Gesetze werden nicht eingehalten: Wirkungsgrad > 1 oder Eintrittsm
assenstrom != Austrittsmassenstrom, Totalgrößen werden nicht erhalten
\end_layout

\begin_layout Standard
Aber es ist noch sehr viel Entwicklungspotential vorhanden.
\end_layout

\begin_layout Itemize
Physikalischen Gesetze könnten durch ein geschicktes Trainingsverfahren
 gelernt werden 
\end_layout

\begin_layout Itemize
0D Größen können in das Training mit aufgenommen werden
\end_layout

\begin_layout Itemize
Trainingszeit könnte durch ein vortrainiertes Netz reduziert werden
\end_layout

\begin_layout Itemize
Struktur der NNs bietet noch zahlreiche Möglichkeiten
\end_layout

\begin_layout Standard
Unsicher, es gibt noch zahlreiche Hürden, wie z.B.
 die hohe Trainingszeit, die Erzeugung der Boxen usw., mer Efahrung mit der
 Struktur ist nötig.
 Ein gewissen Informationsgehalt auf Delta Basis scheint vorhanden zu sein
 und zumindest so groß zu sein, dass ein Co-Kriging Modell davon profitiert.
 Wenn die Vorhersagen noch etwas besser werden, was durchaus möglich ist,
 da die Entwicklung erst am Anfang steht und die Trainings- und vorhersagezeiten
 reduziert werden können, dann ja
\end_layout

\end_body
\end_document
