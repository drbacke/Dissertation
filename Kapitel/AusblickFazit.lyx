#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass dlrreport
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Zusammenfassung und Ausblick
\end_layout

\begin_layout Standard
Ziel dieser Arbeit ist es ein industriell einsetzbares und erweiterbares
 Multifidelity-Optimierungsverfahren zu entwickeln und zu testen.
 Zusätzlich müssen die speziellen Anforderungen im Bereich der Turbomaschinenent
wicklung und der Softwaretechnik berücksichtigt werden.
 Die Herausforderungen bei der Optimierung von Turbomaschinen sind die Existenz
 mehrerer Zielfunktionen und zahlreicher Nebenbedingungen sowie hochdimensionale
 Suchräume und sehr laufzeitintensive Prozessketten, welche nicht immer
 Ergebnisse liefern.
 Das hier vorgestellte Multifidelity-Optimierungsverfahren sorgt dafür,
 dass hochdimensionale Suchräume effizienter abgetastet werden und damit
 die Laufzeit der Optimierungen deutlich reduziert wird.
 Hierfür werden schnellere Prozessketten niedrigerer Güte herangezogen und
 mit Hilfe der dort enthaltenen Informationen die Anzahl an teuren Prozessketten
auswertungen reduziert.
 Die Anforderungen an das Multifidelity-Optimierungsverfahren umfasst die
 folgende Punkte (vgl.
 Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Anforderungen-und-Zielsetzung"

\end_inset

):
\end_layout

\begin_layout Itemize
Integration des Verfahrens in die bestehende Optimierungssoftware AutoOpti
\end_layout

\begin_layout Itemize
Unterstützung einer HPC-Rechnerarchitektur und GPUs
\end_layout

\begin_layout Itemize
Erweiterbare und objektorientierte Softwarestruktur 
\end_layout

\begin_layout Itemize
Hohe Effizienz des Optimierungsverfahrens, insbesondere des Ersatzmodells
\end_layout

\begin_layout Itemize
Hoher Automatisierungsgrad
\end_layout

\begin_layout Standard
Um diese zu erfüllen, wurden (vgl.
 Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Anforderungen-und-Zielsetzung"

\end_inset

) mehrere Ziele definiert:
\end_layout

\begin_layout Paragraph
Entwicklung eines CO-Kriging-Ersatzmodells
\end_layout

\begin_layout Standard
Ein wesentlicher Punkt dieser Arbeit ist die Entwicklung eines Co-Kriging
 Ersatzmodells, denn erst auf Basis eines solchen Ersatzmodells ist eine
 Multifidelity-Strategie sinnvoll umsetzbar.
 Die theoretischen Hintergründe werden in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Die-Kriging-Verfahren"

\end_inset

 zusammengefasst.
 Eine Besonderheit des hier entwickelten Verfahrens ist die Möglichkeit
 die Punkte der verschiedenen Gütestufen frei im Raum verteilen zu können
 (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:VergleicheCoKrigingAndere"

\end_inset

).
 
\end_layout

\begin_layout Standard
Weiterhin ist eine der zentralen Anforderungen die Nutzung einer erweiterbaren
 und objektorientierten Softwarestruktur.
 Um dies umzusetzen wird eine moderne Interface-basierte Programmierung
 verwendet, wobei die genutzte Programmiersprache C++ ist.
 Diese Art der Softwarearchitektur ermöglicht die effiziente Implementierung
 von unterschiedlichen Verfahren wie z.B.
 Ordinary-, Gradient-Enhanced-, Co-Kriging und Klassifikatoren wie z.B.
 Supporting-Vector Machines innerhalb eines Programms.
 Der Vorteil dabei liegt darin, dass viele Softwaremodule geteilt werden
 können und so Redundanzen vermieden, die Übersichtlichkeit erhöht und die
 Fehleranfälligkeit reduziert werden.
 Weiterhin profitieren folgende Module besonders von dieser Architektur:
\end_layout

\begin_layout Itemize
Durch die Implementierung eines hier entwickelten Interfaces wird ein Netzwerkau
stausch von vollständigen Objekten ermöglicht.
 
\end_layout

\begin_layout Itemize
Mehrere Minimierungsverfahren wurden generalisiert und sind allgemein nutzbar
\end_layout

\begin_layout Itemize
Die hier entwickelte Matrix-Klasse ist generalisiert auf unterschiedlichsten
 Architekturen (GPUs, Intel(c) MKL, OpenMP) nutz- und austauschbar
\end_layout

\begin_layout Standard
Eine detaillierte Beschreibung aller Module ist in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Softwarearchitektur-und-Laufzeit"

\end_inset

 zu finden.
 
\end_layout

\begin_layout Standard
Neben der Softwarearchitektur spielt die Effizienz der Software eine entscheiden
de Rolle.
 Innerhalb einer Optimierung müssen die Ersatzmodelle einen höheren Zeitgewinn
 bringen als die Nutzung selbst kostet.
 Dieses Verhältnis kann gesteigert werden, indem die Ersatzmodelle selbst
 möglichst effizient gestaltet werden.
 Um dies zu erreichen sind die entwickelten Ersatzmodelle in der Lage viele
 moderne Hardwarebeschleunigungen zu nutzen.
 Besonders erwähnt seien hier Advanced Vector Extensions (siehe Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Streaming-SIMD-Extensions"

\end_inset

), GPU-Beschleunigung (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Verwendung-von-GPGPU"

\end_inset

) und OpenMP-Parallelisierung auf Thread-Ebene (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Matrixoperationen"

\end_inset

).
 
\end_layout

\begin_layout Standard
Weiterhin sind zahlreiche Maßnahmen innerhalb des Verfahrens selbst zur
 Beschleunigung des Trainings umgesetzt.
 Hierzu zählen: 
\end_layout

\begin_layout Itemize
Die zahlreichen Initialisierungsmethoden des Trainingsverfahrens 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset


\end_layout

\begin_layout Itemize
Ein in dieser Arbeit entwickeltes RPROP-Trainingsverfahren, angepasst an
 das Co-Kriging (
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Minimierungsverfahren"

\end_inset

)
\end_layout

\begin_layout Itemize
Die in dieser Arbeit entwickelte Matrix-Klasse mit zahlreichen Beschleunigungsve
rfahren und der Möglichkeit verschiedene Architekturen zu nutzen (siehe
 Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Matrixoperationen"

\end_inset

) 
\end_layout

\begin_layout Itemize
Eine effiziente Umsetzung der Kovarianzfunktionen 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SoftwaretechnKorrelationsfunktionen"

\end_inset


\end_layout

\begin_layout Itemize
Die automatisierte Reduktion von Stützstellen 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Reduktion-von-Stützstellen"

\end_inset

 auf Basis eines Kriging-Modells
\end_layout

\begin_layout Itemize
Zahlreiche Methoden zur effizienten Berechnung des Likelihood-Terms und
 dessen Ableitungen (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Ableitung-LikelihoodRueckMode"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SpurApprox"

\end_inset

)
\end_layout

\begin_layout Standard
Neben diesen Maßnahmen wurde zusätzlich eine unabhängige Softwarebibliothek
 entwickelt, welche die asynchrone Verteilung von verschiedensten Operationen
 auf mehrere Rechner erlaubt (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Verteiltes-Rechnen-1"

\end_inset

).
 Mit dieser Bibliothek konnten die wesentlichen Matrix-Operationen parallelisier
t werden.
 Das System ist vollständig asynchron und ermöglicht es auch, die Aufgaben
 auf unterschiedliche Archtitekturen zu verteilen.
 Beispielsweise Server mit GPUs und CPUs oder auch verschieden starke Server
 im Mischbetrieb zu verwenden.
 Die dafür nötige Lastverteilung übernimmt ein Scheduler.
 Zudem kann das System Ausfälle einzelner Server kompensieren und die Aufgaben
 dann zeitnah an andere Server verteilen.
 Dies ist ein erheblicher Vorteil gegenüber z.B.
 den meisten MPI-basierten Systemen.
 
\end_layout

\begin_layout Paragraph
Erweiterung des bisherigen Optimierungsverfahrens
\end_layout

\begin_layout Standard
Neben der Entwicklung des Ersatzmodells war auch die Integration des Multifideli
ty-Verfahrens innerhalb der bereits bestehen Software AutoOpti eine wichtige
 Aufgabe.
 Um dies zu verwirklichen ist eine neue Schnittstelle in AutoOpti etabliert
 worden, welche die Anbindung und Nutzung von unterschiedlichen Ersatzmodellen
 innerhalb von AutoOpti ermöglicht (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Softwarearchitektur-und-Laufzeit"

\end_inset

).
 Weiterhin sind zahlreichen Anpassungen innerhalb von AutoOpti vorgenommen
 worden.
 Diese umfassen bswp.
 die Datenbankhaltung und Prozesskettensteuerung welche auf mehrere Gütestufen
 erweitert worden sind und die Kopplung von C99 und C++ Standard.
 Alle weiteren Änderungen werden in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Änderungen-des-Optimierungsproze"

\end_inset

 aufgezählt.
 
\end_layout

\begin_layout Standard
Die Entwicklung einer automatisierten Entscheidungsfunktion (siehe Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Entscheidungsfunktion"

\end_inset

) ist ebenfalls ein wesentlicher Punkt dieser Arbeit.
 Diese trifft während der Laufzeit einer Optimierung die Entscheidung, welche
 Gütestufe als nächstes berechnet werden soll.
 Die Entscheidung wird dabei so getroffen, dass diese den Optimierungsverlauf
 möglichst günstig beeinflusst.
 Hierfür werden Prozesskettenlaufzeiten, Trainings- und Optimierungszeiten,
 der lokale Informationsgehalt der Gütestufen und die Gewichtung der unterschied
lichen Nebenbedingungen mit einbezogen.
 Der theoretische Hintergrund hierzu wird in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Entscheidungsfunktion"

\end_inset

 beschrieben und die softwaretechnische Umsetzung ist in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Umsetzung-der-Entscheidungsfunkt"

\end_inset

 zu finden.
\end_layout

\begin_layout Standard
Neben dem eigentlichen Optimierungsverfahren wurde zusätzlich eine grafische
 Analyse-Software für die hier entwickelten Kriging-Modelle geschrieben.
 Diese analysiert die während einer laufenden Optimierung erzeugten Kriging-Mode
lle und deren Vorhersagen und stellt die Ergebnisse in übersichtlicher und
 einfacher Form dar (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Laufzeit-Analysesoftware-für-Kri"

\end_inset

).
 Der Fokus liegt dabei auf der schnellen und einfachen Erkennung von möglichen
 Problemen für einen Optimierungsanwender.
 
\end_layout

\begin_layout Paragraph*
Testen des entwickelten Verfahrens 
\end_layout

\begin_layout Standard
Das hauptsächliche Ziel dieser Arbeit ist es ein in einer industriellen
 Umgebung nutzbares Multifidelity-Verfahren zu entwickeln.
 Neben der eigentlichen Entwicklung der Software, ist das Testen und die
 direkte Anwendung einer der wichtigsten Punkte dieser Arbeit.
 Erst dadurch ist es möglich eine Software zu entwickeln, welche die notwendige
 Stabilität und Benutzerfreundlichkeit bietet, um in einer Industrie- und
 Forschungsumgebung Anwendung finden zu können.
 Hierfür wurde die entwickelte Software in zahlreichen komplexen Anwendungen
 in Forschung und Industrie verwendet und betreut.
 Die gewonnenen Erkenntnisse und Erfahrungen wurden für die Weiterentwicklung
 des Verfahrens benutzt.
 Eine Übersicht aller Anwendungen ist in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Übersicht-der-bisherigen"

\end_inset

 zu finden.
 
\end_layout

\begin_layout Standard
Weiterhin sind in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Analytische-Optimierungsbeispiel"

\end_inset

 einige akademische Testfälle zu finden.
 Innerhalb dieser Testfälle sind besonders 
\begin_inset Quotes gld
\end_inset

Grenzfälle
\begin_inset Quotes grd
\end_inset

, wie z.B.
 ein Modell niedriger Güte ohne Informationsgehalt, erfolgreich überprüft
 worden.
 
\end_layout

\begin_layout Standard
Neben den akademischen Testfällen ist in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:CRISP-Testfall"

\end_inset

 eine aeromechanische Optimierungsreihe einer modernen Fanstufe zu finden.
 Innerhalb dieser Optimierungsreihe sollte der Geschwindigkeitsvorteil des
 hier entwickelten Multifidelity-Verfahrens gegenüber einer konventionellen
 Single-Fidelity Optimierung gezeigt werden.
 Hierfür wurden die Optimierungen mehrfach wiederholt um Zufälligkeiten
 abzubilden und auch die Robustheit des Verfahrens messen zu können.
 Als Hauptergebnis konnte die gesamte Optimierungszeit durch das neue Verfahren
 in etwa halbiert werden.
 Neben der reinen Beschleunigung kann auch beobachtet werden, dass die Multifide
lity-Optimierungen alle zu demselben guten Ergebniss führen.
 Die Single-Fidelity Optimierungen zeigten stärkere Schwankungen bei den
 Ergebnissen.
 Die Multifidelity-Optimierungen haben in dieser Anwendung also robuster
 zu dem bestmöglichen Ergebnis geführt.
 
\end_layout

\begin_layout Paragraph
Aktuelle Entwicklungen
\end_layout

\begin_layout Standard
Die Software sowie das Verfahren werden nach dieser Arbeit weiterentwickelt.
 Bereits zum jetzigen Zeitpunkt sind einige dieser Entwicklungen besonders
 interessant und aussichtsreich.
 Besonders die Nutzung des Co-Kriging Modells außerhalb von reinen Multifidelity
-Optimierungen ist ein neues Feld und ermöglicht einige interessante Ansätze.
 Beispielsweise die Wiederverwendung von älteren Optimierungen.
 Eine typische Problemstellung in der Entwicklung von Turbomaschinen, sind
 z.B.
 geänderte Randbedingungen oder geänderte Parametrisierung während der laufenden
 Entwicklung.
 Dies kann z.B.
 dazu führen, dass komplette Optimierungen aufgrund kleinerer Veränderungen
 neu gestartet werden müssen, ohne dass die alten Daten verwendet werden
 können.
 Mithilfe des Co-Krigings können die Daten von älteren Optimierungen als
 niedrige Güte in einer neuen Optimierung weiterverwendet werden.
 Je nach Ähnlichkeit der Optimierungen, kann der Zugewinn dabei sehr hoch
 sein ohne dabei ein großes Risiko einzugehen, da die Daten bereits vorhanden
 sind.
 Eine solche Option existiert zum momentanen Zeitpunkt bereits innerhalb
 von AutoOpti, befindet sich allerdings noch in der Testphase.
 Die bisherigen Ergebnisse sind aber sehr aussichtsreich und werden demnächst
 veröffentlicht.
 
\end_layout

\begin_layout Standard
Eine weitere interessante Nutzung des Co-Kriging Modells ist, die Kopplung
 von komplexen nicht statistischen Ersatzmodellen zur Verbesserung der Vorhersag
egenauigkeit.
 Hier sind insbesondere Deep-Learning Verfahren gemeint.
 Dabei handelt es sich um Neuronale Netzwerke mit einem komplexen Aufbau
 und einer sehr hohen Anzahl an Zwischenschichten.
 Mithilfe dieser Neuronalen Netzwerke sollen komplette 3D-Strömungslösungen
 gelernt, verallgemeinert und damit Vorhersagen getroffen werden.
 Ein großer Vorteil liegt dabei in der Unabhängigkeit der Vorhersagen von
 den Parametern.
 Dies ist möglich, da die Neuronalen-Netzwerke als Input die gesamte 3D-Geometri
e verwenden.
 Erste Arbeiten solcher Vorhersagen sind in 
\begin_inset CommandInset citation
LatexCommand cite
key "aulich2019"

\end_inset

 zu finden.
 Innerhalb einer Optimierung ist die Anwendung solcher Neuronalen Netzwerke
 bisher nur schwer möglich, da eine Optimierung auf einem solchen Neuronalen
 Netzwerk zum jetzigen Zeitpunkt noch zu aufwendig ist.
 Zudem bieten solche Neuronalen Netzwerke bisher noch keine Unsicherheitsvorhers
age an, sodass ein 
\begin_inset Quotes gld
\end_inset

Expected Volume Gain
\begin_inset Quotes grd
\end_inset

 Algorithmus (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:EVG"

\end_inset

) nicht anwendbar ist.
 Eine mögliche Lösung hierfür bietet die Nutzung eines Co-Krigings.
 Die Vorhersagen des Neuronalen Netzwerks könnten so als niedrige Gütestufe
 verwendet und die Kriging-Vorhersagen so verbessert werden.
 Man verspricht sich durch die 
\begin_inset Quotes gld
\end_inset

günstigen
\begin_inset Quotes grd
\end_inset

 Vorhersagen des Neuronalen Netzwerks den Suchraum bereits effektiv abtasten
 zu können und optimalen Regionen so früh zu lokalisieren.
 Hiermit kann die Anzahl an freien Parametern deutlich erhöht werden.
 Dieses Verfahren befindet sich allerdings noch in einem sehr frühen Entwicklung
sstadium.
 Es finden zwar bereits erste Machbarkeitsstudien statt, allerdings ist
 zu diesem Zeitpunkt noch keine belastbare Aussage über den Nutzen möglich.
\end_layout

\begin_layout Standard
Die in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Verteiltes-Rechnen-1"

\end_inset

 beschriebene Netzwerkbibliothek weiterentwickelt.
 Hier liegt das Ziel darin, die Bibliothek so zu erweitern, dass freie Rechnerka
pazitäten für größeren Anwendungen automatisch genutzt werden können.
 Zuerst innerhalb eines internen Netzwerkes und auf lange Sicht möglicherweise
 auch auf das Internet ausgedehnt, in Anlehnung an das SETI@home Programm
 (siehe 
\begin_inset CommandInset citation
LatexCommand cite
key "korpela2001seti"

\end_inset

).
 
\end_layout

\begin_layout Standard
Neben den bisher benannten Weiterentwicklungen sollen auch Multifidelity-Anwendu
ngen in Verbindung mit Vorauslegungsverfahren getestet werden.
 Insbesondere sind hier 2D-Strömungslöser interessant, welche innerhalb
 von Sekunden globale Performance Daten liefern können.
 Hierbei muss allerdings untersucht werden, inwiefern die Funktionale durch
 die niedrige Güte abgebildet werden können und ob das Co-Kriging die Differenzf
unktion abbilden kann.
 
\end_layout

\end_body
\end_document
