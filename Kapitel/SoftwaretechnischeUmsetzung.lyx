#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass dlrreport
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Implementierung der DLR-Kriging-Verfahren 
\end_layout

\begin_layout Standard
In diesem Kapitel soll die Softwaretechnische Umsetzung des Algorithmus
 zur Bildung der Korrelationsmatrix dargestellt werden.
 Da in den Algorithmen sehr viele Matrix Operationen verwendet werden, wurde
 eine Matrix Klasse eingeführt.
 Diese wird am Anfang des Kapitels erläutert.
 
\end_layout

\begin_layout Standard
Im nächsten Abschnitt wird dann die Bildungsvorschrift der Matrix gezeigt
 und darauf folgend eine häufig genutzte Korrelationsfunktion und deren
 softwaretechnische Umsetzung erläutert.
 
\end_layout

\begin_layout Standard
Der letzter Abschnitt zeigt dann den eigentlichen Algorithmus zur Bildung
 der Korrelationsmatrix.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

- Implementierung
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	- Algorithmische Effizienz steigern
\end_layout

\begin_layout Plain Layout

		- Vorwort (warum usw.
 GEK große Matrizen und COkriging viele partielle Ableitungen)
\end_layout

\begin_layout Plain Layout

		- Wiederverwenden von Korrelationswerten
\end_layout

\begin_layout Plain Layout

		- SSE Beschleunigung Korrelationsfunktionen
\end_layout

\begin_layout Plain Layout

		- Minimierungsverfahren beleuchten QuasiNewton / RPROP / RPROP2
\end_layout

\begin_layout Plain Layout

		- Verschiedenen Initialisierungen / Ultra Restart
\end_layout

\begin_layout Plain Layout

		- Inverse durch Gleichungssystem ersetzen
\end_layout

\begin_layout Plain Layout

		- Approximation der Spur
\end_layout

\begin_layout Plain Layout

		- Rückwärtsdifferenzierung der partiellen Ableitungen
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	- Verwendung von GPUs
\end_layout

\begin_layout Plain Layout

		- GPU Computing vorstellen (Flops/Euro unschlagbar, zukünftige Pascal
 Generation wird die stärkste seinm Power Consumption vergleichen)
\end_layout

\begin_layout Plain Layout

		- CuBlas
\end_layout

\begin_layout Plain Layout

		- Transferproblematik
\end_layout

\begin_layout Plain Layout

		- Symmetrie Copy Kernel
\end_layout

\begin_layout Plain Layout

		- K80 MultiGPU notwendig, ungeeignet für das Kriging
\end_layout

\begin_layout Plain Layout

		- CuBlasXT kann nicht sinnvoll verwendet werden, 
\end_layout

\begin_layout Plain Layout

 		- Mehrere Kriging Trainings auf verschiedenen / gleichen GPUs als Ausweg
\end_layout

\begin_layout Plain Layout

		- AdjointChodec als Beispiel
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	- SoftwareDesign ( wenn Platz)
\end_layout

\begin_layout Plain Layout

		- Programmiersprache, Umgebung, grob
\end_layout

\begin_layout Plain Layout

		- AutoOpti Interface
\end_layout

\begin_layout Plain Layout

		- Verschiedene Verfahren wie SVM usw.
\end_layout

\begin_layout Plain Layout

		- Korrelationsfunktionen 
\end_layout

\begin_layout Plain Layout

		- Training
\end_layout

\begin_layout Plain Layout

		- UMLs und Code
\end_layout

\begin_layout Plain Layout

		 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Modellierung der Kovarianz- und Korrelationsfunktion 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Kovarianzmatrix"

\end_inset


\end_layout

\begin_layout Standard
In Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Die-Kriging-Verfahren"

\end_inset

 wurden die verschiedenen Kriging-Verfahren beschrieben.
 Innerhalb dieses Kapitels wurden die Begriffe der Kovarianzmatrix und des
 Kovarianzvektors verwendet.
 Um diese aufstellen zu können, ist eine Kovarianzfunktion in der Form 
\begin_inset Formula $cov\left(Z(\vec{x}_{1}),Z(\vec{x_{2}})\right)$
\end_inset

 nötig, wobei 
\begin_inset Formula $\vec{x}_{1},\vec{x}_{2}$
\end_inset

 die Orte von bekannten Stützstellen beschreiben.
 Da in der praktischen Anwendung der reale Zufallsprozess 
\begin_inset Formula $Z(\vec{x})$
\end_inset

 nicht bekannt ist und damit auch nicht die Kovarianzfunktion, bedient man
 sich parametrisierten Kovarianzmodellen in der Form 
\begin_inset Formula $cov\left(\vec{x}_{1},\vec{x_{2}}\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
Diese Funktionen müssen jedem möglichen Punktepaar eine Kovarianz zuordnen.
 Weiterhin muss die daraus resultierende Matrix positiv Definit und symmetrisch
 sein, was die Wahl einer geeigneten Funktion erschwert.
 Das folgende Beispiel zeigt eine beispielhafte Kovarianzmatrix 
\begin_inset Formula $\mathbf{\mathbf{Cov\in\mathbb{R^{\mathrm{n_{all}\times n_{all}}}}}}$
\end_inset

 für vier verschiedene Samples 
\begin_inset Formula $y_{i}\left(\vec{x}\right)$
\end_inset

 der jeweiligen Gütestufe 
\begin_inset Formula $i\in\left\{ 1,...,s\right\} $
\end_inset

 :
\begin_inset Formula 
\begin{equation}
\mathbf{Cov}=\left[\begin{array}{c|cccc}
 & y_{0}\left(\vec{x}_{1}\right) & y_{0}\left(\vec{x}_{2}\right) & y_{1}\left(\vec{x}_{3}\right) & y_{1}\left(\vec{x}_{4}\right)\\
\hline y_{0}\left(\vec{x}_{1}\right) & cov\left(\vec{x}_{1},\vec{x}_{1}\right) & cov\left(\vec{x}_{1},\vec{x}_{2}\right) & cov\left(\vec{x}_{1},\vec{x}_{3}\right) & cov\left(\vec{x}_{1},\vec{x}_{4}\right)\\
y_{0}\left(\vec{x}_{2}\right) & cov\left(\vec{x}_{2},\vec{x}_{1}\right) & cov\left(\vec{x}_{2},\vec{x}_{2}\right) & cov\left(\vec{x}_{2},\vec{x}_{3}\right) & cov\left(\vec{x}_{2},\vec{x}_{4}\right)\\
y_{1}\left(\vec{x}_{3}\right) & cov\left(\vec{x}_{3},\vec{x}_{1}\right) & cov\left(\vec{x}_{3},\vec{x}_{2}\right) & cov\left(\vec{x}_{3},\vec{x}_{3}\right) & cov\left(\vec{x}_{3},\vec{x}_{4}\right)\\
y_{1}\left(\vec{x}_{4}\right) & cov\left(\vec{x}_{4},\vec{x}_{1}\right) & cov\left(\vec{x}_{4},\vec{x}_{2}\right) & cov\left(\vec{x}_{4},\vec{x}_{3}\right) & cov\left(\vec{x}_{4},\vec{x}_{4}\right)
\end{array}\right]\label{eq:KovarianzmatrixBeispiel}
\end{equation}

\end_inset

Um ein solches Modell praktisch nutzbar zu machen, müssen drei verschiedene
 Problemstellungen behandelt werden:
\end_layout

\begin_layout Enumerate
Die Kovarianzfunktion darf nicht durch die absolute Lage im Raum 
\begin_inset Formula $\left(\vec{x}_{1},\vec{x_{2}}\right)$
\end_inset

, sondern muss durch den Verbindungsvektor 
\begin_inset Formula $\vec{h}=\vec{x}_{1}-\vec{x_{2}}$
\end_inset

 beschrieben werden
\end_layout

\begin_layout Enumerate
Es wird ein parametrisiertes Modell für die Kovarianzfunktion benötigt,
 welches zu einer positiv definiten und symmetrischen Matrix führt.
\end_layout

\begin_layout Enumerate
Die darin verwendeten Parameter, im Folgenden Hyperparameter genannt, müssen
 in einem gradientenbasierten Trainingsverfahren nutzbar sein.
\end_layout

\begin_layout Standard
Diese Problemstellungen werden in den folgenden drei Abschnitten behandelt.
\end_layout

\begin_layout Subsection
Ortsabhängigkeit Kovarianzfunktion 
\begin_inset CommandInset label
LatexCommand label
name "sec:Variogramm"

\end_inset


\end_layout

\begin_layout Standard
In diesem Abschnitt wird der Begriff des Variogramms und des Kovariogramms
 erklärt (siehe 
\begin_inset CommandInset citation
LatexCommand cite
key "matheron1963principles"

\end_inset

).
 Diese stellen die Basis für die Kovarianzmodellfunktionen dar und sind
 somit zentraler Bestandteil des Kriging Verfahrens.
 Sei 
\begin_inset Formula $Z\left(\vec{x}\right)$
\end_inset

 ein räumlicher Zufallsprozess, so ist das Variogramm 
\begin_inset Formula $2\gamma\left(\vec{x}_{1},\vec{x}_{2}\right)$
\end_inset

, 
\begin_inset Formula $\vec{x}_{1},\vec{x}_{2}\in\mathbb{R^{\textrm{k}}}$
\end_inset

 definiert über:
\begin_inset Formula 
\begin{align}
2\gamma\left(\vec{x}_{1},\vec{x}_{2}\right) & \coloneqq var\left[Z\left(\vec{x}_{1}\right)-Z\left(\vec{x}_{2}\right)\right]\\
 & =E\left[\left(\left(Z\left(\vec{x}_{1}\right)-Z\left(\vec{x}_{2}\right)\right)-E\left[Z\left(\vec{x}_{1}\right)-Z\left(\vec{x}_{2}\right)\right]\right)^{2}\right]\nonumber \\
 & =E\left[\left(\left(Z\left(\vec{x}_{1}\right)-E\left[Z\left(\vec{x}_{1}\right)\right]\right)-\left(Z\left(\vec{x}_{2}\right)-E\left[Z\left(\vec{x}_{2}\right)\right]\right)\right)^{2}\right]\nonumber 
\end{align}

\end_inset

Weiterhin wird das Kovariogramm wie folgt definiert:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
cov\left(\vec{x}_{1},\vec{x}_{2}\right)\coloneqq\frac{1}{2}var\left[Z\left(\vec{x_{1}}\right)\right]+\frac{1}{2}var\left[Z\left(\vec{x_{2}}\right)\right]-\gamma\left(\vec{x}_{1},\vec{x}_{2}\right)
\end{equation}

\end_inset

Einfacher formuliert beschreibt das Variogramm und auch das Kovariogramm
 die räumliche Abhängigkeit eines Punktes zu Nachbarpunkten.
 
\begin_inset Formula $\gamma\left(\vec{x}_{1},\vec{x}_{2}\right)$
\end_inset

 wird als Semivariogramm bezeichnet.
 Trifft man die Annahme, dass das Zufallsfeld schwach stationär ist, dann
 gilt (siehe 
\begin_inset CommandInset citation
LatexCommand cite
key "Ozkaya2014"

\end_inset

): 
\begin_inset Formula 
\begin{align}
E\left[Z\left(\vec{x}\right)\right] & =\mu,\forall\vec{x}\in\mathbb{R^{\textrm{k}}}\label{eq:OrtsAbhKovStationärE}
\end{align}

\end_inset

Weiterhin gilt dann, dass die Kovarianz nur noch abhängig von dem Verschiebevekt
or 
\begin_inset Formula $\vec{h}\in\mathbb{R^{\textrm{k}}};\vec{h}=\vec{x}_{1}-\vec{x}_{2}$
\end_inset

 ist:
\begin_inset Formula 
\begin{align}
cov\left(\vec{h}\right) & \coloneqq cov\left(\vec{x},\vec{x}+\vec{h}\right)\label{eq:OrtsAbhKovStationärcov}
\end{align}

\end_inset

Unter Berücksichtigung von Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:OrtsAbhKovStationärE"

\end_inset

 und Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:OrtsAbhKovStationärcov"

\end_inset

 folgt dann für die gesuchte Kovarianzfunktion: 
\begin_inset Formula 
\begin{equation}
cov\left(\vec{h}\right)=cov\left(\vec{0}\right)-2\gamma\left(\vec{h}\right)=\sigma^{2}-2\gamma\left(\vec{h}\right)\label{eq:KovariogrammGrundformel}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Wobei 
\begin_inset Formula $cov\left(\vec{0}\right)=\sigma^{2}$
\end_inset

 der stationären Varianz des Prozesses (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:MinimierungsverfahrenTraining"

\end_inset

) entspricht.
 Der Beweis für Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KovariogrammGrundformel"

\end_inset

 ist in Anhang zu finden.
 Die Modellierung von 
\begin_inset Formula $\gamma\left(\vec{h}\right)$
\end_inset

 wird in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Kovarianz-parametrisiertes-Model"

\end_inset

 behandelt.
 
\end_layout

\begin_layout Subsection
Kovarianz parametrisiertes Modell
\begin_inset CommandInset label
LatexCommand label
name "subsec:Kovarianz-parametrisiertes-Model"

\end_inset


\end_layout

\begin_layout Standard
Wie bereits beschrieben, wird für das Kriging Verfahren ein parametrisches
 Kovarianz-Modell benötigt.
 Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KovariogrammGrundformel"

\end_inset

 stellt die Basis für ein solches Modell dar.
 Um diese Gleichung in einem realen Modell anwenden zu können, sollte man
 sich vorerst ein typisches Kovariogramm anschauen.
 In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispielhaftes-VarioKovariogramm"

\end_inset

 wird ein solches Kovariogramm gezeigt.
 Der Einfachheit halber beschränkt sich das gezeigte Kovariogramm auf eine
 räumliche Dimension 
\begin_inset Formula $\vec{x},\vec{h}\in\mathbb{R^{\textrm{k}}};k=1$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/KrigingKapitel/KoVariogramm.eps
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Beispielhaftes Kovariogramm
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispielhaftes-VarioKovariogramm"

\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset

Auf der X-Achse ist die räumliche Distanz und auf der Y-Achse die Kovarianz
 
\begin_inset Formula $cov\left(\vec{h}\right)$
\end_inset

 aufgetragen, diese nimmt mit steigender Distanz in der Regel ab.
 
\end_layout

\begin_layout Standard
Empirisch ist oftmals zu beobachten, dass das Kovariogramm bei 
\begin_inset Formula $\vec{h}=0$
\end_inset

 springt.
 Dieser Wert 
\begin_inset Formula $\lambda\in\mathbb{R}$
\end_inset

 wird als 
\begin_inset Quotes gld
\end_inset

Nugget
\begin_inset Quotes grd
\end_inset

 bezeichnet und entspricht einem ortsunabhängigen Rauschen.
 Um dies zu modellieren, wird eine eine Sprungfunktion 
\begin_inset Formula $\delta$
\end_inset

 definiert:
\begin_inset Formula 
\[
\delta\left(\vec{h}\right)=\begin{cases}
1 & falls\,\vec{h}=\vec{0}\\
0 & sonst
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Die Summe 
\begin_inset Formula $\sigma^{2}+\lambda$
\end_inset

 (auch 
\begin_inset Quotes gld
\end_inset

Sill
\begin_inset Quotes grd
\end_inset

 genannt) ist gleichzusetzen mit der Gesamtvarianz des stochastischen Prozesses
 selbst und der eingezeichnete Wert 
\begin_inset Formula $\sigma^{2}$
\end_inset

 wird als 
\begin_inset Quotes gld
\end_inset

partial Sill
\begin_inset Quotes grd
\end_inset

 bezeichnet.
 Damit lässt sich Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KovariogrammGrundformel"

\end_inset

 umformuliert zu:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
cov\left(\vec{h}\right)=\sigma^{2}+\lambda\delta\left(\vec{h}\right)-2\gamma\left(\vec{h}\right)\label{eq:KovarianzmodellAllgemein}
\end{equation}

\end_inset


\end_layout

\begin_layout Paragraph*
Überleitung Modellfunktion
\end_layout

\begin_layout Standard
Die Bestimmung der Varianz 
\begin_inset Formula $\sigma^{2}$
\end_inset

 und des Nuggets 
\begin_inset Formula $\lambda$
\end_inset

 innerhalb des Kriging Modells, werden mithilfe eines Trainingsverfahrens
 geschätzt.
 Diese werden in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:MinimierungsverfahrenTraining"

\end_inset

 beschrieben.
\end_layout

\begin_layout Standard
Für die Variogrammfunktion 
\begin_inset Formula $\gamma\left(\vec{h}\right)$
\end_inset

 muss allerdings noch ein geeignetes Modell gefunden werden.
 Eine Möglichkeit besteht in der Erzeugung eines empirischen Variogramms
 (siehe 
\begin_inset CommandInset citation
LatexCommand cite
key "Cressie1993"

\end_inset

), dieses Verfahren liefert für die Abstände bekannter Stützstellen den
 entsprechenden räumlichen Zusammenhang und ist als nicht parametrisches
 Verfahren einzuordnen.
 Diese Art von Verfahren benötigen aber eine sehr große Anzahl an Stützstellen,
 um plausible Variogramme zu liefern.
 Dafür benötigen diese keinerlei Annahmen über den Verlauf des Variogramms
 über der Distanz.
 
\end_layout

\begin_layout Standard
Typischerweise greift man aber auf parametrisierte Modellfunktionen zurück,
 welche an die vorhandenen Stützstellen bestmöglich angepasst werden.
 Für diese parametrisierten Modellfunktionen wird ein typischer Verlauf
 einer Variogrammfunktion angenommen und die Parameter so gewählt, dass
 die Funktion bestmöglich an die vorhanden Stützstellen angepasst wird.
 Dadurch kommt diese Art des Verfahrens mit weniger Stützstellen aus, als
 eine empirische Schätzung, ist dafür allerdings eingeschränkter was die
 Form der Funktion angeht.
 Diese Funktionen müssen allerdings positiv semidefinit sein (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Cressie1993,Krueger2013,Schmid2012"

\end_inset

).
 Da dieser Nachweis sehr schwierig ist, beschränkt man sich bekannte Modellfunkt
ionen für die der Nachweis bereits erbracht worden ist.
 Hier ist insbesondere ein Modell zu erwähnen 
\begin_inset CommandInset citation
LatexCommand cite
key "lophaven2002aspects,Sacks2007"

\end_inset

:
\begin_inset Formula 
\begin{align}
2\gamma\left(\vec{h}\right)= & \sigma^{2}\left(1-e^{-\frac{1}{2}\underset{l=1}{\overset{l<=k}{\sum}}\left(e^{\theta_{l}}\left|h_{l}\right|^{p}\right)}\right)\label{eq:ExpoKorrelationsfunktion}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Wobei 
\begin_inset Formula $\vec{\theta}\in\mathbb{R^{\textrm{k}}}$
\end_inset

 als Hyperparametervektor bezeichnet wird und jeder Eintrag 
\begin_inset Formula $\theta_{l}$
\end_inset

 eine Korrelationslänge für den entsprechenden Parameter 
\begin_inset Formula $l$
\end_inset

 darstellt.
 Die Wahl eines sinnvollen Hyperparametervektors ist Aufgabe des Trainingsverfah
rens (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:MinimierungsverfahrenTraining"

\end_inset

).
 Die Benutzung der Exponentialfunktion 
\begin_inset Formula $e^{\theta_{l}}$
\end_inset

 dient der Stabilität des Trainingsverfahrens und wird in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Negative-Hyperparameter-1"

\end_inset

 beschrieben.
\end_layout

\begin_layout Standard
Für den Fall 
\begin_inset Formula $p=2$
\end_inset

 spricht man auch von einer Gauss'schen Korrelationsfunktion, welche in
 der hier beschriebenen Software auch als Standard gewählt wird.
 Der Vorteil dieser Korrelationsfunktion liegt in der schnellen Berechnung
 und damit in der schnellen Erzeugung der benötigten Kovarianzmatrix.
 
\end_layout

\begin_layout Standard
Neben diesen Korrelationsfunktionen wird häufig ein parametrisierter kubischer
 Spline verwendet, der interessierte Leser sei hierfür auf 
\begin_inset CommandInset citation
LatexCommand cite
key "lophaven2002aspects"

\end_inset

 verwiesen.
 Innerhalb der hier entwickelten Kriging-Software sind diese drei Korrelationsfu
nktionen implementiert und frei wählbar.
 
\end_layout

\begin_layout Standard
Setzt man bspw.
 die Kovarianzfunktion aus Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ExpoKorrelationsfunktion"

\end_inset

 in Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KovarianzmodellAllgemein"

\end_inset

 ein, dann folgt daraus die resultierende Kovarianzfunktion:
\begin_inset Formula 
\begin{align}
cov\left(\vec{h}\right) & =\sigma^{2}+\lambda\delta\left(\vec{h}\right)-\sigma^{2}\left(1-e^{-\frac{1}{2}\underset{l=1}{\overset{l<=k}{\sum}}\left(e^{\theta_{l}}\left|h_{l}\right|^{p}\right)}\right)\label{eq:ExpoKovarianzfunktion}\\
 & =\lambda\delta\left(\vec{h}\right)+\sigma^{2}e^{-\frac{1}{2}\underset{l=1}{\overset{l<=k}{\sum}}\left(e^{\theta_{l}}\left|h_{l}\right|^{p}\right)}
\end{align}

\end_inset


\end_layout

\begin_layout Paragraph*
Beispiel Gauss Korrelationsfunktion
\end_layout

\begin_layout Standard
\noindent
In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispiel-einer-Gauss-1"

\end_inset

 ist eine beispielhafte Kovarianzfunktion mit zwei verschiedenen 
\begin_inset Formula $\theta$
\end_inset

 Werten zu sehen.
 Die Varianz und der Nugget wurden 
\begin_inset Formula $\sigma^{2}=1,\lambda=0$
\end_inset

 angenommen, dadurch sind Kovarianz und Korrelation in diesem Fall identisch.
 Auf der X-Achse des Diagramms ist die Differenz der beiden Stützstellen
 zueinander aufgetragen und die Y-Achse beschreibt den entsprechende Korrelation
swert.
 Die rote durchgezogene Kurve zeigt die Korrelationsfunktion mit 
\begin_inset Formula $\theta=0.01$
\end_inset

 und die grüne gestrichelte Kurve 
\begin_inset Formula $\theta=0.1$
\end_inset

.
 Nimmt man eine Differenz der beiden Stützstellen von 
\begin_inset Formula $\Delta x=5$
\end_inset

 an, dann ergeben sich für einen Hyperparameter von 
\begin_inset Formula $\theta=0.01$
\end_inset

 ein Korrelationswert von 0.53 und für 
\begin_inset Formula $\theta=0.1$
\end_inset

 ein Korrelationswert von 0.08.
 In dem einen Fall wird also eine stärkere Abhängigkeit der beiden Stützstellen
 angenommen und im anderen Fall eine schwächere Abhängigkeit.
 
\end_layout

\begin_layout Standard
\noindent

\shape italic
Falls einer der Parameter keine Korrelation mit der zu trainierenden Funktion
 besitzt, so kann das Trainingsverfahren auch sehr kleine Hyperparameter
 wählen.
 Dies führt praktisch dazu, dass dieser Parameter keinerlei Einfluss auf
 die Vorhersage mehr hat.
 Dies kann innerhalb einer Optimierung sehr wichtig sein, da so eine Art
 von Dimensionsreduktion erreicht wird.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/CorrelatoinFunction.eps
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-einer-Gauss-1"

\end_inset

Beispiel einer Gauss Korrelationsfunktion mit einer freien Variable und
 zwei unterschiedlichen 
\begin_inset Formula $\theta$
\end_inset

 Einstellungen und deren Einfluss auf den Korrelationswert 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Kovarianzfunktion CO-Kriging
\begin_inset CommandInset label
LatexCommand label
name "subsec:Kovarianzfunktion-CO-Kriging"

\end_inset


\end_layout

\begin_layout Standard
Die Kovarianzfunktion für das CO-Kriging wird aus mehreren Kovarianzfunktionen
 zusammengesetzt, daher werden keine neuen Modelle benötigt.
 Es werden allerdings für jede Gütestufe ein zusätzlicher Hyperparametervektor
 
\begin_inset Formula $\vec{\theta}_{2},\vec{\theta}_{diff}$
\end_inset

 verwendet.
 Geht man von den Gleichungen 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KovarianzFunktionenalleDrei"

\end_inset

 aus und setzt das entsprechende Kovarianzmodell aus Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ExpoKovarianzfunktion"

\end_inset

 ein, wobei 
\begin_inset Formula $c_{2}\left(\vec{h}\right)=e^{-\frac{1}{2}\underset{l=1}{\overset{l<=k}{\sum}}\left(e^{\theta_{l,2}}\left|h_{l}\right|^{p}\right)}$
\end_inset

 und 
\begin_inset Formula $c_{diff}\left(\vec{h}\right)=e^{-\frac{1}{2}\underset{l=1}{\overset{l<=k}{\sum}}\left(e^{\theta_{l,diff}}\left|h_{l}\right|^{p}\right)}$
\end_inset

, so erhält man:
\begin_inset Formula 
\begin{align}
cov\left(Z_{1}\left(\vec{x}_{1}\right),Z_{1}\left(\vec{x}_{2}\right)\right)= & a^{2}\sigma_{2}^{2}c_{2}\left(\vec{h}\right)\nonumber \\
 & +\lambda_{diff}\delta\left(\vec{h}\right)+\sigma_{diff}^{2}c_{diff}\left(\vec{h}\right)\nonumber \\
cov\left(Z_{1}\left(\vec{x}_{1}\right),Z_{2}\left(\vec{x}_{2}\right)\right)= & a\sigma_{2}^{2}c_{2}\left(\vec{h}\right)\label{eq:KovarianzfunktionenCoKrigingGauss}\\
cov\left(Z_{2}\left(\vec{x}_{1}\right),Z_{2}\left(\vec{x}_{2}\right)\right)= & \lambda_{2}\delta\left(\vec{h}\right)+\sigma_{2}^{2}c_{2}\left(\vec{h}\right)\nonumber 
\end{align}

\end_inset


\end_layout

\begin_layout Subsection
Nutzbarkeit innerhalb eines gradientenbasierten Trainingsverfahrens
\begin_inset CommandInset label
LatexCommand label
name "subsec:Negative-Hyperparameter-1"

\end_inset


\end_layout

\begin_layout Standard
Während des Trainingsverfahrens kann es dazu kommen, dass die Hyperparameter
 negative Werte annehmen können.
 Bei der Gauss Korrelationsfunktion würde dies dazu führen, dass die Korrelation
en auch Werte größer Eins erhalten können.
 Die liegt außerhalb des gültigen Wertebereichs und führt bei der Invertierung
 der Kovarianzmatrix zu numerischen Problemen.
 Daher sind negative Hyperparameter zwingend zu vermeiden.
 
\end_layout

\begin_layout Standard
Eine einfache Möglichkeit dies zu tun, wäre eine feste Begrenzung der Hyperparam
eter.
 Da die Hyperparameter während des Trainings durch gradientenbasierte Optimierun
gsverfahren eingestellt werden, kann eine 
\begin_inset Quotes gld
\end_inset

harte Grenze
\begin_inset Quotes grd
\end_inset

 zum Stillstand eines solchen Verfahrens führen und damit zu schlechten
 Resultaten.
 Für ein solches Verfahren ist es also wünschenswert, dass der gesamte Bereich
 der reellen Zahlen nutzbar ist.
 Eine simple Möglichkeit dies zu erreichen ist z.B.
 die Quadratur der Hyperparameter, dadurch sind keine negativen Werte mehr
 möglich:
\begin_inset Formula 
\begin{align*}
c\left(\vec{x}_{1},\vec{x}_{2}\right) & =e^{-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(\theta_{l}^{2}\left|x_{1l}-x_{2l}\right|^{2}\right)}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Diese Formulierung kann zu einem Stillstand des Trainings führen, da innerhalb
 des Trainings die Ableitung der Korrelationsfunktion nach den Hyperparametern
 eine wesentliche Rolle spielt:
\begin_inset Formula 
\begin{align*}
\frac{\partial c}{\partial\theta_{l}} & =c\left(\vec{x}_{1},\vec{x}_{2}\right)\left(-\theta_{l}\left|x_{1l}-x_{2l}\right|^{2}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Das Problem bei dieser Formulierung ist, dass wenn ein Hyperparameter während
 der Optimierung gegen Null geht, auch die entsprechende partielle Ableitung
 gegen Null läuft.
 Bei einem gradientenbasierten Minimierungsverfahrens kann es also passieren,
 dass die partiellen Ableitungen der Hyperparameter sehr kleine Werte annehmen
 und die Minimierung dadurch keine Fortschritte mehr macht.
 Um dieses Problem zu vermeiden, wurde die Exponentialfunktion verwendet:
\begin_inset Formula 
\begin{align*}
c\left(\vec{x}_{1},\vec{x}_{2}\right) & =e^{-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(e^{\theta_{l}}\left|x_{1l}-x_{2l}\right|^{2}\right)}\\
\frac{\partial c}{\partial\theta_{l}} & =c\left(\vec{x}_{1},\vec{x}_{2}\right)\left(-\frac{1}{2}e^{\theta_{l}}\left|x_{1l}-x_{2l}\right|^{2}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Diese Formulierung der Gauss-Korrelationsfunktion hat sich als sehr vorteilhaft
 herausgestellt, da der gesamte Raum der reellen Zahlen verwendet werden
 kann.
 Zudem ist die Funktion stetig, differenzierbar und zeigt auch kein unerwünschte
s Verhalten bei sehr kleinen Hyperparametern.
 
\end_layout

\begin_layout Section
Regularisierung und Behandlung verrauschter Funktionen
\begin_inset CommandInset label
LatexCommand label
name "sec:RegularisierungUndRauschen"

\end_inset


\end_layout

\begin_layout Standard
Zwei weitere wichtige Punkte der verschiedenen Kriging-Verfahren, sind die
 Berücksichtigungen von schlecht konditionierten Kovarianzmatrizen und der
 Umgang mit verrauschten Funktionen.
 Da die praktische Behandlung beider Problematiken sehr ähnlich ist, werden
 innerhalb dieses Kapitels beide Probleme gemeinsam beschrieben.
\end_layout

\begin_layout Subsection
Regularisierung
\begin_inset CommandInset label
LatexCommand label
name "subsec:Regularisierung"

\end_inset


\end_layout

\begin_layout Standard
Während des Trainings wird ein Satz Hyperparameter gesucht, welcher den
 Likelihood Wert (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:COKrigingTraining"

\end_inset

) maximiert.
 Dabei muss für jeden Satz an Hyperparametern die zugehörige Kovarianzmatrix
 aufgestellt werden.
 Bei diesem Prozess kann es passieren, dass die resultierende Matrix schlecht
 konditioniert ist und damit die verwendeten numerischen Verfahren instabil
 werden.
 Die Ursache einer schlecht konditionierten Matrix können sehr vielfältig
 sein und werden in 
\begin_inset CommandInset citation
LatexCommand cite
key "Davis1997"

\end_inset

 genauer beschrieben.
 In der Regel liegt es an schlecht verteilten Stützstellen oder an einer
 ungünstigen Initialisierung der Hyperparameter.
 Auch die Wahl der Kovarianzfunktion kann enormen Einfluss auf die numerische
 Stabilität haben.
 
\end_layout

\begin_layout Standard
Eine gebräuchliche Methode um die Konditionszahl zu verbessern, ist es die
 Hauptdiagonale der Kovarianzmatrix um einen Wert 
\begin_inset Formula $\lambda\in\mathbb{R}$
\end_inset

 (folgend Diagonalaufschlag) zu erhöhen.
 Dieses Vorgehen entspricht einer Tikhonov Regularisierung, wie sie häufig
 für Least Squares Verfahren eingesetzt wird (siehe 
\begin_inset CommandInset citation
LatexCommand cite
key "Sacks2007a,tikhonov2013numerical,hoerl2000"

\end_inset

).
 
\end_layout

\begin_layout Standard
Dieser Diagonalaufschlag sollte so klein wie möglich gehalten werden, da
 dessen Größe einen starken Einfluss auf die Vorhersagen hat.
 Das resultierende Verhalten wird im nächsten Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Approximation"

\end_inset

 behandelt.
 
\end_layout

\begin_layout Paragraph*
Ordinary Kriging
\begin_inset CommandInset label
LatexCommand label
name "par:Ordinary-Kriging"

\end_inset


\end_layout

\begin_layout Standard
Zur Bestimmung eines geeigneten Wertes, ist es sinnvoll die Konditionszahl
 
\begin_inset Formula $\kappa$
\end_inset

 der Kovarianzmatrix zu betrachten.
 Diese ist definiert als Quotient aus maximalem 
\begin_inset Formula $\Xi_{max}$
\end_inset

 und minimalem Eigenwert 
\begin_inset Formula $\Xi_{min}$
\end_inset

:
\begin_inset Formula 
\begin{align*}
\kappa & =\left|\frac{\Xi_{max}\left(\mathbf{Cov}\right)}{\Xi_{min}\left(\mathbf{Cov}\right)}\right|
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Geht man weiterhin von einer Ordinary-Kriging Kovarianzmatrix aus, so kann
 die Varianz 
\begin_inset Formula $\sigma^{2}$
\end_inset

 aus der Matrix ausgeklammert werden und die Korrelationsmatrix 
\begin_inset Formula $\mathbf{R}\in\mathbb{R}^{n\times n}$
\end_inset

 bleibt:
\begin_inset Formula 
\[
\mathbf{Cov}=\sigma^{2}\mathbf{R}
\]

\end_inset


\end_layout

\begin_layout Standard
Die Korrelationen innerhalb der Korrelationsmatrix 
\begin_inset Formula $\mathbf{R\in\mathbb{R}^{n\times n}}$
\end_inset

 können einen maximalen Wert von 1 annehmen.
 Daraus lässt sich der ungünstigste Fall 
\begin_inset Formula $\mathbf{\widetilde{R}}\in\mathbb{R}^{n\times n}$
\end_inset

 für die Konditionierung der Matrix ableiten, welcher einer reinen Einsmatrix
 entspricht.
\begin_inset Formula 
\begin{align}
\mathbf{Cov} & =\sigma^{2}\left[\begin{array}{ccc}
1 & ... & 1\\
... & ... & ...\\
1 & ... & 1
\end{array}\right]=\mathbf{\sigma^{2}\widetilde{R}}
\end{align}

\end_inset

Die minimalen und maximalen Eigenwerte der Einsmatrix sind für diesen Fall
 bekannt:
\begin_inset Formula 
\begin{align}
\Xi_{min}\left(\mathbf{Cov}\right) & =0\\
\Xi_{max}\left(\mathbf{Cov}\right) & =\sigma^{2}n
\end{align}

\end_inset

Dies würde einer unendlichen Konditionszahl entsprechen:
\begin_inset Formula 
\begin{align}
\kappa & =\infty
\end{align}

\end_inset

Addiert man nun den Diagonalaufschlag, bekommt man folgende Kovarianzmatrix:
 
\begin_inset Formula 
\begin{align}
\mathbf{\mathbf{Cov}} & =\left[\begin{array}{ccc}
\sigma^{2}+\lambda & ... & \sigma^{2}\\
... & ... & ...\\
\sigma^{2} & ... & \sigma^{2}+\lambda
\end{array}\right]\\
\mathbf{\mathbf{Cov}} & =\sigma^{2}\left[\begin{array}{ccc}
1+\frac{\lambda}{\sigma^{2}} & ... & 1\\
... & ... & ...\\
1 & ... & 1+\frac{\lambda}{\sigma^{2}}
\end{array}\right]
\end{align}

\end_inset

Daraus ergeben sich die folgenden maximalen und minimalen Eigenwerte:
\begin_inset Formula 
\begin{align}
\Xi_{min}\left(\mathbf{\mathbf{Cov}}\right) & =\lambda\\
\Xi_{max}\left(\mathbf{Cov}\right) & =\sigma^{2}\left(n+\frac{\lambda}{\sigma^{2}}\right)=\lambda+\sigma^{2}n
\end{align}

\end_inset

Und die entsprechende Konditionszahl verbessert sich zu:
\begin_inset Formula 
\begin{align}
\kappa & =\left|\frac{\lambda+\sigma^{2}n}{\lambda}\right|
\end{align}

\end_inset

Da die Matrix positiv definit sein muss und damit nur positive Eigenwerte
 hat, kann der Betrag vernachlässigt werden.
 Wählt man nun für die Konditionszahl eine obere Grenze, erhält man eine
 Untergrenze für den Diagonalaufschlag:
\begin_inset Formula 
\begin{align}
\kappa_{max} & >\frac{\lambda+\sigma^{2}n}{\lambda}\\
\lambda & >\frac{\sigma^{2}n}{\left(\kappa_{max}-1\right)}
\end{align}

\end_inset


\end_layout

\begin_layout Paragraph*
CO-Kriging
\end_layout

\begin_layout Standard
Im Falle des CO-Krigings ist, bedingt durch die unterschiedlichen Gütestufen,
 die Kovarianzmatrix partitioniert.
 
\end_layout

\begin_layout Standard
Der Ansatz aus dem Ordinary-Kriging ist mit dieser partitionierten Matrix
 nicht mehr möglich, dennoch ist es möglich den maximalen Eigenwert 
\begin_inset Formula $\Xi_{max}\left(\mathbf{Cov}\right)$
\end_inset

 der Matrix zu schätzen.
 Für eine diagonalisierbare Matrix gilt allgemein, dass die Summe der Eigenwerte
 
\begin_inset Formula $\Xi_{i},i\in\left\{ 1,...,n_{all}\right\} $
\end_inset

 der Spur der Matrix entspricht:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\sum_{i=1}^{n_{all}}\Xi_{i} & =spur\left(\mathbf{Cov}\right)\label{eq:SpurEqSummeEigenwerte}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Geht man von zusammengesetzten Kovarianzfunktion wie sie in den Gleichungen
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KovarianzfunktionenCoKrigingGauss"

\end_inset

 gezeigt wurde aus, so ergibt sich die Spur als Summe der Diagonaleinträge
 wie folgt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
spur\left(\mathbf{Cov}\right) & =\sum_{i=1}^{n_{1}}\left(a^{2}\sigma_{2}^{2}c_{2}\left(\vec{0}\right)+\sigma_{diff}^{2}c_{diff}\left(\vec{0}\right)+\lambda_{diff}\right)+\sum_{i=1}^{n_{2}}\left(\sigma_{2}^{2}c_{2}\left(\vec{0}\right)+\lambda_{2}\right)
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Da die Korrelationen der Diagonalen den Wert Eins besitzen,
\begin_inset Formula $c_{2}\left(\vec{0}\right)=1$
\end_inset

 und 
\begin_inset Formula $c_{diff}\left(\vec{0}\right)=1$
\end_inset

, gilt für die Spur der Matrix:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
spur\left(\mathbf{Cov}\right) & =\sum_{i=1}^{n_{1}}\left(a^{2}\sigma_{2}^{2}1+\sigma_{diff}^{2}1+\lambda_{diff}\right)+\sum_{i=1}^{n_{2}}\left(\sigma_{2}^{2}1+\lambda_{2}\right)\\
 & =n_{1}\left(a^{2}\sigma_{2}^{2}+\sigma_{diff}^{2}+\lambda_{diff}\right)+n_{2}\left(\sigma_{2}^{2}+\lambda_{2}\right)
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Übertragen auf Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:SpurEqSummeEigenwerte"

\end_inset

 folgt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\sum_{i=1}^{n_{all}}\Xi_{i} & =n_{1}\left(a^{2}\sigma_{2}^{2}+\sigma_{diff}^{2}+\lambda_{diff}\right)+n_{2}\left(\sigma_{2}^{2}+\lambda_{2}\right)\geq n_{1}\lambda_{diff}+n_{2}\lambda_{2}\label{eq:EigenwertBedSpur}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Geht man weiterhin von nur einem Regularisierungsterm 
\begin_inset Formula $\lambda_{diff}=\lambda_{2}=\lambda$
\end_inset

 für alle Gütestufen aus, gilt für den maximalen und minimalen Eigenwert
 
\begin_inset Formula $\Xi_{max},\Xi_{min}$
\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\Xi_{max} & \leq n_{1}\left(a^{2}\sigma_{2}^{2}+\sigma_{diff}^{2}+\lambda\right)+n_{2}\left(\sigma_{2}^{2}+\lambda\right)\\
\Xi_{min} & \geq\lambda;falls\,\Xi_{i}=\Xi_{min}\forall i\label{eq:EigenwertMinGrLambda}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:EigenwertMinGrLambda"

\end_inset

 folgt aus 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:EigenwertBedSpur"

\end_inset

 Für die Konditionszahl 
\begin_inset Formula $\kappa$
\end_inset

 lässt sich so eine obere Grenze bestimmen:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\kappa & \leq\frac{n_{1}\left(a^{2}\sigma_{2}^{2}+\sigma_{diff}^{2}+\lambda\right)+n_{2}\left(\sigma_{2}^{2}+\lambda\right)}{\lambda}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Legt man nun für die Konditionszahl einen maximalen Wert 
\begin_inset Formula $\kappa_{max}$
\end_inset

 fest, ergibt sich als Schätzung für den Diagonalaufschlag:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\lambda_{min} & \geq\frac{n_{1}a^{2}\sigma_{2}^{2}+n_{1}\sigma_{diff}^{2}+n_{2}\sigma_{2}^{2}}{\left(\kappa_{max}-\left(n_{2}+n_{1}\right)\right)}\label{eq:DiagonalSchätzungCoKriging}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Die Werte 
\begin_inset Formula $\sigma_{2}^{2},\sigma_{diff}^{2},a$
\end_inset

 werden während des Trainings oftmals verändert, dadurch ändert sich natürlich
 auch die untere Grenze des Diagonalaufschlags 
\begin_inset Formula $\lambda_{min}$
\end_inset

 (siehe Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:DiagonalSchätzungCoKriging"

\end_inset

) permanent.
 Prinzipiell sind zwei Lösungen möglich:
\end_layout

\begin_layout Enumerate
Die untere Grenze für 
\begin_inset Formula $\lambda_{min}$
\end_inset

 in jedem Trainingsschritt neu bestimmen und bei Unterschreitung auf den
 Grenzwert setzen.
\end_layout

\begin_layout Enumerate
Die untere Grenze für 
\begin_inset Formula $\lambda_{min}$
\end_inset

 nur beim Start des Trainings bestimmen.
 
\end_layout

\begin_layout Standard
Die erste Lösung kann dazu führen, dass sich der Grenzwert 
\begin_inset Formula $\lambda_{min}$
\end_inset

 während des Training ändert und der aktuelle Wert 
\begin_inset Formula $\lambda<\lambda_{min}$
\end_inset

 die Grenze unterschreitet.
 Da der Diagonalaufschlag dann bei Unterschreitung der Grenze abhängig von
 den Variablen 
\begin_inset Formula $\sigma_{2}^{2},\sigma_{diff}^{2},a$
\end_inset

 wird, muss dies bei der Ableitung des Likelihoods (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:COKrigingTraining"

\end_inset

) Berücksichtigung finden.
 
\end_layout

\begin_layout Standard
Aus diesem Grund wird die zweite Variante gewählt, also die untere Grenze
 nur initial eingestellt und dann nicht mehr verändert.
 Es sei denn es treten numerische Probleme während des Trainings auf, dann
 wird in der Software eine entsprechende Exception geworfen und in der Software
 abgefangen.
 Daraufhin wird der letzte Iterationsschritt wiederholt und der Diagonalaufschla
g so lange erhöht, bis die numerischen Probleme verschwinden.
 Gelingt selbst dies nicht, wird ein Fehler ausgegeben und abgebrochen.
 
\end_layout

\begin_layout Standard
Ein geeigneter Wert für die obere Grenze der Konditionszahl liegt erfahrungsgemä
ß bei 
\begin_inset Formula $\sim10^{9}$
\end_inset

, dieser Wert kann im Einzelfall natürlich angepasst werden.
 
\end_layout

\begin_layout Subsection
Behandlung verrauschter Funktionen
\begin_inset CommandInset label
LatexCommand label
name "subsec:Approximation"

\end_inset


\end_layout

\begin_layout Standard
Bei Vernachlässigung des Diagonalaufschlags 
\begin_inset Formula $\lambda$
\end_inset

, ist das bisher beschriebene Kriging-Verfahren rein interpolierend.
 In einigen Fällen ist allerdings ein approximierendes Verhalten gewünscht.
 Ein solches Verhalten entspricht dem in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Variogramm"

\end_inset

 beschriebenen 
\begin_inset Quotes gld
\end_inset

Nugget-Effekt
\begin_inset Quotes grd
\end_inset

.
 Die praktische Umsetzung innerhalb des Kriging Verfahrens ist letztlich
 dieselbe wie bei dem in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Regularisierung"

\end_inset

 beschriebenen Regularisierungsterm.
 Der hauptsächliche Unterschied besteht in der Größenordnung des Diagonalaufschl
ags 
\begin_inset Formula $\lambda$
\end_inset

 und in dessen Bedeutung.
 Da es sich bei dem Diagonalaufschlag in diesem Fall um eine Varianz handelt
 die einem zufälligen Rauschen entspricht, siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Kovarianz-parametrisiertes-Model"

\end_inset

.
 Zudem ist der Diagonalaufschlag für diesen Fall als Hyperparameter zu behandeln
 und muss daher mit trainiert werden.
 Die Umsetzung soll folgend gezeigt werden.
 
\end_layout

\begin_layout Standard
Die Bildung der Kovarianzfunktion ist in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Kovarianzfunktion-CO-Kriging"

\end_inset

 beschrieben.
 Um den Rauschterm innerhalb eines gradientenbasierten Trainingsverfahrens
 (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:MinimierungsverfahrenTraining"

\end_inset

) zu verwenden, müssen noch die Ableitungen der Kovarianzfunktionen nach
 den Rauschtermen gebildet werden.
 Im Fall des Co-Krigings mit den zwei Rauschtermen 
\begin_inset Formula $\lambda_{diff},\lambda_{2}\in\mathbb{R}$
\end_inset

 sehen die partiellen Ableitungen wie folgt aus: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\frac{cov\left(Z_{1}\left(\vec{x}_{1}\right),Z_{1}\left(\vec{x}_{2}\right)\right)}{\partial\lambda_{diff}}= & 1\nonumber \\
\frac{cov\left(Z_{1}\left(\vec{x}_{1}\right),Z_{1}\left(\vec{x}_{2}\right)\right)}{\partial\lambda_{2}}= & 0\\
\frac{cov\left(Z_{1}\left(\vec{x}_{1}\right),Z_{2}\left(\vec{x}_{2}\right)\right)}{\partial\lambda_{diff}}=\frac{cov\left(Z_{1}\left(\vec{x}_{1}\right),Z_{2}\left(\vec{x}_{2}\right)\right)}{\partial\lambda_{2}}= & 0\label{eq:KovarianzfunktionenCoKrigingAbleitungDiag}\\
\frac{cov\left(Z_{2}\left(\vec{x}_{1}\right),Z_{2}\left(\vec{x}_{2}\right)\right)}{\partial\lambda_{diff}}= & 0\nonumber \\
\frac{cov\left(Z_{2}\left(\vec{x}_{1}\right),Z_{2}\left(\vec{x}_{2}\right)\right)}{\partial\lambda_{2}}= & 1
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Mit diesen Ableitungen ist das Maximum Likelihood Verfahren (siehe Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:COKrigingTraining"

\end_inset

 und Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:MinimierungsverfahrenTraining"

\end_inset

) direkt anwendbar.
 
\end_layout

\begin_layout Paragraph*
Rauschterm Beispiel
\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Kriging_RauschFunktion"

\end_inset

 wird ein einfaches Beispiel gezeigt, es soll die Wirkung von unterschiedlichen
 Rauschtermen auf die Vorhersage beispielhaft erläutert werden.
 Es handelt sich um eine konstante Null-Funktion mit einem normalverteilten
 Rauschen, welche den Erwartungswert Null und die Standardabweichung Eins
 besitzt: 
\begin_inset Formula $f\left(x\right)=\mathcal{N}\left(0,1\right)$
\end_inset

.
 Jeder eingezeichnete Punkt entspricht einer Stützstelle, wobei jede Stützstelle
 an einem anderen Ort ist.
 Mit Hilfe dieser Stützstellen wird dann ein Ordinary-Kriging trainiert
 und dann für den entsprechenden Wertebereich Vorhersagen getroffen.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/KrigingKapitel/KonstantenRauschFunktion.eps
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Kriging_RauschFunktion"

\end_inset

Konstante Funktion mit normalverteiltem Rauschen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:RauschenBeispiel"

\end_inset

 zeigt zwei mögliche Vorhersagen, beide werden durch den Likelihood Term
 gleichermaßen gut bewertet.
\end_layout

\begin_layout Standard
Die schwarze Linie entspricht dem vorhergesagten Erwartungswert und die
 Fehlerbalken der vorhergesagten Standardabweichung.
 Auf dem linken Bild zeigt das trainierte Kriging eine approximierendes
 Verhalten und auf dem rechten Bild ein interpolierendes Verhalten.
 Auf dem rechten Bild wird jeder der Stützstellen exakt wiedergegeben und
 die vorhersagte Standardabweichung ist an diesen Stellen Null.
 Der Diagonalaufschlag ist bei dieser Lösung ebenfalls Null.
\end_layout

\begin_layout Standard
Auf dem linken Bild hat der Diagonalaufschlag den Wert Eins, was genau der
 Varianz des Rauschterms entspricht.
 Im Extrapolationsbereich zeigen die verschiedenen Vorhersagen exakt dieselben
 Ergebnisse.
 Diese Doppeldeutigkeit kann auf die Einstellungen der Hyperparameter zurückgefü
hrt werden, die wesentlichen Hyperparameter sind die Prozessvarianz 
\begin_inset Formula $\sigma^{2}$
\end_inset

, der Diagonalaufschlag 
\begin_inset Formula $\lambda$
\end_inset

 und die Korrelationslänge 
\begin_inset Formula $\theta$
\end_inset

.
 Tabelle 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:KrigingRauschBspEinstellungn"

\end_inset

 zeigt die Einstellungen der beiden Lösungen.
 Für das Training der beiden Kriging-Modelle wurde der Diagonalaufschlag
 
\begin_inset Formula $\lambda$
\end_inset

 vorher festgelegt und die anderen Größen durch das Training automatisch
 bestimmt.
 
\end_layout

\begin_layout Standard
Die interpolierenden Variante besitzt eine Varianz von 
\begin_inset Formula $\sigma^{2}=1$
\end_inset

.
 Diese Varianz entspricht dann dem 
\begin_inset Quotes gld
\end_inset

Sill
\begin_inset Quotes grd
\end_inset

 aus Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Variogramm"

\end_inset

, also der Varianz bei großem Abstand zu einem bekannten Punkt.
 Der Abstand wird durch die Korrelationslänge 
\begin_inset Formula $\theta$
\end_inset

 beeinflusst.
 Wobei ein großer 
\begin_inset Formula $\theta$
\end_inset

 Wert auf einen räumlich sehr kleinen Einfluss deutet.
 Diese Lösung würde also einem sehr steilen Variogramm entsprechen, welches
 bei kleinstem Abstand sofort auf den 
\begin_inset Quotes gld
\end_inset

Sill
\begin_inset Quotes grd
\end_inset

 springt.
 Das Variogramm wird qualitativ in dem rechten Diagramm der Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:VarioApproxInter"

\end_inset

 dargestellt.
 
\end_layout

\begin_layout Standard
Die approximierende Variante hat eine sehr kleine Korrelationslänge 
\begin_inset Formula $\theta=e^{-50}$
\end_inset

 und eine Varianz von 
\begin_inset Formula $\sigma^{2}=0$
\end_inset

, was einer konstanten Funktion ohne Unsicherheit entspricht.
 Durch den Rauschterm 
\begin_inset Formula $\lambda=1$
\end_inset

 wird dem Modell eine grundlegende Unsicherheit aufaddiert, welche dem 
\begin_inset Quotes gld
\end_inset

Nugget
\begin_inset Quotes grd
\end_inset

 entspricht.
 Das entsprechende Variogramm wäre unabhängig von der Distanz und entspricht
 dem linken Diagramm in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:VarioApproxInter"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interpolierend
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Approximierend
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\sigma^{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lambda$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\theta$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e^{15}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $e^{-50}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:KrigingRauschBspEinstellungn"

\end_inset

Einstellungen der verschiedenen Kriging-Lösungen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/KrigingKapitel/semiSteep.eps
	scale 70

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:VarioApproxInter"

\end_inset

Qualitatives Variogramm für das interpolierende und approximierende Kriging
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/KrigingKapitel/KonstantenRauschFunktionPunkte.eps
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:RauschenBeispiel"

\end_inset

Normalverteiltes Rauschen und zwei mögliche Kriging Modelle.
 Die Fehlerbalken stellen die vorhergesagte Standardabweichung dar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die beiden gezeigt Lösungen haben denselben Likelihood Wert, werden vom
 Trainingsverfahren also als gleichwertig angesehen.
 Welche Lösung letztlich vom Training gewählt wird, hängt hauptsächlich
 von der gewählten Initialisierung ab.
 In Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

 werden verschiedene Möglichkeiten der Initialisierung beschrieben.
 
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:RauschBeiespielDiagonalaufschlagVarianz"

\end_inset

 zeigt für verschiedene Diagonalaufschläge den resultierenden Likelihood-Wert,
 wobei hier ein kleiner Likelihood ein besseres Ergebnis darstellt.
 Das Ergebnis zeigt, dass der Likelihood-Wert für einem Diagonalaufschlag
 im Bereich von 
\begin_inset Formula $\lambda>0\land\lambda<1$
\end_inset

 konstant und minimal bleibt.
 Darüber wird der Likelihood-Wert dann deutlich größer.
 Um das Verhalten zu verstehen, wird in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:RauschBeispielVarianzDiag"

\end_inset

 die eingestellte Varianz 
\begin_inset Formula $\sigma^{2}$
\end_inset

 und der Diagonalaufschlag für den Bereich des optimalen Likelihood-Wertes
 gezeigt.
 Das Ergebnis ist auch hier plausibel, denn in der Summe ergeben die beiden
 Werte immer den Wert 
\begin_inset Formula $\sigma^{2}+\lambda=1$
\end_inset

, was dann wiederum der Varianz des Erzeugungsprozesses entspricht.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/KrigingKapitel/DiagonalLikelihood.eps
	scale 60

\end_inset


\begin_inset Graphics
	filename ../images/KrigingKapitel/DiagonalVarianz.eps
	scale 60

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:RauschBeiespielDiagonalaufschlagVarianz"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:RauschBeispielVarianzDiag"

\end_inset

 (a) Diagonalaufschlag und Varianz und resultierender Likelihood Wert (b)
 Bereich des optimalen Likelihood-Wertes und Entwicklung des Diagonalaufschlag
 und der Varianz
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das hier gezeigte Verhalten entspricht also den Erwartungen.
 Allerdings kann dies bei einer geringeren Datenlage oder einer komplexeren
 Funktion dazu führen, dass der Diagonalaufschlag deutlich überschätzt wird.
 Die praktische Erfahrung zeigt auch genau ein solches Verhalten.
 Aus diesem Grund sollte das Training des Diagonalaufschlags als nur optionale
 Funktion des Trainings verfügbar sein.
 
\end_layout

\begin_layout Subsection
Softwaretechnische Umsetzung von Approximation und Regularisierung 
\end_layout

\begin_layout Standard
In den Kapiteln 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Regularisierung"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Approximation"

\end_inset

 wird ein Diagonalaufschlag verwendet, um eine Regularisierung der Matrix
 zu erreichen und auch um ein approximierendes Verhalten herbeizuführen.
 Praktische Unterschiede ergeben sich nur in der Größe der Werte und in
 der Bestimmung während des Trainings.
 Auf der einen Seite steht der Regularisierungsterm, welcher für die numerische
 Stabilität sorgen soll.
 Dieser soll die Vorhersage möglichst nicht beeinflussen und muss daher
 sehr klein gewählt werden.
 Zudem ist dieser nicht als Hyperparameter anzusehen und daher keine zu
 trainierende Größe.
 Auf der anderen Seite steht der Rauschterm, welcher für ein approximierende
 Verhalten sorgen soll.
 Dieser Parameter wird auch innerhalb des Trainingsverfahrens geschätzt
 und ist als Hyperparameter einzustufen.
 Um nicht für den Regularisierungsterm und den Rauschterm jeweils einen
 eigenen Wert zu verwenden, ist es möglich den Regularisierungsterm als
 minimale Grenze anzunehmen.
 Der Rauschterm kann dann wie beschrieben trainiert werden, besitzt dann
 allerdings eine untere Schranke, die sich wie in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Regularisierung"

\end_inset

 beschrieben festlegen lässt.
 
\end_layout

\begin_layout Section
Training
\begin_inset CommandInset label
LatexCommand label
name "chap:MinimierungsverfahrenTraining"

\end_inset


\end_layout

\begin_layout Standard
Im Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Maximum-Likelihood-für"

\end_inset

 wurde die Maximum Likelihood Methode vorgestellt.
 Als Ergebnis dieses Kapitels erhielt man zwei Gleichungen zur Berechnung
 des Likelihood Terms und der dazugehörigen Ableitung.
 Ziel ist es, für den Likelihood Term die optimalen Hyperparameter zu finden.
 Dieser Vorgang ist das eigentliche Training des Modells.
 Zu diesem Zweck werden zwei numerische Minimierungsverfahren vorgestellt.
 Beide Minimierungsverfahren waren bereits in einer institutseigenen Bibliothek
 vorhanden.
 Die entwickelte Minimierungsklasse sollte beide Verfahren nutzen können.
 Hierfür wurde ein spezielles Klassenmodell unter Benutzung von Boost Funktionso
bjekten entwickelt.
\end_layout

\begin_layout Standard
Das Training bringt einige zusätzliche Probleme mit sich, z.B.
 müssen die Hyperparameter anfangs initialisiert werden.
 Zudem kann die Korrelationsmatrix schlecht konditioniert sein, für beide
 Probleme wurden Lösungsansätze entwickelt, welche hier vorgestellt werden.
 
\end_layout

\begin_layout Standard

\color red
In Anhang 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:AnhangLikelihoodCOKrigingBsp"

\end_inset

 ist ein Beispiel einer Likelihood Funktion eines CO-Kriging Modells gezeigt.
 Hier ist die Komplexität der zu optimierenden Funktion ersichtlich.
\end_layout

\begin_layout Subsection
Maximum Likelihood für alle Kriging Verfahren
\begin_inset CommandInset label
LatexCommand label
name "sec:COKrigingTraining"

\end_inset


\end_layout

\begin_layout Standard
Um ein Kriging-Modell vollständig aufzustellen, ist es nötig sinnvolle Werte
 für die Hyperparameter zu finden.
 Ein sehr häufig verwendetes Verfahren ist die Maximum Likelihood Methode.
 Diese Methode soll in diesem Abschnitt anhand eines einfachen Beispiels
 erläutert werden.
 Grundsätzlich ist die Maximum Likelihood Methode ein parametrisches Schätzverfa
hren in der Statistik.
 Es werden Werte für Hyperparameter gewählt, gemäß derer die Realisierung
 der bereits bekannten Daten am plausibelsten erscheint.
 
\end_layout

\begin_layout Standard
Es wird von einer Zufallsvariablen 
\begin_inset Formula $Z$
\end_inset

 ausgegangen, die Dichtefunktion 
\begin_inset Formula $f$
\end_inset

 dieser Zufallsvariablen hängt von einem oder mehreren Parametern ab.
 Die könnten z.B.
 bei einer Normalverteilung der Erwartungswert und die Standardabweichung
 sein.
 Der Einfachheit halber wird im folgenden ein Parameter 
\begin_inset Formula $p$
\end_inset

 verwendet.
 Liegt nun eine Stichprobe mit 
\begin_inset Formula $n$
\end_inset

 Messwerten 
\begin_inset Formula $x_{1}..x_{n}$
\end_inset

 vor, ist eine Faktorisierung möglich, wenn diese unabhängig sind und die
 dabei entstehende Funktion 
\begin_inset Formula $L$
\end_inset

 wird Likelihood Funktion genannt (siehe 
\begin_inset CommandInset citation
LatexCommand cite
key "Otterbach2014"

\end_inset

):
\begin_inset Formula 
\begin{align}
L\left(p\right) & =\underset{i=1}{\prod}f\left(x_{i},q\right)\label{eq:Likelihood Funktion-1}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Wird diese Funktion nun in Abhängigkeit von 
\begin_inset Formula $q$
\end_inset

 maximiert, erhält man die Maximum-Likelihood-Schätzung für 
\begin_inset Formula $q$
\end_inset

.
 Man erhält also die Dichtefunktion bei der die Werte 
\begin_inset Formula $x_{1}..x_{n}$
\end_inset

 die größte Dichte in Abhängigkeit von 
\begin_inset Formula $q$
\end_inset

 haben und welche damit auch am plausibelsten erscheint.
 
\end_layout

\begin_layout Standard
Um diesen Ansatz bei einem Verfahren wie dem Kriging anzuwenden, werden
 die bekannten Funktionswerte als Realisierung einer multivariaten Normalverteil
ung 
\begin_inset Formula $\mathcal{N}\left(\vec{F},\mathbf{Cov}\right)$
\end_inset

 angenommen.
 Wobei 
\begin_inset Formula $\mathbf{Cov\in\mathbb{R^{\mathrm{n_{all}\times n_{all}}}}}$
\end_inset

 die jeweilige Kovarianzmatrix, 
\begin_inset Formula $\vec{y}_{s}$
\end_inset

 den Vektor aller bekannten Stützstellen und 
\begin_inset Formula $\vec{F}$
\end_inset

 den Vektor mit den jeweiligen stationären Erwartungswerten darstellt (siehe
 Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:FVektor"

\end_inset

).
 
\begin_inset Formula 
\begin{align*}
\mathcal{N}= & \frac{1}{\left(2\pi\right)^{\frac{n}{2}}\det\left(\mathbf{Cov}\right)^{\frac{1}{2}}}e^{-\frac{1}{2}\left(\vec{y}_{s}-\vec{F}\right)^{T}\mathbf{Cov^{\textrm{-1}}}\left(\vec{y}_{s}-\vec{F}\right)}
\end{align*}

\end_inset

Logarithmiert man diese Gleichung, ergibt sich:
\begin_inset Formula 
\begin{align*}
\log(\mathcal{N})= & \log(1)-\frac{n}{2}\log(2\pi)-\frac{1}{2}\log\left(\det(\mathbf{\mathbf{Cov}})\right)-\frac{1}{2}\left(\vec{y}_{s}-\overrightarrow{F}\right)^{T}\mathbf{\mathbf{Cov}}^{-1}\left(\vec{y}_{s}-\overrightarrow{F}\right)
\end{align*}

\end_inset

Da das Maximum der Funktion gesucht ist, können die Konstanten ignoriert
 werden:
\begin_inset Formula 
\begin{align}
\log(\mathcal{N})= & -\log\left(\det(\mathbf{\mathbf{Cov}})\right)-\left(\vec{y}_{s}-\overrightarrow{F}\right)^{T}\mathbf{\mathbf{Cov}}^{-1}\left(\vec{y}_{s}-\overrightarrow{F}\right)
\end{align}

\end_inset

Die Ableitung nach einem beliebigen Hyperparameter 
\begin_inset Formula $h_{l}$
\end_inset

 sieht dann wie folgt aus, die vollständige Herleitung ist in Anhang 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Differentiation-der-Likelihood-Funktion"

\end_inset

 zu finden:
\begin_inset Formula 
\begin{align}
\frac{\partial L\left(\vec{h}\right)}{\partial h_{l}}= & -\textrm{Spur}\left(\mathbf{\mathbf{Cov}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\right)+\left(\left(\vec{y}_{s}-\overrightarrow{F}\right)^{T}\mathbf{\mathbf{\mathbf{Cov}}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\mathbf{\mathbf{Cov}}^{-1}\left(\vec{y}_{s}-\overrightarrow{F}\right)\right)
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Damit ist es nun möglich die unbekannten Hyperparameter mit einem geeigneten
 Minimierungsverfahren zu bestimmen.
 Einige in dieser Arbeit verwendete Minimierungsverfahren werden in Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Minimierungsverfahren"

\end_inset

 beschrieben.
\end_layout

\begin_layout Standard
Um eine Vorstellung von der Form einer solchen Likelihood Funktion für das
 CO-Kriging Verfahren zu bekommen, wird in Anhang 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:AnhangLikelihoodCOKrigingBsp"

\end_inset

 ein einfaches Beispiel in Abhängigkeit verschiedener Hyperparameter gezeigt.
 Die Form der Funktion spielt auch für das gewählte Trainingsverfahren eine
 wesentliche Rolle.
\end_layout

\begin_layout Subsection
Likelihood Schätzer Erwartungswerte und Varianz 
\begin_inset CommandInset label
LatexCommand label
name "subsec:CoKrigingAnalytische-Bestimmung-derErwwartzungswerte"

\end_inset


\end_layout

\begin_layout Standard
Die Maximierung der Likelihood-Funktion in Abhängigkeit der Erwartungswerte
 
\begin_inset Formula $\overrightarrow{F}\in\mathbb{R^{\mathrm{n_{all}}}}$
\end_inset

 ist analytisch lösbar.
 Im Folgenden soll die Lösung dafür gezeigt werden.
 Die Anzahl der Gütestufen wird mit 
\begin_inset Formula $s$
\end_inset

 gekennzeichnet, die Anzahl der Stützstellen einer Gütestufe 
\begin_inset Formula $k\in\left\{ 1,...,s\right\} $
\end_inset

 wird mit 
\begin_inset Formula $n_{k}$
\end_inset

 bezeichnet und 
\begin_inset Formula $n_{all}$
\end_inset

 bezeichnet die Anzahl der Stützstellen aller Gütestufen.
 Das Maximum der mehrdimensionalen Normalverteilung nach dem Maximum Likelihood
 Ansatz bezüglich des Vektors 
\begin_inset Formula $\overrightarrow{F}\in\mathbb{R^{\mathrm{n_{all}}}}$
\end_inset

 sieht wie folgt aus:
\end_layout

\begin_layout Paragraph
\begin_inset Formula 
\[
MLE\left(\overrightarrow{F}\right)=max\left(\frac{1}{\left(2\pi\right)^{\frac{n}{2}}|\mathbf{Cov}|^{\frac{1}{2}}}e^{-\frac{1}{2}\left(\overrightarrow{y}-\overrightarrow{F}\right)^{T}\mathbf{Cov}^{-1}\left(\overrightarrow{y}-\overrightarrow{F}\right)}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
Führt man eine Matrix 
\begin_inset Formula $\mathbf{G}\in\mathbb{R^{\mathrm{n_{all}\times s}}}$
\end_inset

 ein in der Form:
\begin_inset Formula 
\begin{equation}
\mathbf{G}=\left[\begin{array}{ccc}
1 &  & 0\\
\vdots & \cdots & \vdots\\
1_{n_{1}} &  & 0_{n_{1}}\\
0 & 1 & 0\\
\vdots & \ddots & \vdots\\
0_{n_{k}} & 1 & 0_{n_{k}}\\
0 &  & 1\\
\vdots & \cdots & \vdots\\
0_{n_{s}} &  & 1_{n_{s}}
\end{array}\right]\label{eq:DefinitionG}
\end{equation}

\end_inset

Und einen Vektor 
\begin_inset Formula $\vec{\tilde{F}}\in\mathbb{R^{\mathrm{s\times1}}}$
\end_inset

, so gilt folgende Beziehung:
\begin_inset Formula 
\begin{align*}
\vec{F} & =\mathbf{G}\vec{\tilde{F}}
\end{align*}

\end_inset

Daraus folgt:
\begin_inset Formula 
\begin{align*}
MLE\left(\vec{\tilde{F}}\right) & =max\left(\frac{1}{\left(2\pi\right)^{\frac{n}{2}}|\mathbf{Cov}|^{\frac{1}{2}}}e^{-\frac{1}{2}\left(\overrightarrow{y}-\mathbf{G}\vec{\tilde{F}}\right)^{T}\mathbf{Cov}^{-1}\left(\overrightarrow{y}-\mathbf{G}\vec{\tilde{F}}\right)}\right)
\end{align*}

\end_inset

Mit dieser Gleichung lässt sich der gesuchte Erwartungswertvektor 
\begin_inset Formula $\vec{\tilde{F}}$
\end_inset

 des Kriging Prozesses innerhalb des Trainings analytisch bestimmen.
 Die Lösung sieht wie folgt aus, wobei der komplette Lösungsweg in Anhang
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Likelihood-Schätzer-Erwartungswe"

\end_inset

 zu finden ist:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\left(\overrightarrow{y}^{T}\mathbf{Cov}^{-1}\mathbf{G}\right)\left(\mathbf{G}^{T}\mathbf{Cov}^{-1}\mathbf{G}\right)^{-1} & =\vec{\tilde{F}}^{T}
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph*
Varianz
\end_layout

\begin_layout Standard
Die direkte analytische Bestimmung der Varianz im Falle des Co-Kriging Verfahren
s ist mit der hier gewählten Formulierung nicht möglich.
 Es ist allerdings eine iterative Bestimmung möglich, diese Art der Bestimmung
 wird in Anhang 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Iterative-VarianzbestimmungTraining"

\end_inset

 beschrieben und bringt allerdings viele numerische Probleme mit sich und
 wurde aus diesem Grund nicht verwendet.
 Innerhalb dieses Verfahrens wurden die Varianzen als zusätzlicher Hyperparamete
r innerhalb des Trainings freigegeben und werden dann über das Training
 bestimmt.
 
\end_layout

\begin_layout Subsection
Initialisierung der Hyperparameter für alle Kriging Modelle 
\begin_inset CommandInset label
LatexCommand label
name "sec:Initialisierung-der-Hyperparamet"

\end_inset


\end_layout

\begin_layout Standard
Um einen Minimierungsalgorithmus starten zu können, ist eine geeignete Initialis
ierung der Hyperparameter von großer Bedeutung.
 Diese kann die Konvergenz und auch die Stabilität der Minimierung stark
 beeinflussen.
 Innerhalb dieser Arbeit wurden mehrere Ansätze entwickelt, um eine geeignete
 Initialisierung zu finden.
 
\end_layout

\begin_layout Subsection*
Abschätzung konstanter Hyperparameter 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Const"

\end_inset


\end_layout

\begin_layout Standard
Eine sehr einfache und schnelle Möglichkeit die Hyperparameter für eine
 Gauss Verteilung zu schätzen, wäre einen Erwartungswert für die Einträge
 in der Korrelationsmatrix zu wählen.
 Da die Korrelation grundlegend zwischen Eins und Null liegen sollte, ist
 dies recht einfach.
 Angenommen der Mittelwert der Korrelationsfunktion soll bei einem Wert
 von 
\begin_inset Formula $c_{erw}=\left\{ c_{erw}\in\mathbb{R}|0\leq c_{erw}\leq1\right\} $
\end_inset

 liegen.
\begin_inset Formula 
\begin{align*}
c_{erw} & =\frac{1}{n^{2}}\underset{i=1}{\overset{i<n}{\sum}}\underset{j=1}{\overset{j<n}{\sum}}e^{-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(e^{\theta_{l}}\left|x_{i,l}-x_{j,l}\right|^{2}\right)}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Nimmt man weiterhin an, dass die einzelnen Korrelationswerte nahezu identisch
 sind:
\begin_inset Formula 
\begin{align*}
c_{erw} & =e^{-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(e^{\theta_{l}}\left|x_{i,l}-x_{j,l}\right|^{2}\right)}
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\left(\vec{x}_{i},\vec{x}_{j}\right)\right) & =-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(e^{\theta_{l}}\left|x_{i,l}-x_{j,l}\right|^{2}\right)
\end{align*}

\end_inset

Nimmt man ferner an, dass 
\begin_inset Formula $x$
\end_inset

 eine Realisierung einer Zufallsvariablen ist und bildet den Erwartungswert:
\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\left(\vec{x}_{i},\vec{x}_{j}\right)\right) & =E\left[-\frac{1}{2}\underset{l=1}{\overset{l<k}{\sum}}\left(e^{\theta_{l}}\left|x_{i,l}-x_{j,l}\right|^{2}\right)\right]
\end{align*}

\end_inset

Als weitere Vereinfachung sollen alle Hyperparameter den gleichen Wert haben:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\left(\vec{x}_{i},\vec{x}_{j}\right)\right) & =-\frac{1}{2}e^{\theta}E\left[\underset{l=1}{\overset{l<k}{\sum}}\left(\left|x_{i,l}-x_{j,l}\right|^{2}\right)\right]
\end{align*}

\end_inset

Die beiden Variablen werden als Zufallsvariablen angenommen und der Betrag
 wird aufgrund des Quadrats vernachlässigt:
\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\right) & =-\frac{1}{2}e^{\theta}E\left[\underset{l=1}{\overset{l<k}{\sum}}\left(x_{i,l}-x_{j,l}\right)^{2}\right]
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\right) & =-\frac{1}{2}e^{\theta}\underset{l=1}{\overset{l<k}{\sum}}\left(E\left[x_{i,l}^{2}\right]-E\left[2x_{i,l}x_{j,l}\right]+E\left[x_{j,l}^{2}\right]\right)
\end{align*}

\end_inset

Nimmt man nun an, dass die Zufallsvariablen unabhängig sind, gilt 
\begin_inset Formula $E\left[2x_{i,l}x_{j,l}\right]=0$
\end_inset


\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\right) & =-\frac{1}{2}e^{\theta}\underset{l=1}{\overset{l<k}{\sum}}\left(E\left[x_{i,l}^{2}\right]+E\left[x_{j,l}^{2}\right]\right)
\end{align*}

\end_inset

Die Varianz einer Zufallsvariable 
\begin_inset Formula $X$
\end_inset

 ist definiert durch 
\begin_inset Formula $\textrm{var}\left(X\right)=E\left[X^{2}\right]-E\left[X\right]^{2}$
\end_inset

.
 Die im Modell verwendeten Daten werden grundsätzlich auf einen Erwartungswert
 von Null und eine Standardabweichung von Eins normiert.
\begin_inset Formula 
\begin{align*}
E\left[X\right] & =0
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\textrm{var}\left[X\right] & =1
\end{align*}

\end_inset

Daraus ergibt sich folgende Formel für das verwendete Modell für die Varianz
 der Stützstellen:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\textrm{var}\left[X\right]=E\left[X^{2}\right]
\end{align*}

\end_inset

Also
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
E\left[x_{i,l}^{2}\right] & =\textrm{var}\left[x_{i,l}^{2}\right]=1
\end{align*}

\end_inset

und analog dazu:
\begin_inset Formula 
\begin{align*}
E\left[x_{j,l}^{2}\right] & =\textrm{var}\left[x_{j,l}^{2}\right]=1
\end{align*}

\end_inset

Daraus folgt:
\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\right) & =-\frac{1}{2}e^{\theta}\underset{l=1}{\overset{l<k}{\sum}}\left(1+1\right)
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
\log\left(c_{erw}\right) & =-\frac{1}{2}e^{\theta}2k
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align}
\log\left(-\frac{\log\left(c_{erw}\right)}{k}\right) & =\theta\label{eq:ConstThetaSchatzung}
\end{align}

\end_inset

Mit dieser Formel hat man nun eine Möglichkeit die Hyperparameter zu schätzen.
 Aufgrund der vielen Annahmen und Vereinfachungen ist dieses Verfahren als
 heuristisch einzustufen.
 Die Hyperparameter haben dann allerdings alle denselben Initialwert.
 Zudem ist der erwartete Korrelationswert 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $c_{erw}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang ngerman
 unbekannt, dies kann leicht durch einfaches Ausprobieren gelöst werden,
 da der Wertebereich bekannt ist.
 Man würde also 
\begin_inset Formula $c_{erw}$
\end_inset

 von 0 bis 1 variieren, damit einen Hyperparameter erhalten und mit diesem
 Hyperparameter die Likelihood Funktion berechnen.
 Letztlich wählt man den Hyperparameter, welcher den besten Likelihood Wert
 aufweist.
 
\end_layout

\begin_layout Subsection*
Zufällige Initialisierung der Hyperparameter
\begin_inset CommandInset label
LatexCommand label
name "subsec:Reduktion-der-Stützstellen"

\end_inset


\end_layout

\begin_layout Standard
Eine weitere Möglichkeit eine Initialisierung für die Hyperparameter zu
 finden ist, diese zufällig zu Erzeugen und die entsprechende Likelihood
 Funktion zu berechnen.
 Es würden die Hyperparameter gewählt, welche die beste Likelihood Funktion
 haben.
 Die zufällige Erzeugung ist extrem zeitaufwendig, da für jeden Satz zufälliger
 Hyperparameter die Likelihood Funktion ausgewertet werden muss.
 Um diesen Aufwand zu reduzieren, kann man einfach Stützstellen weglassen.
 Die Likelihood Funktion sollte sich im Vergleich zumindest ähnlich verhalten.
 Statt einer zufälligen Veränderung der Hyperparameter kann man auch ein
 Minimierungsverfahren mit reduzierter Stützstellenzahl verwenden.
 Dies wurde im Code auch umgesetzt.
 Die möglichen Minimierungsverfahren sind dieselben wie sie für das eigentliche
 Training verwendet werden und werden im nächsten Abschnitt beschrieben.
 
\end_layout

\begin_layout Standard
Reduziert man die Anzahl der Stützstellen wird die Korrelationsmatrix dementspre
chend kleiner.
 Dadurch sinkt der Aufwand für die Invertierung und die Matrix Multiplikationen
 erheblich.
 Tests zeigten, dass die Initialisierung durch solch ein Verfahren zwar
 langsamer ist, allerdings konvergiert das Minimierungsverfahren durch die
 bessere Initialisierung deutlich schneller.
 Da bei dem Minimierungsverfahren wieder die volle Anzahl der Stützstellen
 notwendig ist und zusätzlich noch die Ableitungen der Korrelationsmatrix
 berechnet werden müssen, bietet dieses Verfahren durch die bessere Initialisier
ung für das gesamte Training betrachtet eine deutliche Beschleunigung.
 
\end_layout

\begin_layout Standard
Allerdings konnte auch beobachtet werden, dass die Initialisierung häufiger
 zu lokalen Minima führt.
 Eine Begründung für dieses Verhalten wurde noch nicht gefunden und sollte
 weitergehend untersucht werden.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Ein geeignetes Initialisierungverfahren für Ordinary-, Gradient Enhanced-
 und CO-Kriging zu finden ist keine leichte Aufgabe, dennoch kann eine Initialis
ierung das Trainingsergebnis enorm beeinflussen.
 Dies ist insbesondere von großer Bedeutung bei der Verwendung von gradientenbas
ierten Trainingsverfahren wie dem Quasi-Newton.
 Das CO-Kriging stellt hier die größte Herausforderung dar, da bei diesem
 Verfahren nicht nur die Hyperparameter der Korrelationsfunktionen bestimmt
 werden müssen, sondern auch die Prozessvarianz für jede Fidelity des Krigingmod
ells und die Diagonalaufschläge ebenfalls für jede Fidelity.
 
\end_layout

\begin_layout Standard
Eine zufällige Initialisierung der Hyperparameter ist sicherlich ein gutes
 Verfahren zur Initialisierung.
 Der Vorteil bei diesem Verfahren liegt darin, dass während einer Optimierung
 Variation in die Modelle gelangt.
 Dies ist wünschenswert, daes bei einem konstanten Initialisierungsverfahren
 durchaus passieren kann, dass man durchgängig schlechte Modelle hat.
 Dies passiert insbesondere bei hochdimensionalen Parameterräumen.
 Für eine zufällige Initialisierung müssen allerdings Grenzen für die Hyperparam
eter gewählt werden, um den Suchraum zu verkleinern.
 
\end_layout

\begin_layout Standard
Für die minimale Grenze der Hyperparameter eignet sich das in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

 vorgestellte Verfahren, für den Erwartungswert der Korrelationen sollte
 man hier einen hohen Wert wählen, bspw.
 0.99 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\log\left(-\frac{\log\left(0.99\right)}{k}\right) & =\theta_{min}\label{eq:ConstThetaSchatzung-1}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Die maximale Grenze bedarf einer kleinen Änderung, da man in diesem Fall
 wissen möchte, wie groß ein dominierendes 
\begin_inset Formula $\theta$
\end_inset

 ist.
 Nimmt man einen geringen Erwartungswert für die Korrelation an von z.B.
 0.01, so wäre der Schätzwert für ein dominierendes 
\begin_inset Formula $\theta$
\end_inset

 größer, als wenn man annimmt, alle 
\begin_inset Formula $\theta$
\end_inset

 seien gleich.
 Die Formel ändert sich dadurch zu:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\log\left(-\log\left(0.01\right)\right) & =\theta_{max}\label{eq:ConstThetaSchatzung-1-1}
\end{align}

\end_inset


\end_layout

\begin_layout Subsection*
Genetisch/Zufällige Initialisierung der Hyperparameter 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Reduktion-der-Stützstellen-1"

\end_inset


\end_layout

\begin_layout Standard
Random 2 beschreiben 
\end_layout

\begin_layout Standard
Reduktion der zu bestimmenden Parameter auf 5 beim CO-Kriging 2 Thetas,
 2 Varianzen und 1 Scale Faktor
\end_layout

\begin_layout Standard
Wiederverwendung des besten bisher gefundenen und normalverteilt um diesen
 variieren
\end_layout

\begin_layout Standard
Birgt die Gefahr in ein lokales Minimum zu kommen, durch die Zufälligkeit
 ist diese Gefahr allerdings eher klein
\end_layout

\begin_layout Subsection*
Initialisierung auf Basis bereits vorhandener Kriging Modelle
\end_layout

\begin_layout Standard
Das Kriging Modell wird in der Regel innerhalb einer Optimierung verwendet.
 In der Regel wird mit jedem neuen konvergierten Member ein neues Training
 gestartet und so die Hyperparameter neu bestimmt.
 Grundsätzlich wäre es natürlich äußerst sinnvoll die Hyperparameter aus
 den letzten trainierten Modellen zur Initialisierung zu verwenden.
 Als einfacher Ansatz wäre es z.B.
 möglich einfach immer die Hyperparameter aus dem letzten Training zu Initialisi
erung zu verwenden.
 Diese Art der Wiederverwendung von alten Trainings ist für das Kriging
 Verfahren ohne Probleme möglich.
 Ändert sich jedoch die Datenbasis für das Training und damit auch die Normalisi
erungskonstanten, so müssen die Hyperparameter renormalisiert werden, in
 Anhang 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Renormalisierung-der-Hyperparame"

\end_inset

 wird eine solche Renormalisierung beschrieben.
 
\end_layout

\begin_layout Standard
Bei der Wiederverwendung alter Hyperparametersätz müssen jedoch zwei Problemstel
lungen beachtet werden:
\end_layout

\begin_layout Enumerate
Das letzte Modell befindet sich in einem lokalen Minimum der Likelihood
 Funktion
\end_layout

\begin_layout Enumerate
Die Hyperparameter der Kovarianz Funktion(en) sind noch nicht richtig eingestell
t
\end_layout

\begin_layout Standard
Im ersten Fall besteht die Gefahr, dass das Training durch die ungünstige
 Initialisierung in einem lokalen Minimum bleibt und so nicht die optimalen
 Hyperparameter findet.
 Das wiederum führt zu schlechten Vorhersagen.
 Im Extremfall kann es sogar passieren, dass das lokale Minimum während
 der gesamten Optimierung nicht mehr verlassen wird.
 
\end_layout

\begin_layout Standard
Der zweite Fall ist insbesondere am Anfang der Optimierung interessant,
 denn am Anfang hat man in der Regel nur wenig Samples zur Verfügung und
 damit ist es dem Kriging Training noch nicht möglich die richtigen Hyperparamet
er für die Kovarianzfunktion zu schätzen.
 Diese Fälle treten erfahrungsgemäß leider sehr häufig auf, deshalb sollte
 man auf diese Art der Initialisierung verzichten.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Eine rein zufällige Initialisierung hat allerdings den Nachteil, dass die
 Trainingszeit enorm steigt und die Modelle im Laufe der Optimierung sehr
 unterschiedlich ausfallen können.
 Eine andere Möglichkeit der Initialisierung ist eine Mischform zwischen
 zufälliger Initialisierung und der Verwendung alter Modelle.
 In diesem Fall soll ein Kriterium darüber entscheiden, ob ein altes Kriging
 Modell verwendet werden soll oder eine zufällige Initialisierung durchgeführt
 werden soll.
 Zudem ist es sinnvoll nicht nur das letzte Kriging Modell zu betrachten,
 sondern noch weitere Modelle die während der Optimierung entstanden sind.
 Dies macht insbesondere Sinn, da das Ausprobieren eines vorhandenen Hyperparame
ter Satz im Vergleich zum Training nur einen Bruchteil der Zeit benötigt
 und man so einzelne 
\begin_inset Quotes eld
\end_inset

Ausreißer
\begin_inset Quotes erd
\end_inset

 in den Modellen nicht den weiteren Optimierungsverlauf gefährden.
 Der in AutoOpti verwendete Algorithmus sieht wie folgt aus:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

bestKrigingFile = None
\end_layout

\begin_layout Plain Layout

vector<string> krigingFiles = getLastKrigingFiles(20);
\end_layout

\begin_layout Plain Layout

if(krigingFiles.size() < 20){
\end_layout

\begin_layout Plain Layout

	initType = random;
\end_layout

\begin_layout Plain Layout

	end()
\end_layout

\begin_layout Plain Layout

} 				
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for(i=0; i < krigingFiles.size() ; i++){
\end_layout

\begin_layout Plain Layout

	oldLikelihood = getLikelihood(krigingFiles[i])
\end_layout

\begin_layout Plain Layout

	newLikelihood = calculateLikelihood(krigingFiles[i])
\end_layout

\begin_layout Plain Layout

	if( (newLikelihood < bestLikelihood) 
\end_layout

\begin_layout Plain Layout

	and (newLikelihood < oldLikelihood) 
\end_layout

\begin_layout Plain Layout

	and (newLikelihood < -numberSamples/4.0) ){
\end_layout

\begin_layout Plain Layout

			bestLikelihood =newLikelihood
\end_layout

\begin_layout Plain Layout

			bestKrigingFile = krigingFiles[i]
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(bestKrigingFile==None)
\end_layout

\begin_layout Plain Layout

	initType = random;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Algorithmus startet mit dem Speichern der Dateinamen der letzten 20
 Kriging Modelle aus der laufenden Optimierung (Zeile 2).
 Sind noch keine 20 Kriging Modelle erzeugt worden, soll die Initialisierung
 zufällig erfolgen (Zeile 3-6).
 In der darauffolgenden for Schleife erfolgt nun die Bewertung der einzelnen
 Kriging Modelle.
 Für die Bewertung muss zuerst der alte Likelihood Wert ausgelesen werden,
 dies geschieht in Zeile 10.
 Im nächsten Schritt muss der Likelihood mit der aktuellen Datenbasis neu
 berechnet werden, in der Regel sind an dieser Stelle einige Member zur
 Datenbasis hinzugekommen.
 Dieser Schritt ist numerisch auch der aufwendigste, allerdings muss keine
 Invertierung 
\begin_inset Formula $\mathcal{O\left(\mathrm{n^{3}}\right)}$
\end_inset

 durchgeführt werden, sondern jeweils nur ein Gleichungssystem gelöst werden
 
\begin_inset Formula $\mathcal{O\left(\mathrm{n^{2}}\right)}$
\end_inset

.
 In der darauffolgenden If Abfrage geht es zum einen darum das beste Modell
 der 20 eingelesenen Kriging Modelle zu finden.
 Hierfür wird einfach der kleinste Likelihood verwendet (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Likelihood"

\end_inset

).
 Zudem ist eine weitere Bedingung, dass der neu berechnete Likelihood kleiner
 sein muss, als der bereits eingelesene aus dem vorhergehenden Modell.
 Die Überlegung hierbei ist, dass wenn ein neues Sample eingefügt wird und
 dieses nicht in die angenommene Verteilung passt, die Hyperparameter vollständi
g neu eingestellt werden müssen.
 Im umgekehrten Fall, sollte der Likelihood kleiner werden, da dieser linear
 mit der Sample Anzahl sinkt.
 
\end_layout

\begin_layout Standard
Als letzte Bedingung ist eine absolute Grenze für den Likelihood Wert angegeben,
 diese basiert rein auf Erfahrungswerten und soll sicherstellen, dass grundsätzl
ich zu schlechte Modelle zufällig initialisiert werden.
 Dies ist meistens am Anfang einer Optimierung der Fall, wenn noch nicht
 genügend Daten vorhanden sind, um die Kovarianzfunktion ausreichend gut
 zu schätzen.
 In diesem Fall ist eine zufällige Initialisierung ebenfalls günstiger.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../images/UltraRestart/Vergleich.png
	scale 15

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:RestartRandomLikelihood"

\end_inset

Vergleich verschiedener Initialisierungsverfahren und deren Auswirkung auf
 eine Testoptimierung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Minimierungsverfahren 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Minimierungsverfahren"

\end_inset


\end_layout

\begin_layout Standard
Innerhalb des Kriging Modells wurden zwei verschiedene mehrdimensionale
 Minimierungsverfahren eingesetzt.
 Beide Verfahren waren bereits in einer institutseigenen Software Bibliothek
 verfügbar.
 
\end_layout

\begin_layout Subsection*
Minimierungsverfahren angelehnt an Resilient Backpropagation
\begin_inset CommandInset label
LatexCommand label
name "subsec:RPROP"

\end_inset


\end_layout

\begin_layout Standard
Das erste hier verwendete Minimierungsverfahren ist angelehnt an ein Trainingsve
rfahren für Neuronale Netzwerke, genannt RPROP (Resilient Backpropagation)
 
\begin_inset CommandInset citation
LatexCommand cite
key "riedmiller1993direct,NNSchiffmann"

\end_inset

 und ist ein Verfahren erster Ordnung.
 Besonderheit des Verfahrens ist, dass es nur das Vorzeichen der partiellen
 Ableitungen verwendet und nicht den Wert selbst.
 
\end_layout

\begin_layout Standard
Die Änderung der Hyperparameter 
\begin_inset Formula $\theta_{i}$
\end_inset

 für den nächsten Iterationsschritt 
\begin_inset Formula $t+1$
\end_inset

 ergibt sich aus der Schrittweite 
\begin_inset Formula $\gamma_{i}$
\end_inset

.
 Diese wird für jeden Hyperparameter einzeln bestimmt und in jeder Iteration
 geändert.
 Die Änderung hängt nur von dem Vorzeichen der entsprechenden partiellen
 Ableitung 
\begin_inset Formula $\frac{\partial f}{\partial\theta_{i}}$
\end_inset

 zum Zeitpunkt t der zu minimierenden Funktion 
\begin_inset Formula $f$
\end_inset

 ab.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\theta_{i}^{t+1} & =\theta_{i}^{t}-\gamma_{i}^{t}\textrm{sgn}\left(\left(\frac{\partial f}{\partial\theta_{i}}\right)^{t}\right)
\end{align*}

\end_inset

 
\end_layout

\begin_layout Standard
Die Schrittweite wird in jedem Iterationsschritt für jeden Hyperparameter
 einzeln angepasst.
 Dies wird über zwei Multiplikatoren erzielt 
\begin_inset Formula $\eta^{+}=\left\{ \eta^{+}\in\mathbb{R}|1<\eta^{+}\right\} $
\end_inset

 und 
\begin_inset Formula $\eta^{-}=\left\{ \eta^{-}\in\mathbb{R}|1>\eta^{-}\right\} $
\end_inset

.
 Ist die entsprechende partielle Ableitung aus dem letzten Schritt multipliziert
 mit dem jetzigen Schritt größer als Null, wird die Schrittweite erhöht,
 indem die Schrittweite 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $\gamma_{i}^{t}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang ngerman
 multipliziert wird mit 
\begin_inset Formula $\eta^{+}$
\end_inset

.
 Wenn die partielle Ableitung aus dem letzten Schritt multipliziert mit
 dem jetzigen Schritt kleiner als Null ist, dann wird die Schrittweite verkleine
rt durch Multiplikation mit 
\begin_inset Formula $\eta^{-}$
\end_inset

.
 Für die Schrittweite wird zudem eine Unter- und Obergrenze (
\begin_inset Formula $\gamma_{min},\gamma_{max}$
\end_inset

) festgelegt.
 
\begin_inset Formula 
\begin{align*}
\gamma_{i}^{t+1} & =\begin{cases}
\min\left(\gamma_{i}^{t}\eta^{+},\gamma_{max}\right) & wenn\left(\frac{\partial f}{\partial\theta_{i}}\right)^{t}\left(\frac{\partial f}{\partial\theta_{i}}\right)^{t-1}>0\\
\max\left(\gamma_{i}^{t}\eta^{-},\gamma_{min}\right) & wenn\left(\frac{\partial f}{\partial\theta_{i}}\right)^{t}\left(\frac{\partial f}{\partial\theta_{i}}\right)^{t-1}<0\\
\gamma_{i}^{t} & sonst
\end{cases}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Bei sehr flachen Bereichen der zu minimierenden Funktion, wo die partiellen
 Ableitungen nur sehr klein sind, würden andere Gradientenverfahren nur
 sehr langsam bis gar nicht mehr vorwärts kommen.
 Da dieses Verfahren allerdings die Größe der Gradienten überhaupt nicht
 berücksichtigt, kann dies nicht passieren.
 Das ist bei der Likelihood Funktion von besonderem Vorteil, da diese bereits
 durch Ihre Definition sehr viele flache Gebiete aufweist.
 
\end_layout

\begin_layout Subsection*
Verbessertes Minimierungsverfahren angelehnt an Resilient Backpropagation
\begin_inset CommandInset label
LatexCommand label
name "subsec:RPROP2"

\end_inset


\end_layout

\begin_layout Standard
Ein sehr großes Problem bei dem RPROP Verfahren ist, dass es relativ viele
 Iterationen benötigt bis es konvergiert.
 In jedem Iterationsschritt muss zum einen der Dichtefunktionswert der Likelihoo
d Funktion berechnet werden und zum anderen die partiellen Ableitungen nach
 den Hyperparametern.
 Die Berechnung der Likelihood Funktion sowie die Berechnung einer partiellen
 Ableitung ist von der Komplexität 
\begin_inset Formula $\mathcal{O}\left(n^{2}\right)$
\end_inset

.
 Es müssen allerdings 
\begin_inset Formula $o$
\end_inset

 partielle Ableitungen gebildet werden, aus diesem Grund kann der numerische
 Aufwand stark variieren.
 Besonders im Co-Kriging ist dieser Punkt wichtig, da die Anzahl der Hyperparame
ter größer ist, als bei einem Ordinary-Kriging.
 
\end_layout

\begin_layout Standard
Die Lernraten 
\begin_inset Formula $\eta^{+},\eta^{-}$
\end_inset

 sind im RPROP Verfahren konstant, insbesondere bei den anfänglichen Iterationss
chritten führt dies zu einem relativ langsamen Anpassen der Deltas 
\begin_inset Formula $\gamma_{i}^{t}$
\end_inset

.
 Es wäre daher wünschenswert die Lernraten ebenfalls anzupassen.
 Eine gute Möglichkeit ist es verschiedene Lernraten einfach auszuprobieren.
 Der folgende Pseudo Programmcode zeigt die Umsetzung des neuen Verfahrens:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

density = RPROPDensity(eta_plus, eta_minus)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Teste kleinere und größere Lernraten für eta_plus
\end_layout

\begin_layout Plain Layout

for(eta_plusFact=0.9; eta_plusFact<=1.1; eta_plusFact+=0.2){
\end_layout

\begin_layout Plain Layout

	newEtaPlus = eta_plus*eta_plusFact
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if(newEtaPlus<1.2)
\end_layout

\begin_layout Plain Layout

				newEtaPlus=1.2
\end_layout

\begin_layout Plain Layout

	if(newEtaPlus>2.0)
\end_layout

\begin_layout Plain Layout

				newEtaPlus=2.0
\end_layout

\begin_layout Plain Layout

	if(eta_plus==newEtaPlus)
\end_layout

\begin_layout Plain Layout

				continue
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	newDensity = RPROPDensity(newEtaPlus, eta_minus)
\end_layout

\begin_layout Plain Layout

	if(newDensity<density)
\end_layout

\begin_layout Plain Layout

		eta_plus=newEtaPlus
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Teste kleinere und größere Lernraten für eta_minus
\end_layout

\begin_layout Plain Layout

for(eta_minusFact=0.9; eta_minusFact<=1.1; eta_minusFact+=0.2){
\end_layout

\begin_layout Plain Layout

	newEtaMinus = eta_minus*eta_minusFact
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if(newEtaMinus<0.4)
\end_layout

\begin_layout Plain Layout

				newEtaMinus=0.4
\end_layout

\begin_layout Plain Layout

	if(newEtaMinus>0.7)
\end_layout

\begin_layout Plain Layout

				newEtaMinus=0.7
\end_layout

\begin_layout Plain Layout

	if(eta_minus==newEtaMinus)
\end_layout

\begin_layout Plain Layout

				continue
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	newDensity = RPROPDensity(eta_plus, newEtaMinus)
\end_layout

\begin_layout Plain Layout

	if(newDensity<density)
\end_layout

\begin_layout Plain Layout

		eta_minus=newEtaMinus
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In einem Iterationsschritt, wird dann zuerst der Dichtefunktionswert  mit
 den bisherigen Lernraten 
\begin_inset Formula $\eta^{+},\eta^{-}$
\end_inset

 berechnet.
\end_layout

\begin_layout Standard
Danach wird dann zuerst 
\begin_inset Formula $\eta^{+}$
\end_inset

 leicht erhöht oder verringert und überprüft, ob es im Bereich von 
\begin_inset Formula $2.0>\eta^{+}>1.2$
\end_inset

 liegt (diese Werte sind reine Erfahrungswerte).
 Sollte sich das neue 
\begin_inset Formula $\eta^{+}$
\end_inset

 nicht geändert haben, so wird sich die Berechnung der Dichtefunktion gespart.
 Gewählt wird die Lernrate mit dem geringsten Dichtefunktionswert.
 Für die Lernrate 
\begin_inset Formula $\eta^{-}$
\end_inset

 gilt im Prinzip dasselbe.
 
\end_layout

\begin_layout Standard
Für diese Art der Lernratenregelung sind maximal 4 neue Dichtefunktionsauswertun
gen notwendig, im Gegenzug hat man allerdings eine deutliche Verringerung
 der Iterationsanzahl und muss somit deutlich weniger partielle Ableitungen
 bestimmen.
 Diese sollte insbesondere für das CO-Kriging von großem Vorteil sein.
\end_layout

\begin_layout Standard
Um das Verfahren zu validieren, wurde eine Datenbasis aus einer aktuellen
 Optimierung für einen gegenläufigen Rotor verwendet (
\color red
Referenz
\color inherit
).
 Es gab ca.
 113 freie Parameter und für das CO-Kriging somit 228 Hyperparameter (130*2
 und 2x die Prozessvarianzen der Kovarianzfunktionen) und die Datenbasis
 enthielt zu diesem Zeitpunkt 373 Member.
 Das CO-Kriging wurde mit zufälligen Hyperparametern initialisiert und 10x
 mit dem RPROP Verfahren trainiert und 10x mit dem neuen RPROP2 Verfahren.
 Die Vorhersagen der fertig trainierten Ersatzmodelle wurden dann anhand
 einer Testdatenbasis validiert und ein mittlerer Vorhersagefehler bestimmt.
 Die folgenden Tabellen zeigen die Ergebnisse beider Verfahren:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RPROP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mittelwert
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Standardabweichung
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainingszeit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
346.3s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100.9s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mittlerer Fehler
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0201
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.00565
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainingsiterationen
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
781
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
165
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RPROP2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mittelwert
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Standardabweichung
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainingszeit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
186s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
50.29s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mittlerer Fehler
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0149
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0031
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainingsiterationen
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
398
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
86
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Man kann sehen, dass das RPROP Verfahren in diesem Beispiel die 1.86 fache
 Zeit benötigt um Konvergenz zu erreichen.
 Dies wird hauptsächlich durch die deutlich geringere Iterationsanzahl erreicht.
 Die mittleren Fehler sind in etwa vergleichbar, die etwas geringeren Fehler
 beim RPROP2 sind mit hoher Wahrscheinlichkeit zufälliger Natur.
 
\end_layout

\begin_layout Standard
Die folgende Abbildung zeigt nochmal den gemittelten Trainingsverlauf beider
 Verfahren.
 Die rote und schwarze Kurve stellt den mittleren Dichtefunktionswert über
 den Iterationsschritten dar.
 Die Fehlerbalken sind die Standardabweichungen der verschiedenen Trainings.
 Auch hier lässt sich gut erkennen, dass das RPROP2 Verfahren eine deutlich
 schnelleren Konvergenzverlauf hat, insbesondere am Anfang.
 Dies wird durch die schneller eingestellten Deltas erreicht.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../images/RPROP2/Vergleich.png
	scale 25

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Natürlich bleibt zu beachten, dass das Verfahren bei einer sehr geringen
 Anzahl von Hyperparametern auch durchaus langsamer sein kann.
 
\end_layout

\begin_layout Subsection*
Quasi Newton
\begin_inset CommandInset label
LatexCommand label
name "subsec:Quasi-Newton"

\end_inset


\end_layout

\begin_layout Standard
Das zweite implementierte Minimierungsverfahren ist ein Verfahren höherer
 Ordnung namens Quasi Newton.
 Basis für diese Art der mehrdimensionalen Minimierung ist eine Taylor Approxima
tion zweiten Grades, wobei 
\begin_inset Formula $t$
\end_inset

 der Iterationsschritt ist und 
\begin_inset Formula $\mathbf{H}$
\end_inset

 die Hesse Matrix: 
\begin_inset Formula 
\begin{align*}
f\left(\vec{\theta}\right) & \approx f\left(\vec{\theta}_{t}\right)+\left(\vec{\theta}-\vec{\theta}_{t}\right)^{T}\nabla f\left(\vec{\theta}_{k}\right)+\frac{1}{2}\left(\vec{\theta}-\vec{\theta}_{t}\right)^{T}\mathbf{H}\left(\vec{\theta}_{t}\right)\left(\vec{\theta}-\vec{\theta}_{t}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Die entsprechende Ableitung dieser Funktion muss im Minimum oder Maximum
 der Funktion Null ergeben:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\nabla f\left(\vec{\theta}\right) & \approx\nabla f\left(\vec{\theta}_{t}\right)+\mathbf{H}\left(\vec{\theta}_{t}\right)\left(\vec{\theta}-\vec{\theta}_{t}\right)=0
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Besonderheit bei der Quasi Newton Methode ist, dass die Hesse Matrix 
\begin_inset Formula $\mathbf{H}$
\end_inset

, nicht direkt berechnet werden muss, sondern sukzessive über die Gradienten
 angenähert wird.
 Vorteil des Verfahrens ist, dass es deutlich schneller konvergiert als
 das bereits vorgestellte Verfahren erster Ordnung.
 Allerdings ist es weniger robust und kann in flachen Gebieten der Funktion
 langsam bis gar nicht konvergieren.
 Die exakte Umsetzung des Algorithmus und weitere Details können in 
\begin_inset CommandInset citation
LatexCommand cite
key "press2007numerical,gill1981practical,gill2007numerical"

\end_inset

 gefunden werden.
\end_layout

\begin_layout Section
Vergleiche zu anderen CO-Kriging Modellen
\begin_inset CommandInset label
LatexCommand label
name "sec:VergleicheCoKrigingAndere"

\end_inset


\end_layout

\begin_layout Standard
Alle Kriging Verfahren in einem Code!!!!
\end_layout

\begin_layout Standard
In diesem Abschnitt sollen die Unterschiede und Gemeinsamkeiten zu einigen
 anderen Co-Kriging Verfahren herausgestellt werden.
 Eine grundlegende Arbeit in diesem Bereich stellt die Veröffentlichung
 von 
\begin_inset CommandInset citation
LatexCommand cite
key "Kennedy2000"

\end_inset

 dar.
 Das dort beschriebene Modell ist dem in dieser Arbeit in sehr vielen Punkten
 ähnlich.
 Beispielsweise ist das Kovarianzmodell dasselbe wie in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:COKrigingKovarianzmodell"

\end_inset

 beschrieben.
 Damit gleichen sich der Aufbau der Kovarianzmatrix 
\begin_inset Formula $\mathbf{Cov}\in\mathbb{R^{\mathrm{n_{all}}\times\textrm{n_{all}}}}$
\end_inset

 und außerdem ähnelt die analytische Bestimmung des Erwartungswertvektors
 
\begin_inset Formula $\overrightarrow{F}\in\mathbb{R^{\mathrm{n_{all}}}}$
\end_inset

 der Bestimmung aus Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:CoKrigingAnalytische-Bestimmung-derErwwartzungswerte"

\end_inset

.
 Allerdings beinhaltet der Erwartungswertvektor bei 
\begin_inset CommandInset citation
LatexCommand cite
key "Kennedy2000"

\end_inset

 die Erwartungswerte der höchsten Gütestufe und die der Differenzfunktion
 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Kennedy2000"

\end_inset

 Gleichung 4 und 5).
 In der hier verwendeten Formulierung entspricht der Differenzerwartungswert
 dem Erwartungswert der niedrigen Gütestufe selbst.
 Dieser Unterschied ist aber nur unwesentlich, da das Ergebnis davon unberührt
 bleibt.
 
\end_layout

\begin_layout Standard
Größere Unterschiede zeigen sich im Trainingsverfahren und zwar gilt bei
 
\begin_inset CommandInset citation
LatexCommand cite
key "Kennedy2000"

\end_inset

 die Bedingung, dass an jeder Stützstelle hoher Güte auch eine Stützstelle
 niedriger Güte bekannt sein muss.
 Dies resultiert aus der Annahme, dass die Daten und damit auch die Hyperparamet
er niedrigerer Güte, unabhängig von den Daten hoher Güte trainierbar sind.
 
\end_layout

\begin_layout Standard
Durch diese Annahme kann man die Hyperparameter für die Gütestufen hierarchisch
 (Bottom-Top) bestimmen.
 Das Training der Hyperparameter wird dadurch vereinfacht und auch der numerisch
e Aufwand sinkt dadurch, da man zwei unabhängige Trainings durchführt mit
 jeweils einer Kovarianzmatrix der Größe des jeweiligen Datensatzes.
 Als Beispiel müssten bei einer Anzahl von 
\begin_inset Formula $n_{high}$
\end_inset

 High-Fidelity und 
\begin_inset Formula $n_{low}$
\end_inset

 Low-Fidelity Stützstellen jeweils ein Training mit den Kovarianzmatrizen
 
\begin_inset Formula $\mathbf{Cov_{high}}\in\mathbb{R^{\mathrm{n_{high}\times n_{high}}}}$
\end_inset

 und 
\begin_inset Formula $\mathbf{Cov_{low}}\in\mathbb{R^{\mathrm{n_{low}\times n_{low}}}}$
\end_inset

 durchgeführt werden.
 Die Komplexität liegt dann bei etwa 
\begin_inset Formula $\mathcal{O}\left(n_{high}^{3}\right)+\mathcal{O}\left(n_{low}^{3}\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
In dem hier beschrieben Verfahren werden alle Hyperparameter gleichzeitig
 trainiert, wodurch die Stützstellen der unterschiedlichen Gütestufen beliebig
 verteilt sein können.
 Es muss also nicht an jedem Punkt hoher Güte auch ein Punkt niedriger Güte
 vorhanden sein.
 Der numerische Aufwand steigt dadurch allerdings, da die gesamte Kovarianzmatri
x zerlegt werden muss und auch alle Hyperparameter gleichzeitig trainiert
 werden.
 Die Komplexität liegt dann bei 
\begin_inset Formula $\mathcal{O}\left(\left(n_{high}+n_{low}\right)^{3}\right)$
\end_inset

.
 Dennoch wird dies als zeitlicher Vorteil erachtet, da der Zeitaufwand für
 die Bestimmung der zusätzlichen Stützstellen deutlich größer ist als der
 zusätzliche Trainingsaufwand, insbesondere bei Turbomaschinenanwendungen.
 
\end_layout

\begin_layout Standard
Weiterhin wird auch der mögliche Lösungsraum für die Hyperparameter größer.
 Der Grund liegt darin, dass man den Raum der Hyperparameter (wobei 
\begin_inset Formula $o$
\end_inset

 die Anzahl der Hyperparameter angibt) von 
\begin_inset Formula $\mathbb{R^{\mathrm{o_{high}+o_{low}}}}$
\end_inset

 auf die beiden Räume 
\begin_inset Formula $\mathbb{R^{\mathrm{o_{high}}}}$
\end_inset

 und 
\begin_inset Formula $\mathbb{R^{\mathrm{o_{high}}}}$
\end_inset

 auftrennt und damit mögliche Lösungen für die Hyperparameter ausschließt.
\end_layout

\begin_layout Standard
Aufbauend auf der Arbeit von 
\begin_inset CommandInset citation
LatexCommand cite
key "Kennedy2000"

\end_inset

, schlägt 
\begin_inset CommandInset citation
LatexCommand cite
key "forrester2007multi"

\end_inset

 ein weiteres Modell vor.
 In diesem wird ein Ordinary-Kriging auf die Daten niedrigerer Güte aufgestellt
 und die Vorhersagen aus dem Modell dazu verwendet, die Differenz-Kovarianzfunkt
ion und damit das resultierende Co-Kriging Modell aufzustellen.
 Grundlegend ist dies zwar eine praktikable Lösung, allerdings wird damit
 die Bedingung von 
\begin_inset CommandInset citation
LatexCommand cite
key "Kennedy2000"

\end_inset

 
\begin_inset Formula $p\left(z|\phi\right)=p\left(z_{high}|z_{low},\rho,\beta_{high},\sigma_{high}^{2}\right)p\left(z_{low}|\beta_{low},\sigma_{low}^{2}\right)$
\end_inset

 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Kennedy2000"

\end_inset

 Gleichung 8) verletzt.
 Diese besagt, das die Schätzung der Parameter der Verteilungsfunktion hoher
 Güte 
\begin_inset Formula $\rho,\beta_{high},\sigma_{high}^{2}$
\end_inset

 unabhängig von den Parametern niedrigerer Güte 
\begin_inset Formula $\beta_{low},\sigma_{low}^{2}$
\end_inset

 erfolgen kann.
 Da die Daten niedrigerer Güte dann aber aus einer Kriging-Vorhersage stammen,
 sind 
\begin_inset Formula $z_{low},\rho,\beta_{high},\sigma_{high}^{2}$
\end_inset

 nicht mehr unabhängig von 
\begin_inset Formula $\beta_{low},\sigma_{low}^{2}$
\end_inset

.
 Weiterhin sind diese Vorhersagen mit einer Unsicherheit behaftet, stellen
 also selbst Verteilungen dar.
 Inwiefern dieser Umstand beachtet werden sollte, wurde hier allerdings
 nicht mehr weiter untersucht.
 
\end_layout

\begin_layout Standard
Eine weitere Herangehensweise kann in 
\begin_inset CommandInset citation
LatexCommand cite
key "han2012alternative"

\end_inset

 gefunden werden.
 In dieser Arbeit wird ein Co-Kriging-Modell mit drei unabhängigen Kovarianzfunk
tionen beschrieben.
 Die bedeutet, dass drei verschiedene Hyperparametersätze gleichzeitig trainiert
 werden.
 Dies führt allerdings zu erheblichen numerischen Problemen.
 Der Grund liegt darin, dass die positive Definitheit der Kovarianzmatrix
 nicht mehr gesichert ist.
 Praktisch ist das Verfahren damit nicht anwendbar.
 Um dieses Problem zu umgehen, wurde in 
\begin_inset CommandInset citation
LatexCommand cite
key "han2009improving"

\end_inset

 vorgeschlagen, für alle drei Kovarianzfunktionen denselben Hyperparametersatz
 zu verwenden.
 Verglichen mit einem Ordinary-Kriging welches alle Fidelity Samples beinhaltet,
 besteht der Unterschied dann nur noch in einer eigenen globalen Varianz
 und einem eigenen globalen Erwartungswert für die verschiedenen Fidelities.
 Damit könnte nur noch eine für das gesamte Modell gültige konstante Verschiebun
g zwischen den Gütestufen dargestellt werden.
 Dies stellt jedoch eine erhebliche Vereinfachung des Co-Kriging Modells
 dar und für industrielle Anwendungen nicht ausreichend ist.
\end_layout

\begin_layout Section
Softwaredesign
\end_layout

\begin_layout Subsection
Grundlegendes
\begin_inset CommandInset label
LatexCommand label
name "subsec:Offenes-Softwaredesign"

\end_inset


\end_layout

\begin_layout Standard
Integration von Supporting Vector Machines und GEK, COKriging, Ordinary
 Kriging in einem Code usw.
 
\end_layout

\begin_layout Standard
z.B.
 Kovarianzmatrix statt Korrelationsmatrix verwenden.
 Dadurch gibt es allerdings neue Schwieirigkeiten in der Bestimmung von
 den Sigmas, das günstigste war es diese mitzutrainieren.
\end_layout

\begin_layout Standard
Umgebung usw.
 C++ mit Boost usw.
\end_layout

\begin_layout Standard
In dem im Rahmen dieser Arbeit entstandenen Abschlussarbeiten 
\begin_inset CommandInset citation
LatexCommand cite
key "schmitz2013,kueppers2016,kueppers2016b"

\end_inset


\end_layout

\begin_layout Subsection
Schnittstelle zu AutoOpti
\end_layout

\begin_layout Standard
Interface beschreiben + 
\end_layout

\begin_layout Subsection
Softwaretechnische Umsetzung
\begin_inset CommandInset label
LatexCommand label
name "sec:MinimierungSoftwaretechnische-Umsetzung"

\end_inset


\end_layout

\begin_layout Subsection*
Klasse für die Steuerung des Trainings
\end_layout

\begin_layout Standard
In diesem Abschnitt soll der Ablauf und die dazugehörige Klasse für ein
 Training eines Kriging Modells erklärt werden.
 Das UML Diagramm 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLTrainer"

\end_inset

 zeigt die Klasse Trainer, welche das Training steuern und verwalten soll.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/UMLTrainer.PNG
	scale 34

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:UMLTrainer"

\end_inset

UML Diagramm der Trainer Klasse, welche das Training des Kriging Modells
 steuert
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Methoden und auch Attribute der Trainer Klassen sollen am Ablauf des
 Trainings erläutert werden.
 Ein Training besteht im Wesentlichen aus den folgenden Schritten:
\end_layout

\begin_layout Enumerate
Der erste Schritt besteht aus der Erzeugung eines Trainer Objekts.
 Dem Konstruktor müssen drei Parameter übergeben werden: Der Name der Konfigurat
ionsdatei (configFile), der Name der Datenbankdatei (DataBaseFile) und die
 zu trainierende Funktion.
 Der Parameter objectString gibt an, welcher der Funktionswerte aus der
 Datenbankdatei verwendet werden soll, diese kann zu einem Variablensatz
 mehrere verschiedene Funktionen beinhalten.
 Innerhalb des Konstruktors werden dann einige Schritte ausgeführt, um das
 Kriging Modell zu initialisieren.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Einlesen der Datenbankdatei.
\end_layout

\begin_layout Enumerate
Einlesen der Konfigurationsdatei durch die Methode readConfig(), an dieser
 Stelle werden auch die zu verwendenden Korrelationsfunktionen gesetzt (Attribut
 correlationMap, siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SoftwaretechnKorrelationsfunktionen"

\end_inset

 ).
 Zudem wird ein DensityFunktion Objekt erzeugt und in dem Attribut densityFuncti
on gespeichert, siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Maximum-Likelihood-für"

\end_inset

.
\end_layout

\begin_layout Enumerate
Normalisierung der Stützstellen und der dazugehörigen Funktionswerte (mit
 der Methode normalizeData())
\end_layout

\begin_layout Enumerate
Initialisierung der Hyperparameter, siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Starten der train() Methode des Trainer Objekts.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Erzeugung eines Minimierer Objekts, je nach gewähltem Minimierer Typ.
 Die entsprechende Klassenstruktur wird im nächsten Abschnitt behandelt
\end_layout

\begin_layout Enumerate
Starten des Minimierers
\end_layout

\end_deeper
\begin_layout Enumerate
Nach erfolgreichem Training wird eine XML Datei geschrieben, in der im Wesentlic
hen alle Ergebnisse des Trainings stehen.
 Es werden die gefundenen Hyperparameter, die Korrelationsmatrix, einige
 Vektoren usw.
 gespeichert um bei einer späteren Vorhersage diese Werte nicht mehr berechnen
 zu müssen.
 Diese XML Datei beinhaltet also ein fertiges Kriging Modell.
\end_layout

\begin_layout Subsection*
Klassenstruktur zur Steuerung der Minimierungsverfahren
\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLMinimizer"

\end_inset

 wird das UML Diagramm der Klassenstruktur für die Minimierungsverfahren
 gezeigt.
 Es gibt eine abstrakte Superklasse MinimizerInterface, welche hier als
 Interface zu verstehen ist.
 Diese schreibt die notwendigen Methoden für die Subklassen vor.
 Die Subklassen sollen dann die konkreten Minimierungsverfahren realisieren.
 Die einzige öffentliche Methode callMinimizer ist dazu da, um von außen
 den entsprechenden Minimierer aufzurufen und die Minimierung zu starten.
 In der Methode function muss die zu minimierende Funktion berechnet werden.
 Die Rückgabe des berechneten Funktionswertes wird über eine Referenz des
 Parameters functionValue gemacht, eine Referenz wird aus Performancegründen
 verwendet.
 Der Parameter variables vom Typ vector, soll die entsprechenden Variablen
 beinhalten.
 Zu diesen Variablen wird dann der Funktionswert berechnet.
 Wie die Berechnung vor sich geht und was genau berechnet wird, ist den
 einzelnen Subklassen überlassen, diese müssen sich nur an die Interface
 Spezifikation halten.
 
\end_layout

\begin_layout Standard
Die Methode functionDerivative soll den Gradienten des Funktionswertes abgeleite
t nach den Variablen berechnen.
 Der Gradient wird über die Referenz auf den Parameter derivatives zurückgegeben.
 Zusätzlich soll es möglich sein, Nebenbedingungen für die Minimierung vorzugebe
n.
 Dies wird über die Methode constraintFunction umgesetzt.
 Die Nebenbedingung muss so formuliert werden, dass diese bei einem Wert
 größer oder gleich Null eingehalten wird und unter Null nicht eingehalten
 wird.
 Zudem muss der Gradient der einzelnen Nebenbedingungsfunktionen bereitgestellt
 werden und zwar über die Methode constraintFunctionDerivative.
 
\end_layout

\begin_layout Standard
Um die Konvergenz des Verfahrens festzustellen, wird die Methode convergenceChec
k verwendet.
 Der Methode müssen drei Parameter übergeben werden, der erste Parameter
 ist ein vector mit den Funktionswerten der bisher durchgeführten Iterationen.
 Der zweite Parameter ist ein mehrdimensionaler vector, welcher alle Variablenwe
rte der bisherigen Iterationen beinhaltet und der letzte Parameter der Methode
 ist die Nummer der aktuellen Iteration.
 Das entsprechende Konvergenzkriterium muss dann innerhalb der Funktion
 umgesetzt werden.
 Beispielsweise könnte man das Verfahren als konvergiert ansehen, wenn die
 Funktions- und Parameterwerte sich seit einigen Iterationen nicht mehr
 verändert haben oder die Veränderung unterhalb einer bestimmten Schwelle
 liegt.
\end_layout

\begin_layout Standard
Die Methode saveFunction stellt eine Art von Rettungsfunktion dar.
 Diese soll aufgerufen werden, wenn das Verfahren in irgendeiner Form numerisch
 instabil wird.
 Beispielsweise könnte eine einfache Maßnahme sein, die Funktionswerte zufällig
 zu verändern, in der Hoffnung auf ein anderes (globaleres) Minimum zu treffen.
\end_layout

\begin_layout Standard
Die jeweiligen Subklassen implementieren in diesem Fall noch ein Attribut
 vom Typ DensityFunction, da diese die LikeliHood Funktion minimieren sollen
 und die Klasse DensityFunction alle nötigen Methoden für die Berechnung
 dieser liefert, siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Likelihood"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/UMLMinimizer.PNG
	scale 34

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:UMLMinimizer"

\end_inset

UML Diagramm der Klassenstruktur der Minimierungsalgorithmen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das folgende Listing zeigt die Umsetzung der Methode function in der Subklasse
 MinimizerInterfaceRPROP.
 Die Methode ist in diesem Fall vereinfacht dargstellt, einige Ausgabefunktionen
 wurden aus Platzgründen entfernt.
 Die wichtigen Teile der Methode sind allerdings unverändert.
 Der Methodenkopf entspricht dem aus dem UML Diagramm.
 In Zeile 5 werden die aktuellen Variablen (in diesem Fall die Hyperparameter)
 dem Objekt densityFunction zu Berechnung der Likelihood Funktion übergeben.
 In den Zeilen 7-18 wird dann die eigentliche Likelihood Funktion innerhalb
 eines try-catch Blocks berechnet, um eventuelle Exceptions fangen zu können.
 Wird eine Exception geworfen, so wird eine Fehlermeldung ausgegeben und
 eine -1 als zurückgegeben.
 Zusätzlich kann wie in Zeile 15 die entsprechende Korrelationsmatrix bei
 Auftreten einer Exceptions ausgegeben werden, in diesem Fall wird die Matrix
 in eine Datei geschrieben.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

int MinimizerInterfaceRPROP<T,B>::function(	vector<double> &hyperparameter,
 
\end_layout

\begin_layout Plain Layout

												double &likelihood, 
\end_layout

\begin_layout Plain Layout

												size_t *iteration){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	densityFunction->setAllHyperparameter(hyperparameter);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	try{
\end_layout

\begin_layout Plain Layout

		likelihood = densityFunction->calcDensity();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	catch(InvCholNotIdentity &e){
\end_layout

\begin_layout Plain Layout

		cout <<"RPROP Func (InvCholNotIdentity):"<<endl;
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	catch(ChodecNotPosDef &Exception){
\end_layout

\begin_layout Plain Layout

		densityFunction->getCorrelationMatrixRef().saveAsAscii("CorrMatFailed_sav");
\end_layout

\begin_layout Plain Layout

		cout <<"RPROP Func (ChodecNotPosDef):"<<endl;
\end_layout

\begin_layout Plain Layout

		return -1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ein zusätzliches Problem bei der Implementierung der Minimierungsverfahren
 war, dass diese in einer externen Bibliothek in Form von C Funktionen vorlagen
 und diese Funktionen Funktionspointer als Parameter erwarten.
 Die zu übergebenden Funktionen entsprechen den Funktionen aus der MinimizerInte
rface Klasse, also z.B.
 function oder functionDerivative.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},tabsize=4"
inline false
status open

\begin_layout Plain Layout

	quasiNewton(nrHyperparam,
\end_layout

\begin_layout Plain Layout

				nrConstraints, 
\end_layout

\begin_layout Plain Layout

				variables,
\end_layout

\begin_layout Plain Layout

				function(),
\end_layout

\begin_layout Plain Layout

				functionDerivatives(),
\end_layout

\begin_layout Plain Layout

				constraintFunction(),
\end_layout

\begin_layout Plain Layout

				constrainFunctionDerivative(),
\end_layout

\begin_layout Plain Layout

				convergenceCheck())
\end_layout

\end_inset


\begin_inset listings
lstparams "basicstyle={\scriptsize},tabsize=4"
inline false
status open

\begin_layout Plain Layout

	rprop(  	nrHyperparam,
\end_layout

\begin_layout Plain Layout

				nrConstraints, 
\end_layout

\begin_layout Plain Layout

				variables, 
\end_layout

\begin_layout Plain Layout

				variablesLowerLimit,
\end_layout

\begin_layout Plain Layout

				variablesUpperLimit,
\end_layout

\begin_layout Plain Layout

				function(),
\end_layout

\begin_layout Plain Layout

				functionDerivatives(),
\end_layout

\begin_layout Plain Layout

				constraintFunction(),
\end_layout

\begin_layout Plain Layout

				constrainFunctionDerivative(),
\end_layout

\begin_layout Plain Layout

				convergenceCheck())
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Schwierigkeit ergibt sich in diesem Fall dadurch, dass die Funktionspointer
 in C++ eine Zuordnung zu dem entsprechenden Objekt zu dem die Funktionen
 gehören, benötigen.
 Das folgende Listing soll das Problem verdeutlichen: 
\begin_inset listings
lstparams "basicstyle={\scriptsize},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

MinimizerInterfaceRPROP testObject;
\end_layout

\begin_layout Plain Layout

int (MinimizerInterfaceRPROP::*ptr2)(vector<double> &, double &, size_t
 *) = 
\end_layout

\begin_layout Plain Layout

											&MinimizerInterfaceRPROP::function;
\end_layout

\begin_layout Plain Layout

(testObject.*ptr2)(variables, functionValue, iteration);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Zeile 1 wird ein Test Objekt vom Typ MinimizerInterfaceRPROP erzeugt
 (der Konstruktoraufruf wurde hier absichtlich vereinfacht).
 In den Zeilen 2-3 wird ein Funktionspointer namens ptr2 erzeugt, dieser
 zeigt auf eine Methode der Klasse MinimizerInterfaceRPROP mit den entprechenden
 Parametern der Methode function.
 Zusätzlich erfolgt in diesen Zeilen eine Zuweisung des Pointers der Methode
 durch 
\shape italic

\begin_inset Quotes eld
\end_inset

&MinimizerInterfaceRPROP::function
\shape default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
In Zeile 4 wird ein beispielhafter Aufruf des Funktionspointers auf dem
 Objekt testObject gemacht.
 Dieses Beispiel würde so funktionieren.
 Das eigentliche Problem besteht aber nun darin, dass man in Zeile 2 statt
 der Subklasse MinimizerInterfaceRPROP die abstrakte Klasse MinimizerInterface
 verwenden möchte.
 Da diese Funktionspointer Parameter einer Funktion darstellen, wäre dieses
 Verhalten sehr wichtig, weil so alle Methodenpointer der Subtypen von Minimizer
Interface angenommen werden würden.
 Andernfalls müsste man die Funktion rprop oder quasiNewton für jeden Subtypen
 von MinimizerInterface neu implementieren.
 Leider sind die Möglichkeiten polymorpher Programmierung in C++ stark begrenzt
 und solch ein Konstrukt wird von der Sprache nicht unterstützt.
 
\end_layout

\begin_layout Standard
Um dieses Problem zu umgehen, werden Funktionsobjekte 
\begin_inset CommandInset citation
LatexCommand cite
key "boostfunction"

\end_inset

 der Boost Bibliothek verwendet.
 Mit dieser Bibliothek ist es möglich, die entsprechenden Methoden als Objekt
 an die entsprechenden externen Funktionen (z.B.
 rprop und quasiNewton) zu übergeben.
 Das folgende Listing soll die prinzipielle Funktionsweise von Boost Funktionsob
jekten erklären:
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

class X {
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

 int foo(int); 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

boost::function<int (X*, int)> f;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

X x;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f = &X::foo;
\end_layout

\begin_layout Plain Layout

f(&x, 10);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In diesem Beispiel soll ein Funktionsobjekt der Methode foo der Klasse X
 erzeugt werden.
 Zu diesem Zweck wird ein Funktionsobjekt in Zeile 6 initialisiert, wobei
 innerhalb der eckigen Klammern zuerst der Rückgabewert int und danach die
 Parameter der Funktion (X*, int) übergeben werden.
 Der Parameter X* muss vorhanden sein, da innerhalb C++ der erste Parameter
 einer Methode immer das Objekt selbst ist.
 Im Normalfall wird dies jedoch automatisch umgesetzt und ist daher unsichtbar
 für den Programmierer.
 Die Zuweisung der Methode auf das Funktionsobjekt erfolgt dann in Zeile
 10.
 Der Aufruf des Funktionsobjekts erfolgt nach normaler C++ Syntax, siehe
 Zeile 11.
\end_layout

\begin_layout Standard
Für die Klasse MinimizerInterfaceRPROP würde ein solches Funktionsobjekt
 wie folgt aussehen:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},tabsize=4"
inline false
status open

\begin_layout Plain Layout

boost::function<int (MinimizerInterfaceRPROP*, vector<double> &, double
 &, size_t *)> fPointer;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Problem dass das Funktionsobjekt unabhängig vom Subtyp der Klasse MinimizerI
nterface sein soll, bleibt allerdings bestehen.
 Um dies nun zu umgehen, kann man boost::bind verwenden.
 Mit dieser Funktionalität ist es möglich, Parameter von Funktionen zu verändern.
 
\end_layout

\begin_layout Standard
Das nächste Listing soll dies verdeutlichen, es handelt sich hier um ein
 stark vereinfachtes Beispiel um die grundlegende Funktionalität zu erklären.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

void external_rprop(boost::function<int (vector<double> &, double &, size_t
 *)> fPointer){...}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class MinimizerInterfaceRPROP: public MinimizerInterface{
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

	void callMinimizer(){
\end_layout

\begin_layout Plain Layout

		boost::function<int (vector<double> &, double &, size_t *)> fPointer;
\end_layout

\begin_layout Plain Layout

		fPointer = boost::bind(&MinimizerInterfaceRPROP::function, (*this), _1,
 _2, _3);
\end_layout

\begin_layout Plain Layout

		external_rprop(fPointer);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

private:
\end_layout

\begin_layout Plain Layout

	int function(vector<double> &vars, double &f, size_t *it) {...}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Zeile 1 ist eine Funktion definiert, welche einer externen Bibliotheksfunktio
n entspricht, beispielsweise einem externen RPROP Algorithmus.
 Dieser Algorithmus benötigt nun ein Funktionsobjekt, mit dem er die zu
 minimierende Funktion berechnen kann.
 Wie man sehen kann, benötigt das hier definierte Funktionsobjekt als ersten
 Parameter nicht mehr das aufrufende Objekt selbst.
 
\end_layout

\begin_layout Standard
Analog zum Originalcode wird als nächstes ist die Subklasse MinimizerInterfaceRP
ROP definiert, welche Subklasse der abstrakten Klasse MinimizerInterface
 ist.
 Diese Klasse besitzt nun eine öffentliche Methode namens callMinimizer.
 Diese Methode soll von irgendeinem Clienten ausgeführt werden können, um
 den Minimierungsalgorithmus starten.
 
\end_layout

\begin_layout Standard
Der erste Schritt innerhalb der Methode callMinimizer ist die Erzeugung
 eines boost Funktionsobjekts, auch hier ist der erste Parameter nicht mehr
 das aufrufende Objekt selbst (also MinimizerInterfaceRPROP*).
 In Zeile 7, wird nun ein Funktionsobjekt mit boost bind erzeugt.
 Mit bind ist es Möglich, die Methodenparameter zu verändern.
 Dies wird dazu verwendet das Funktionsobjekt quasi unabhängig von der aufgerufe
nen Klasse zu machen.
 Dem ersten Parameter für bind wird der Funktionspointer übergeben, der
 zweite Parameter ist das Objekt selbst.
 Mit boost bind ist es nun möglich, das Objekt einfach standardmäßig über
 den this Zeiger fest zu binden.
 Dieser taucht im kreierten Funktionsobjekt nicht mehr auf und man hat die
 gewünschte Unabhängigkeit erreicht.
 Die nächsten drei Parameter _1,_2,_3 sind Platzhalter für die später nötigen
 Parameter des Funktionsobjekts (also vector<double> &, double &, size_t
 *).
\end_layout

\begin_layout Standard
In der nächsten Zeile wird das Funktionsobjekt an die externe Bibliotheksfunktio
n übergeben und diese kann die Funktion nun nach belieben verwenden.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Subsection
Algorithmus zur Bildung der Korrelationsmatrix für alle Kriging Verfahren
\end_layout

\begin_layout Plain Layout
Beim Aufstellen der Korrelationsmatrix müssen alle Korrelationen zwischen
 Membern berechnet werden.
 Ein Member wird durch die Klasse Point beschrieben, in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLPoint"

\end_inset

 ist das UML Diagramm der entsprechenden Klasse dargestellt.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../images/UML/point.eps
	lyxscale 40
	scale 17

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:UMLPoint"

\end_inset

UML Diagramm der Klasse Point, welche einen Member/Stützstelle beschreibt
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "PointKlasseAnfang"

\end_inset

Die Klasse verwendet zwei Template Parameter.
 Zum einen den Parameter B, dieser gibt den verwendeten Fließkommazahlentyp
 an und zum anderen gibt es den Parameter T, welcher den verwendeten Matrix
 Typ darstellt.
 Der Matrix Typ muss ein Subtyp der Matrix Klasse aus Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Korrelationsmatrix"

\end_inset

 sein.
 Die Point Klasse besteht aus vier Attributen und zwei öffentlichen Methoden.
 Das Attribut fit beschreibt den Funktionswert des Members.
 PartialDerivatives beinhaltet die vorgegebenen partiellen Ableitungen eines
 Members.
 Der Typ des Attributs ist eine map (Hashtabelle), wobei der Schlüssel die
 Nummer der Variable darstellt, nach der abgeleitet wurde.
 In vars werden die Variablenwerte des Members gespeichert, der Typ des
 Attributs ist eine Matrix.
 Eigentlich wird nur ein Vektor als Typ benötigt, da man aber gerne die
 Matrix Operationen nutzen möchte, wird vars als einspaltige Matrix verwendet,
 was letztlich wieder einem Vektor entspricht.
 Das Attribut type beinhaltet den Typ des Members, dies ist für Variable
 Fidelity Methods ( siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Andere-Kriging-Verfahren"

\end_inset

 ) wichtig.
 In diesem Attribut wird dann über einen Identifier angegeben, ob es sich
 z.B.
 um einen Member handelt, welcher mit hoher Güte berechnet wurde oder niedriger.
 
\end_layout

\begin_layout Plain Layout
Eine Korrelationsfunktion soll zwischen zwei solcher Point Objekte einen
 Korrelationswert bestimmen.
 Daher macht es Sinn, eine gemeinsame abstrakte Superklasse einzuführen,
 der Aufbau ist in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

 dargestellt.
 Da jedes Point Objekt auch die partiellen Ableitungen enthält ist es sinnvoll,
 dass die Korrelationsfunktion alle Korrelationen zwischen zwei Point Objekten
 zurück gibt, also auch die Korrelationen zwischen partiellen Ableitungen
 und Funktionswerten.
 Zu diesem Zweck wird die Korrelationsmatrix durch Zeilen- und Spaltentausch
 umsortiert, um die Korrelationen zwischen zwei Point Objekten direkt als
 Submatrix in die Gesamtmatrix einzufügen:
\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset Formula 
\begin{equation}
\mathbf{R}=\left[\begin{array}{c|cccc}
 & Z\left(\vec{x}_{1}\right) & \frac{\partial Z\left(\vec{x}_{1}\right)}{\partial x_{1}^{1}} & Z\left(\vec{x}_{2}\right) & \frac{\partial Z\left(\vec{x}_{2}\right)}{\partial x_{1}^{1}}\\
\hline Z\left(\vec{x}_{1}\right) & c\left(\vec{x}_{1},\vec{x}_{1}\right) & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{1}\right)}{\partial x_{1}^{1}} & c\left(\vec{x}_{1},\vec{x}_{2}\right) & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{2}^{1}}\\
\frac{\partial Z\left(\vec{x}_{1}\right)}{\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{1}\right)}{\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{1}\right)}{\partial x_{1}^{1}\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{1}^{1}\partial x_{2}^{1}}\\
Z\left(\vec{x}_{2}\right) & c\left(\vec{x}_{2},\vec{x}_{1}\right) & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{1}\right)}{\partial x_{1}^{1}} & c\left(\vec{x}_{2},\vec{x}_{2}\right) & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{2}\right)}{\partial x_{2}^{1}}\\
\frac{\partial Z\left(\vec{x}_{2}\right)}{\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{1}\right)}{\partial x_{2}^{1}} & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{1}\right)}{\partial x_{2}^{1}\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{2}\right)}{\partial x_{2}^{1}} & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{2}\right)}{\partial x_{2}^{1}\partial x_{2}^{1}}
\end{array}\right]\label{eq:FinalCorrMat}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
Durch diese Anordnung stehen alle Korrelationen zwischen zwei bestimmten
 Punkten immer zusammen, dies vereinfacht den Algorithmus zum Aufstellen
 der Matrix erheblich.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/home/andreas/documents/GoogleDrive/Promotion/Diss/images/UML/CorrelationFunction.eps
	lyxscale 70
	width 30cm
	height 14cm
	scaleBeforeRotation

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:UMLCorrelation"

\end_inset

UML Diagramm der abstrakten Klasse CorrelationFunction mit zwei Subklassen,
 diese stellen spezifische Korrelationsfunktionen dar
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Die Methode CreateCorrelationMatrix
\begin_inset CommandInset label
LatexCommand label
name "subsec:Die-Methode-CreateCorrelationMat"

\end_inset


\end_layout

\begin_layout Plain Layout
Das UML Diagramm in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

 zeigt die abstrakte Superklasse CorrelationFunction mit zwei Spezialisierungen
 namens CorrelationFunctionGauss und CorrelationsFunctionSpline.
 Die Spezialisierungen stellen jeweils verschiedene Korrelationsfunktionen
 dar.
 Die Umsetzung der Gauss Korrelationsfunktion wurde im Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SoftwaretechnKorrelationsfunktionen"

\end_inset

 dargestellt, auf die Beschreibung der Spline Funktion wird hier verzichtet.
 Die Methode getAllCorrelation schreibt alle Korrelationswerte zwischen
 den Stützpunkten P1 und P2 in die ebenfalls übergebene Korrelationsmatrix
 corrMat.
 Da die Korrelationswerte zwischen zwei Stützstellen eine Submatrix der
 Korrelationsmatrix darstellen (siehe Formel 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:FinalCorrMat"

\end_inset

), wird der Methode getAllCorrelation die entsprechende Stelle der Submatrix
 in der Korrelationsmatrix über die Indizes i und j mit angegebenen.
 Die beiden Parameter stellen hier die Position der ersten Zeile und Spalte
 der Submatrix in der Korrelationsmatrix dar.
 Es wird also im ersten Schritt die Korrelation zwischen den beiden Punkten
 bestimmt, dann die Korrelationen der partiellen Ableitungen, daraus wird
 dann die entsprechende Submatrix gebildet und diese in die Korrelationsmatrix
 eingefügt.
\end_layout

\begin_layout Plain Layout
Das folgende Programmlisting zeigt die Funktion, welche unter Benutzung
 der abstrakten Klasse CorrelationFunktion, eine Korrelationsmatrix mit
 Werten befüllt.
 Der gezeigte Code ist der Originalcode in C++, auf Pseudocode wird hier
 verzichtet da einige Besonderheiten von C++ eine recht große Rolle in der
 Programmierung spielen.
 Einige Zeilenumbrüche wären in C++ in der Form nicht zulässig, aus Platzgründen
 ließen sich diese allerdings nicht vermeiden.
 
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

template <class T, class B> 
\end_layout

\begin_layout Plain Layout

void createCorrelationMatrix(
\end_layout

\begin_layout Plain Layout

					T &correlationMatrix,
\end_layout

\begin_layout Plain Layout

					vector<Point<T,B> > &points, 
\end_layout

\begin_layout Plain Layout

					map<string,map<string,CorrelationFunction<T,B>*>> correlationMap){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	T tmp(config::numSamplesDerivatives, config::numSamplesDerivatives);
\end_layout

\begin_layout Plain Layout

	correlationMatrix = tmp;
\end_layout

\begin_layout Plain Layout

	#pragma omp parallel for schedule(dynamic) 	
\end_layout

\begin_layout Plain Layout

	for(size_t i=0; i<points.size(); i++){ 		
\end_layout

\begin_layout Plain Layout

		for(size_t j=i; j<points.size(); j++){
\end_layout

\begin_layout Plain Layout

			if(i==j){ 				
\end_layout

\begin_layout Plain Layout

				correlationMap[points[i].getType()][points[j].getType()]->getAllCorrelation(
\end_layout

\begin_layout Plain Layout

						points[i],
\end_layout

\begin_layout Plain Layout

						points[j],
\end_layout

\begin_layout Plain Layout

						correlationMatrix,
\end_layout

\begin_layout Plain Layout

						0.0,
\end_layout

\begin_layout Plain Layout

						config::matrixPositions[i],
\end_layout

\begin_layout Plain Layout

						config::matrixPositions[j], 
\end_layout

\begin_layout Plain Layout

						true ); 								
\end_layout

\begin_layout Plain Layout

				correlationMatrix[config::matrixPositions[i]][config::matrixPositions[j]]
 
\end_layout

\begin_layout Plain Layout

								+= fmath::expd(config::diagonalAddition); 			
\end_layout

\begin_layout Plain Layout

			} 			
\end_layout

\begin_layout Plain Layout

			else{ 				
\end_layout

\begin_layout Plain Layout

				correlationMap[points[i].getType()][points[j].getType()]->getAllCorrelation(
\end_layout

\begin_layout Plain Layout

					points[i],
\end_layout

\begin_layout Plain Layout

					points[j], 
\end_layout

\begin_layout Plain Layout

					correlationMatrix, 
\end_layout

\begin_layout Plain Layout

					0.0,
\end_layout

\begin_layout Plain Layout

					config::matrixPositions[i],
\end_layout

\begin_layout Plain Layout

					config::matrixPositions[j],
\end_layout

\begin_layout Plain Layout

					false); 			
\end_layout

\begin_layout Plain Layout

			} 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	#pragma omp parallel for 
\end_layout

\begin_layout Plain Layout

	for(int i=correlationMatrix.getColumnSize()-1; i>0; i--){ 		
\end_layout

\begin_layout Plain Layout

		for(int j=i-1; j>=0; j--){ 			
\end_layout

\begin_layout Plain Layout

			correlationMatrix[i][j] = correlationMatrix[j][i]; 		
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Die Funktion createCorrelationMatrix hat genau drei Parameter.
 Der erste Parameter ist eine Referenz auf die eigentliche Korrelationsmatrix.
 Um unnötiges Kopieren zu vermeiden, wird eine Referenz verwendet, weil
 die Daten direkt in die Matrix geschrieben werden sollen.
 Da die Matrizen sehr groß werden können (20000x20000 sind keine Seltenheit)
 und während des Trainings sehr häufig gebildet werden müssen, können solche
 Überlegungen erhebliche Unterschiede in der Geschwindigkeit ausmachen.
\end_layout

\begin_layout Plain Layout
Der Parameter Points vom Typ Point (Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLPoint"

\end_inset

) ist ein eindimensionaler Vektor, welcher alle Member/Stützstellen beinhaltet.
 
\end_layout

\begin_layout Plain Layout
CorrelationMap ist eine zweidimensionale Hashtabelle, die beiden Indizes
 sind Integer und beschreiben die Typen (vgl.
 Attribut type aus Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLPoint"

\end_inset

) der entsprechenden Stützstellen.
 Durch diese Hashtabelle ist es möglich, jedem Paar von Stützstellen verschieden
e Korrelationsfunktionen zuzuordnen.
 Dies ist bei der weiteren Entwicklung des Verfahrens von großer Bedeutung,
 insbesondere für Variable Fidelity Models (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Andere-Kriging-Verfahren"

\end_inset

).
 Der Wert der Hashtabelle ist vom Typ CorrelationFunction (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

), dieser kann also durch jeden Subtyp der abstrakten Klasse CorrelationFunction
 überladen werden.
 Eine solche correlationMap könnte z.B.
 folgendermaßen aufgebaut sein:
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typ1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Typ2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CorrelationFunction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
correlationFunctionGauss
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
correlationFunctionSpline
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
correlationFunctionGauss
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
Würde man mit dieser correlationMap z.B.
 folgenden Aufruf machen, so würde man die Methode getAllCorrelation des
 SubTyps CorrelationFunctionGauss (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

) aufrufen.
 
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small},language={C++},tabsize=4"
inline false
status open

\begin_layout Plain Layout

correlationMap[0][0]->getAllCorrelation(...);
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Genau diesen Aufruf findet man in den Zeilen 13 und 25.
 
\end_layout

\begin_layout Plain Layout
In Zeile 7 und 8 wird eine neue Matrix vom Template Typ T allokiert und
 der Parameter correlationMatrix damit überschrieben.
 Der Wert config::numSamplesDerivatives beschreibt hier die Anzahl der Stützstel
len plus die Anzahl der gegebenen partiellen Ableitungen.
 
\end_layout

\begin_layout Plain Layout
In den Zeilen 9 bis 11 wird eine doppelte for Schleife über alle Stützstellen
 gestartet, um die Korrelationen von allen Stützstellen zu allen Stützstellen
 zu berechnen.
 Das 
\begin_inset Quotes eld
\end_inset

#pragma omp parallel for
\begin_inset Quotes erd
\end_inset

 ist eine einfache Schleifenparallelisierung von OpenMP.
 Die Indizes werden automatisch in Bereiche eingeteilt und dann in einzelnen
 Threads abgearbeitet.
 Die Anzahl der maximalen Threads wird direkt zu Anfang über ein Parameterfile
 festgelegt.
 Der zusätzliche Befehl 
\begin_inset Quotes eld
\end_inset

schedule(dynamic)
\begin_inset Quotes erd
\end_inset

 gibt an, wie der OpenMP Scheduler die Arbeit auf die Threads verteilt,
 es gibt prinzipiell drei Varianten:
\end_layout

\begin_layout Itemize

\shape italic
static
\shape default
: Jede Teilschleife besitzt eine feste Anzahl von Durchläufen, diese Durchläufe
 werden dann reihum an die Threads verteilt.
 Dieses Vorgehen ist, bei gleicher Lastverteilung der Teilschleifen optimal.
 Im Normalfall gibt es soviele Teilschleifen wie Anzahl Threads.
\end_layout

\begin_layout Itemize

\shape italic
dynamic
\shape default
: Hier werden die Teilschleifen dynamisch an die Threads verteilt, um das
 zu erreichen, werden die Teilschleifen kleiner gewählt als z.B.
 bei static.
 Dies ist sinnvoll, wenn die Last stark variiert, allerdings ist der Verwaltungs
aufwand für die OpenMP Laufzeitumgebung höher.
\end_layout

\begin_layout Itemize

\shape italic
guided
\shape default
: Bei diesem Fall werden die Teilschleifen während der Laufzeit exponentiell
 von groß zu klein verändert.
 Dies ist ein Spezialfall von 
\shape italic
dynamic 
\shape default
und reduziert den Verwaltungsaufwand.
\end_layout

\begin_layout Plain Layout
Welche der drei Varianten für einen Fall geeignet ist, lässt sich oftmals
 nur durch Testen gut bestimmen.
 Bei der Belegung der Korrelationsmatrix scheint zuerst die Option 
\shape italic
static
\shape default
 sinnvoller zu sein, da der Aufwand für einen Schleifendurchlauf in etwa
 gleich bleibt.
 Allerdings war die Option 
\shape italic
dynamic
\shape default
 in Tests ca.
 10
\begin_inset space ~
\end_inset

% schneller.
 Das könnte durch interne Compiler Optimierungen und die Verwendung des
 If- Else Blocks innerhalb der Schleife zu erklären sein.
 
\end_layout

\begin_layout Plain Layout
Der If- Else Block ist dazu da, um zwischen der Berechnung der Korrelation
 zwischen zwei gleichen Stützpunkten und der Berechnung der Korrelation
 zwischen zwei verschiedenen Punkten zu unterscheiden.
 Dies ist sinnvoll, da sich die Korrelation zwischen zwei gleichen Stützpunkten
 durch Vereinfachungen der mathematischen Formulierung deutlich schneller
 berechnen lässt.
 Eine solche Vereinfachung wird im nächsten Abschnitt genauer beschrieben.
 Zusätzlich kann auf die Diagonalelemente der Matrix, ein Diagonalaufschlag
 addiert werden (Zeile 21-22).
 Dies wird verwendet um die Matrix für die Invertierung numerisch stabiler
 zu machen, in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

 wird der Diagonalaufschlag genauer erläutert.
 
\end_layout

\begin_layout Plain Layout
Innerhalb des If- Else Blocks wird die Methode getAllCorrelation der entsprechen
den Subklasse von CorrelationFunction (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

) aufgerufen.
 Zwei wichtige Parameter dieses Methodenaufrufs sind 
\begin_inset Quotes eld
\end_inset


\shape italic
config::matrixPositions[i]
\shape default

\begin_inset Quotes erd
\end_inset

 und 
\begin_inset Newline newline
\end_inset


\begin_inset Quotes eld
\end_inset


\shape italic
config::matrixPositions[j]
\shape default

\begin_inset Quotes erd
\end_inset

, diese Arrays enthalten eine Tabelle, welche zu einer gegebenen Membernummer
 die entsprechende Position der Member in der Korrelationsmatrix zurückgeben
 soll.
 Da ein Member in der Korrelationsmatrix durch eine kleinere Submatrix beschrieb
en wird, stellt die Position immer die erste Zeile bzw.
 Spalte der Submatrix in der Korrelationsmatrix dar.
 Die Methode getAllCorrelation wird im folgenden Abschnitt genauer erläutert.
\end_layout

\begin_layout Plain Layout
Da die Korrelationsmatrix symmetrisch ist, wird nur die rechte obere Dreiecksmat
rix belegt und in den Zeilen 37-43 wird diese dann auf die linke untere
 kopiert.
 Dadurch wird die Geschwindigkeit des Algorithmus nochmals erhöht.
\end_layout

\begin_layout Subsection*
Die Methode getAllCorrelation
\begin_inset CommandInset label
LatexCommand label
name "subsec:Die-Methode-getAllCorrelation"

\end_inset


\end_layout

\begin_layout Plain Layout
Die Methode getAllCorrelation, welche in Subklassen des Typs CorrelationFunction
 (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

) definiert ist, soll alle Korrelationswerte zwischen zwei Stützstellen
 berechnen.
 Diese werden in die Korrelationsmatrix eingetragen und von der Funktion
 createCorrelationMatrix (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Die-Methode-CreateCorrelationMat"

\end_inset

) aufgerufen.
 Das folgende Listing zeigt den Originalcode in C++.
 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize},language={C++},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

template <class T,class B>
\end_layout

\begin_layout Plain Layout

inline void CorrelationFunctionGauss<T,B>::getAllCorrelation(
\end_layout

\begin_layout Plain Layout

		Point<T,B> &point1,
\end_layout

\begin_layout Plain Layout

 		Point<T,B> &point2,
\end_layout

\begin_layout Plain Layout

 		T &corrMatrix,
\end_layout

\begin_layout Plain Layout

 		B diag,
\end_layout

\begin_layout Plain Layout

 		size_t iMatrix,
\end_layout

\begin_layout Plain Layout

 		size_t jMatrix,
\end_layout

\begin_layout Plain Layout

 		bool equalMember){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	typename map<size_t, B>::iterator derIt;
\end_layout

\begin_layout Plain Layout

	typename map<size_t, B>::iterator derItCol;
\end_layout

\begin_layout Plain Layout

	size_t freevarNr=0, freevarNr2=0;
\end_layout

\begin_layout Plain Layout

	if(equalMember){
\end_layout

\begin_layout Plain Layout

		 corrMatrix[iMatrix][jMatrix]= 1.0;
\end_layout

\begin_layout Plain Layout

		 for(size_t i=0; i<point2.getNumPartDerivatives();i++){
\end_layout

\begin_layout Plain Layout

			freevarNr=i;
\end_layout

\begin_layout Plain Layout

			corrMatrix[iMatrix+i+1][jMatrix+i+1] = fmath::expd(thetas[0][freevarNr]);
\end_layout

\begin_layout Plain Layout

		 }
\end_layout

\begin_layout Plain Layout

	}else{
\end_layout

\begin_layout Plain Layout

		corrMatrix[iMatrix][jMatrix] = calcSimpleGauss(point1, point2);
\end_layout

\begin_layout Plain Layout

		size_t i=0;
\end_layout

\begin_layout Plain Layout

		size_t j=0;
\end_layout

\begin_layout Plain Layout

		for(derItCol=point2.getAllPartDervsRef().begin();
\end_layout

\begin_layout Plain Layout

					derItCol!=point2.getAllPartDervsRef().end();derItCol++){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			freevarNr=derItCol->first;
\end_layout

\begin_layout Plain Layout

			corrMatrix[iMatrix][jMatrix+i+1] = calcGEKPartialDerivative(point1, point2,
\end_layout

\begin_layout Plain Layout

 											 		corrMatrix[iMatrix][jMatrix], freevarNr);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			i++;
\end_layout

\begin_layout Plain Layout

		} 		 	
\end_layout

\begin_layout Plain Layout

		if(corrMatrix.getRowSize()>1){
\end_layout

\begin_layout Plain Layout

			i=0;
\end_layout

\begin_layout Plain Layout

			for(derItCol=point1.getAllPartDervsRef().begin();
\end_layout

\begin_layout Plain Layout

						derItCol!=point1.getAllPartDervsRef().end();derItCol++){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				freevarNr=derItCol->first;
\end_layout

\begin_layout Plain Layout

				corrMatrix[iMatrix+i+1][jMatrix] = -calcGEKPartialDerivative(point1,
 point2,
\end_layout

\begin_layout Plain Layout

														corrMatrix[iMatrix][jMatrix], freevarNr);
\end_layout

\begin_layout Plain Layout

				i++; 
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			i=0; 			 			
\end_layout

\begin_layout Plain Layout

			for(derItCol=point1.getAllPartDervsRef().begin();
\end_layout

\begin_layout Plain Layout

 					derItCol!=point1.getAllPartDervsRef().end(); derItCol++){
\end_layout

\begin_layout Plain Layout

				freevarNr=derItCol->first;
\end_layout

\begin_layout Plain Layout

				j=0;
\end_layout

\begin_layout Plain Layout

				for(derIt=point2.getAllPartDervsRef().begin();
\end_layout

\begin_layout Plain Layout

					derIt!=point2.getAllPartDervsRef().end();derIt++){ 					
\end_layout

\begin_layout Plain Layout

							
\end_layout

\begin_layout Plain Layout

					freevarNr2 = derIt->first;
\end_layout

\begin_layout Plain Layout

					if(i==j) 						 						
\end_layout

\begin_layout Plain Layout

						corrMatrix[iMatrix+i+1][jMatrix+j+1]=calcGEKPartialDerivative2(point1,
\end_layout

\begin_layout Plain Layout

																point2,
\end_layout

\begin_layout Plain Layout

																corrMatrix[iMatrix][jMatrix], 
\end_layout

\begin_layout Plain Layout

																freevarNr);
\end_layout

\begin_layout Plain Layout

					else
\end_layout

\begin_layout Plain Layout

						corrMatrix[iMatrix+i+1][jMatrix+j+1] = calcGEKPartialDerivative2(point1,
\end_layout

\begin_layout Plain Layout

																	point2,
\end_layout

\begin_layout Plain Layout

																	corrMatrix[iMatrix][jMatrix],
\end_layout

\begin_layout Plain Layout

																	freevarNr,   
\end_layout

\begin_layout Plain Layout

																	freevarNr2);
\end_layout

\begin_layout Plain Layout

					j++;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				i++;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Die Methode wird mit sieben Parametern aufgerufen.
 Die ersten beiden Parameter sind Referenzen auf zwei Objekte vom Typ Point.
 Zwischen diesen beiden Stützstellen sollen alle entsprechenden Korrelationswert
e berechnet werden.
 Der nächste Parameter corrMatrix ist eine Referenz auf die Korrelationsmatrix,
 in welche die entsprechenden Korrelationswerte geschrieben werden sollen.
 Wie bereits im vorherigen Abschnitt ist der Parameter diag, ein Diagonalaufschl
ag für die Korrelationsmatrix.
 Dieser wird auf die Hauptdiagonale der Matrix addiert und kann für die
 numerische Stabilität der Invertierung von Bedeutung sein, in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

 wird der Diagonalaufschlag genauer erläutert.
 Die nächsten beiden Parameter iMatrix und jMatrix geben an, bei welchen
 Indizes in der Korrelationsmatrix die neuen Korrelationen eingefügt werden
 sollen.
 
\end_layout

\begin_layout Plain Layout
Der letzte Parameter equalMember ist ein bool'scher Wert und gibt an, ob
 es sich bei den beiden Stützstellen um dieselben Punkte handelt.
 Ist dies der Fall, kann die Berechnung der Korrelationswerte stark vereinfacht
 werden.
 
\end_layout

\begin_layout Plain Layout
In den Zeilen 11-13 werden einige Variablen deklariert.
 Insbesondere zwei Iteratoren, welche zum iterieren über die partiellen
 Ableitungen der beiden Stützstellen dienen.
 Dies ist nötig, da die partiellen Ableitungen als map gespeichert sind
 und eine map in C++ nur über Iteratoren durchlaufen werden kann.
 
\end_layout

\begin_layout Plain Layout
Die Zeilen 14-19 werden ausgeführt, wenn die beiden Stützstellen identisch
 sind.
 Dann vereinfachen sich die Korrelationswerte für eine Gauss Korrelation
 wie sie in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SoftwaretechnKorrelationsfunktionen"

\end_inset

 beschrieben wurde zu:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
c\left(\vec{x}_{1},\vec{x}_{1}\right)=1
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
\frac{\partial c\left(\vec{x}_{1},\vec{x}_{1}\right)}{\partial x_{1}^{p}}=0
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
\frac{\partial c\left(\vec{x}_{1},\vec{x}_{1}\right)}{\partial x_{1}^{p}\partial x_{1}^{j}}=\begin{cases}
0 & p\neq j\\
e^{\theta_{k}} & p=j
\end{cases}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
Übertragen auf das Beispiel aus Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:FinalCorrMat"

\end_inset

, vereinfacht sich die entsprechende Korrelationsmatrix dann zu:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
R=\left[\begin{array}{c|cccc}
 & Z\left(\vec{x}_{1}\right) & \frac{\partial Z\left(\vec{x}_{1}\right)}{\partial x_{1}^{1}} & Z\left(\vec{x}_{2}\right) & \frac{\partial Z\left(\vec{x}_{2}\right)}{\partial x_{1}^{1}}\\
\hline Z\left(\vec{x}_{1}\right) & 1 & 0 & c\left(\vec{x}_{1},\vec{x}_{2}\right) & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{2}^{1}}\\
\frac{\partial Z\left(\vec{x}_{1}\right)}{\partial x_{1}^{1}} & 0 & e^{\theta_{k}} & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{1}^{1}\partial x_{2}^{1}}\\
Z\left(\vec{x}_{2}\right) & c\left(\vec{x}_{2},\vec{x}_{1}\right) & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{1}\right)}{\partial x_{1}^{1}} & 1 & 0\\
\frac{\partial Z\left(\vec{x}_{2}\right)}{\partial x_{1}^{1}} & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{1}\right)}{\partial x_{2}^{1}} & \frac{\partial c\left(\vec{x}_{2},\vec{x}_{1}\right)}{\partial x_{2}^{1}\partial x_{1}^{1}} & 0 & e^{\theta_{k}}
\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
Diese Vereinfachung gilt nur für die Gauss Korrelationsfunktion, für andere
 Korrelationsfunktionen ergeben sich aber ähnliche Vereinfachungen.
\end_layout

\begin_layout Plain Layout
Handelt es sich bei den beiden Stützstellen allerdings nicht um dieselben,
 wird der else-Fall ab Zeile 21 aufgerufen.
 In dieser Zeile wird dann der einfache Korrelationswert der Matrix gebildet
 und in die gesamte Korrelationsmatrix eingetragen.
 Der Code für die private Methode calcSimpleGauss ist identisch mit dem
 Code für die Gauss Korrelationsfunktion aus Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SoftwaretechnKorrelationsfunktionen"

\end_inset

.
 
\end_layout

\begin_layout Plain Layout
In den Zeilen 24-32 wird die Ableitung der Korrelationsfunktion zwischen
 den Stützstellen gebildet, abgeleitet wird nach den Parametern der zweiten
 Stützstelle.
 Die Schleife geht alle freien Variablen durch, an denen es eine partielle
 Ableitung gibt.
 Die eigentlichen Korrelationswerte werden in der privaten Methode calcGEKPartia
lDerivative berechnet und danach in die gesamte Korrelationsmatrix geschrieben,
 in der oberen Beispielmatrix würde das dem Wert 
\begin_inset Formula $\frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{2}^{1}}$
\end_inset

 aus der rechten oberen Ecke entsprechen, da es in dem Beispiel nur eine
 freie Variable gibt.
 Der Methode calcGEKPartialDerivative werden anschließend die beide Punkte
 übergeben.
 Der genaue Funktionsablauf soll hier aus Platzgründen nicht weiter aufgeführt
 werden.
 
\end_layout

\begin_layout Plain Layout
Die Abfrage in Zeile 33 prüft, ob es sich bei der Korrelationsmatrix um
 einen Vektor handelt.
 Ist dies der Fall, sind nachfolgenden Berechnungen nicht notwendig.
\end_layout

\begin_layout Plain Layout
In den Zeilen 35-42 wird wie bereits in den Zeilen 24-32 die Ableitung der
 Korrelationsfunktion berechnet.
 In diesem Fall allerdings für die erste Stützstelle, dies würde in der
 Beispielmatrix dem Wert 
\begin_inset Formula $\frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{1}^{1}}$
\end_inset

 entsprechen.
 
\end_layout

\begin_layout Plain Layout
In den Zeilen 44-66 werden die zweiten Ableitungen der Korrelationsfunktion
 gebildet.
 Dafür muss über die freien Variablen von beiden Stützstellen iteriert werden,
 an denen sich partielle Ableitungen befinden.
 Die Berechnung der Ableitungen findet in der privaten Methode calcGEKpartialDer
ivative2 statt.
 Es gibt zwei verschiedene Implementationen der Methode, einmal eine für
 den Fall, dass die freien Variablen, nach denen abgeleitet wird für beide
 Punkte gleich sind und einmal für den Fall, dass sich diese unterscheiden.
 In der Beispielmatrix würde die Ableitung dem Wert 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $\frac{\partial c\left(\vec{x}_{1},\vec{x}_{2}\right)}{\partial x_{1}^{1}\partial x_{2}^{1}}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang ngerman
 entsprechen.
 Zudem besitzen die beiden Punkte jeweils nur eine freie Variable und auch
 nur jeweils eine partielle Ableitung.
 Daher ist die Nummer der freien Variablen nach denen abgeleitet wird, in
 beiden Fällen eins und damit würde die entsprechende Implementation aus
 den Zeilen 52-56 aufgerufen werden.
 
\end_layout

\begin_layout Plain Layout
Diese Methode stellt einen recht allgemeingültigen Algorithmus auf, welcher
 alle notwendigen Korrelationswerte zwischen zwei Stützstellen in die korrekten
 Positionen einer Korrelationsmatrix einfügt.
 Im UML Diagramm 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLCorrelation"

\end_inset

 wurde zusätzlich zur Methode getAllCorrelation eine Methode getAllCorrelationPa
rtialDer gelistet.
 Diese soll die Ableitungen der Korrelationsfunktion nach den Hyperparametern
 zurückgeben.
 Dies ist für das Training, welches in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:MinimierungsverfahrenTraining"

\end_inset

 erklärt wird, wichtig.
 Die eigentliche Methode ist der Methode getAllCorrelation allerdings relativ
 ähnlich und soll daher nicht näher dargestellt werden.
 
\end_layout

\begin_layout Subsection
Bestimmung der Korrelationen bei Verwendung der Kovarianzmatrix und Co-Kriging
\end_layout

\begin_layout Plain Layout
Für einige Anwendungen ist es notwendig die reale Korrelation zwischen zwei
 beliebigen Samples zu kennen.
 Im Co-Kriging hat man natürlich das Problem, dass diese erst einmal unbekannt
 sind, da mit der Kovarianzmatrix 
\end_layout

\begin_layout Subsection
Bestimmung der Hyperparameter durch die Maximum Likelihood Methode
\begin_inset CommandInset label
LatexCommand label
name "chap:Likelihood-1"

\end_inset


\end_layout

\begin_layout Plain Layout
Wie in den vorherigen Kapiteln gezeigt wurde, hängen die einzelnen Korrelationsw
erte der Korrelationsmatrix maßgeblich von den verwendeten Hyperparametern
 ab und damit die Güte des Kriging Modells.
 Ziel eines Kriging Trainings ist es daher, die optimalen Hyperparameter
 zu finden.
 Um dies zu erreichen, wird die Maximum Likelihood Methode verwendet.
 
\end_layout

\begin_layout Plain Layout
Im ersten Teil des Kapitels soll die Maximum Likelihood Methode anhand eines
 simplen Beispiels erklärt werden.
 Im Anschluss daran wird die Umsetzung dieser Methode für das hier verwendete
 Kriging Modell gezeigt.
 
\end_layout

\begin_layout Plain Layout
Der letzte Abschnitt behandelt dann die softwaretechnische Umsetzung dieser
 Methode.
\end_layout

\begin_layout Subsection
Likelihood
\end_layout

\begin_layout Plain Layout
Um den Likelihood Term und seine partiellen Ableitungen zu bilden, wird
 eine eigene Klasse vorgesehen.
 Da mehrere Likelihood Funktionen denkbar wären, wird eine abstrakte Klasse
 namens DensityFunction eingeführt.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLDensity"

\end_inset

 zeigt die Umsetzung der Klasse als UML Diagramm, Getter und Setter Methoden
 wurden hier aus Platzgründen ausgelassen.
 Bisher ist nur die Likelihood Funktion umgesetzt (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Maximum-Likelihood-für"

\end_inset

).
 Der Likelihood Term (Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:VereinfachterLikelihoodTerm"

\end_inset

) wird in der Methode calcDensity() berechnet und die entsprechende Ableitung
 (Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:AbleitungLikelihood"

\end_inset

) in calcDensityDerivative().
 Denkbar wären allerdings auch andere Likelihood Funktionen, welche auf
 anderen Verteilungen basieren.
 
\end_layout

\begin_layout Plain Layout
Ziel der Klassenstruktur ist es, die beiden Gleichungen 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:VereinfachterLikelihoodTerm"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:AbleitungLikelihood"

\end_inset

 so effizient wie möglich zu lösen.
 Die dort verwendeten Matrizen sind in der Regel sehr groß und voll besetzt,
 was eine effiziente Berechnung sehr wichtig macht.
 Allerdings sind die Matrizen symmetrisch und positiv definit, was wiederum
 einige Optimierungen zulässt.
 Zur Vereinfachung werden einige Terme der Gleichungen zusammengefasst:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align}
\vec{R}_{f} & =\mathbf{R}^{-1}\overrightarrow{F}\label{eq:Rf}
\end{align}

\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset Formula 
\begin{align}
f_{rf} & =\vec{F}^{T}\vec{R}_{f}\label{eq:frf}
\end{align}

\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset Formula 
\begin{align}
\overrightarrow{e} & =(\vec{y}_{s}-\beta*\overrightarrow{F})\label{eq:e}
\end{align}

\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset Formula 
\begin{equation}
\overrightarrow{d}=\mathbf{R}^{-1}\overrightarrow{e}\label{eq:dvec}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
Die Terme werden in diese Form auch in der entsprechenden Klasse (ReducedNormalD
istribution) einmal berechnet und dann gespeichert.
 Da diese sehr häufig wiederverwendet werden, muss man diese Termen nur
 einmal berechnen und eine Änderung ist nur notwendig, wenn die Hyperparameter
 verändert wurden.
 Über die Attribute corrMatUpdate und vecUpdate wird festgelegt, ob die
 Matrizen und Vektoren neu berechnet werden müssen oder nicht.
 Sie werden nur dann neu berechnet, wenn die Hyperparameter verändert wurden.
 Da die Hyperparameter nur über Getter und Setter Methoden zugänglich sind,
 kann man bei jedem Setter Zugriff auf die Hyperparameter die Attribute
 corrMatUpdate und vecUpdate auf true setzen.
 
\end_layout

\begin_layout Plain Layout
Viele der Attributnamen entsprechen den hier verwendeten Bezeichnungen für
 die Vektoren/Matrizen, z.B.
 der Vektor 
\begin_inset Formula $\vec{R}_{f}$
\end_inset

 entspricht dem Attribut rf.
 Das Attribut logDeterminantR entspricht dem Logarithmus der Determinante
 der Korrelationsmatrix 
\begin_inset Formula $\log\left(\det(\mathbf{R})\right)$
\end_inset

.
 Aufgrund dieser Ähnlichkeit werden daher nicht alle einzeln aufgeführt.
 
\end_layout

\begin_layout Plain Layout
Wie bereits in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:MatrixKlasse"

\end_inset

 beschrieben, lässt sich die Determinante durch eine Cholesky Zerlegung
 sehr effizient berechnen.
 Insbesondere da die Zerlegung ebenfalls für die Invertierung der Matrix
 sinnvoll ist.
 Die Korrelationsmatrix wird in der Methode createAndInvertCorrelmat aufgestellt
, zerlegt und dann invertiert.
 Die zerlegte Matrix wird in decomposedMatrix gespeichert, die invertierte
 Matrix in inverseCorrMatrix.
 Die benötigten Vektoren werden in der Methode calcVectors() berechnet und
 in den Attributen der Klasse gespeichert.
 Die Methoden predict() und predictVariance() berechnen dann unter Vorgabe
 eines Ortsvektors eine Schätzung der gesuchten Funktion 
\begin_inset Formula $y^{*}\left(\vec{x}_{0}\right)$
\end_inset

 (siehe Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:GewichtetSumme"

\end_inset

) und der Varianz (Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KrigingVarianzSchätzung"

\end_inset

).
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
Mittwoch
\begin_inset Graphics
	filename ../images/UMLDensityFunction.PNG
	lyxscale 50
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:UMLDensity"

\end_inset

UML Diagramm der abstrakten Superklasse DensityFunction und der Subklasse
 ReducedNormalDistribution
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Schritte für die Berechnung eines Likelihood Terms:
\end_layout

\begin_layout Plain Layout
In diesem Abschnitt soll die Methode zur Berechnung des Likelihood Terms
 (calcDensity()) nochmals genauer erklärt werden.
 Das folgende Listing zeigt die Methode im Originalcode:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize},numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

template <class T, class B> 
\end_layout

\begin_layout Plain Layout

B ReducedNormalDistribution<T,B>::calcDensity(){
\end_layout

\begin_layout Plain Layout

	try{ 		
\end_layout

\begin_layout Plain Layout

		if(this->corrMatUpdate){
\end_layout

\begin_layout Plain Layout

			this->createAndInvertCorrelMat(); 			
\end_layout

\begin_layout Plain Layout

			this->corrMatUpdate = false; 		
\end_layout

\begin_layout Plain Layout

		} 		
\end_layout

\begin_layout Plain Layout

		if(this->vecUpdate){
\end_layout

\begin_layout Plain Layout

			this->calcVectors();
\end_layout

\begin_layout Plain Layout

			this->vecUpdate = false;
\end_layout

\begin_layout Plain Layout

		} 	
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

	catch(ChodecNotPosDef& e){
\end_layout

\begin_layout Plain Layout

		cout <<"calcDensity() MatrixExceptions:"<<e.what()<<endl;
\end_layout

\begin_layout Plain Layout

		config::diagonalAddition = log(2.0*exp(config::diagonalAddition)); 		
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		this->getCorrelationMatrixRef().saveAsAscii("corrMatFailed"); 		
\end_layout

\begin_layout Plain Layout

		this->getInverseCorrelationMatrixRef().saveAsAscii("corrMatInverseFailed");
 		
\end_layout

\begin_layout Plain Layout

		return  (config::numSamples*1000.0); 	
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

	catch(...){ 		
\end_layout

\begin_layout Plain Layout

		cout <<"calcDensity() Exception"<<endl; 		
\end_layout

\begin_layout Plain Layout

		cout <<"--------------------------------"<<endl;
\end_layout

\begin_layout Plain Layout

		return  (config::numSamples*1000.0); 	
\end_layout

\begin_layout Plain Layout

	}  		
\end_layout

\begin_layout Plain Layout

	return 0.5*(log(sSqr)*config::numSamples + logDeterminantR + config::numSamples
 );
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
In Zeile 4 wird zuerst überprüft, ob die Korrelationsmatrix neu aufgestellt
 werden muss oder nicht.
 Dies geschieht, wie bereits beschrieben, mit dem Attribut corrMatUpdate-
 Ist dieses true, dann wird die Korrelationsmatrix wie in Zeile 5 über die
 Methode createAndInvertCorrMat() erzeugt, eine Cholesky Zerlegung durchgeführt
 und dann invertiert.
 Nach erfolgreichem Aufruf der Methode wird das Attribut corrMatUpdate wieder
 auf false gesetzt.
 Ansonsten werden die Matrizen im Puffer verwendet, also correlationMatrix,
 decomposedMatrix und inverseCorrMat.
 
\end_layout

\begin_layout Plain Layout
Auf dieselbe Weise wird mit den Vektoren (Gleichungen 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Rf"

\end_inset

-
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:dvec"

\end_inset

) in den Zeilen 8-10 verfahren.
 Diese werden durch die Methode calcVectors erzeugt und dann in den Attributen
 der Klasse gespeichert.
 Durch die verwendete Matrix Klasse ist die Berechnung der einzelnen Vektoren/Ma
trizen sehr simpel.
 Das folgende Listing zeigt dies exemplarisch an der Methode zur Erzeugung
 von Vektor 
\begin_inset Formula $\vec{d}$
\end_inset

.
 
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\scriptsize},tabsize=4"
inline false
status open

\begin_layout Plain Layout

template <class T, class B>
\end_layout

\begin_layout Plain Layout

void ReducedNormalDistribution<T,B>::calcDVec(){
\end_layout

\begin_layout Plain Layout

	dVec = inverseCorrelationMatrix.matrixMultiplicationTranspose(eVec); 	
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
Die Methode ist Mitglied der Klasse ReducedNormalDistribution (siehe Abbildung
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:UMLDensity"

\end_inset

) und wird durch die Methode calcVectors() aufgerufen.
 Das Attribut inverseCorrelationMatrix ist vom Typ Matrix und beinhaltet
 die inverse Korrelationsmatrix.
 Diese wird mit dem transponierten Vektor 
\lang english

\begin_inset Formula $\overrightarrow{e}=(\vec{y}_{s}-\beta*\overrightarrow{F})$
\end_inset


\lang ngerman
 multipliziert, die Transposition wird innerhalb der Multiplikation vorgenommen.
 Die anderen Methoden zur Berechnung der Dichtefunktionswerte usw.
 beinhalten prinzipiell nur andere Matrix Operationen und werden daher nicht
 alle aufgeführt.
\end_layout

\begin_layout Plain Layout
Die Methode InitAllThetas() der Klasse DensityFunction und deren Subklassen
 soll alle Hyperparameter mit möglichst sinnvollen Werten initialisieren.
 Die verschiedenen Intialisierungsmöglichkeiten und deren Umsetzung werden
 in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

 noch genauer erläutert.
\end_layout

\begin_layout Plain Layout
Da die Cholesky Zerlegung nur für positiv definite symmetrische Matrizen
 funktioniert, kann es bei der Zerlegung zu einer Exception vom Typ ChodecNotPos
Def kommen, dies wird in Zeile 13 abgefangen.
 Ist diese Exception aufgetreten, wird der Diagonalaufschlag (siehe Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Initialisierung-der-Hyperparamet"

\end_inset

) erhöht und ein sehr hoher Likelihood Wert zurückgegeben (Zeile 19), damit
 dieser in der Minimierung nicht mehr berücksichtigt wird.
 
\end_layout

\begin_layout Plain Layout
Zusätzlich wird innerhalb der Matrix Klasse nach erfolgreicher Invertierung
 eine kurze Überprüfung der invertierten Matrix gemacht.
 Dies wird durch folgende Gleichung erreicht:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
\textrm{Spur}\left(RR^{-1}\right) & =n
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
Das Produkt der Inversen und der Korrelationsmatrix, ergibt die Einheitsmatrix.
 Da die Einheitsmatrix n Diagonalelemente besitzt, welche alle den Wert
 1.0 haben, muss die Spur der multiplizierten Matrizen n ergeben.
 Gibt es numerische Ungenauigkeiten innerhalb der Invertierung, wird dieser
 Wert wahrscheinlich von n abweichen.
 Dies wird überprüft und bei Überschreitung eines Grenzwertes wird ebenfalls
 eine Exception geworfen.
 Diese wird mit allen anderen unbekannten Exceptions in Zeile 21 gefangen
 und als Reaktion ein sehr hoher Likelihood Wert zurückgegeben.
 
\end_layout

\begin_layout Plain Layout
Nachdem alle Vektoren und Werte berechnet sind, wird in Zeile 26 die eigentliche
 Likelihood Funktion berechnet (siehe Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Likelihood Funktion"

\end_inset

) und zurückgegeben.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Numerische Effizienz steigern
\end_layout

\begin_layout Subsection
Verteiltes Rechnen 
\begin_inset CommandInset label
LatexCommand label
name "chap:Verteiltes-Rechnen-1"

\end_inset


\end_layout

\begin_layout Standard
Kein MPI, Cluster unklar wie es weiter geht (Xeon Phi oder Nvidia ....) daher
 extern auf NVIDIA, bisher die besten Bibliotheken und Dokumentation) Rechner
 lokal sollen mitgenutzt werden können Verschiedene Architekturen sollen
 gekoppelt werden können (GPU/CPU etc.) - Notwendigkeit von GPUs Prozessweite
 asynchrone Parallelisierung
\end_layout

\begin_layout Standard
ZeroMQ: CUDA und ZeroMQ gekoppel:
\begin_inset CommandInset citation
LatexCommand cite
key "Cook2012"

\end_inset

, CERN Paper mit ZeroMQ Empfehlung:
\begin_inset CommandInset citation
LatexCommand cite
key "Dworak2011"

\end_inset


\end_layout

\begin_layout Subsection
Effiziente Berechnung der Korrelationsfunktion
\begin_inset CommandInset label
LatexCommand label
name "sec:SoftwaretechnKorrelationsfunktionen"

\end_inset


\end_layout

\begin_layout Enumerate
Korrelationsfunktion wird extrem oft aufgereufen, jeder gesparte Befehl
 wirkt sich stark aus
\end_layout

\begin_layout Enumerate
Thetas im Vorraus berechnen
\end_layout

\begin_layout Enumerate
Corr Buffer verwenden, um Ableitungen schneller berechnen zu können
\end_layout

\begin_layout Enumerate
Exponentialfunktion durch schnellere ersetzen
\end_layout

\begin_layout Enumerate
SSE verwenden
\end_layout

\begin_layout Standard
Wie bereits in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Kovarianzmodelle"

\end_inset

 beschrieben, sind für die Aufstellung der Kovarianzmatrix verschiedene
 Kovarianzfunktionsmodelle notwendig.
 Da diese für eine große Anzahl an Samples sehr häufig berechnet werden
 müssen, sollte deswegen ein besonderes Augenmerk auf die Effizienz dieser
 Berechnung gelegt werden.
\end_layout

\begin_layout Standard
\noindent
Die programmiertechnische Umsetzung ist sehr simpel und sieht wie folgt
 aus:
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset listings
lstparams "basicstyle={\scriptsize}"
inline false
status open

\begin_layout Plain Layout

for(size_t i=0; i<point1.getNumVars() ; i++){
\end_layout

\begin_layout Plain Layout

    correl += fmath::exp(thetas[i]) * sqr(point1.getVarsRef(i) - point2.getVarsRef
(i)); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

correl=fmath::exp(-0.5*correl);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Da diese Funktion während eines Trainings sehr häufig aufgerufen wird, macht
 es Sinn, diese zu beschleunigen.
 Um dies zu erreichen, wurden SSE (Streaming SIMD Extensions) CPU Befehle
 verwendet.
 Die Lesbarkeit des Codes leidet zwar recht stark darunter, da sich diese
 Methode zukünftig aber kaum noch ändern wird, ist dies vertretbar.
\end_layout

\begin_layout Subsubsection*
Streaming SIMD Extensions (SSE)
\begin_inset CommandInset label
LatexCommand label
name "subsec:Streaming-SIMD-Extensions"

\end_inset


\end_layout

\begin_layout Standard
\noindent
Die Streaming SIMD Extensions (SSE) sind eine von Intel entwickelte Befehlssatze
rweiterung der x86-Architektur.
 Mit Einführung des Pentium-III-(Katmai)-Prozessors wurde diese 1999 vorgestellt.
 Aufgabe der SSE Befehle ist es Programme durch Parallelisierung auf Instruktion
slevel zu beschleunigen, auch SIMD (Single Instruction Multiple Data) genannt.
 Die SSE-Befehlssatzerweiterung umfasst ursprünglich 70 Instruktionen und
 8 neue Register, genannt XMM0 bis XMM7.
 Ursprünglich wurden die 128
\begin_inset space ~
\end_inset

Bit breiten Register allerdings nicht in einem Schritt verarbeitet.
 Bei heutigen CPUs (z.B.
 Intel Core CPUs) werden die Register in einem Schritt verarbeitet, zudem
 wurde die Anzahl der Register von 8 auf 16 erhöht.
 
\end_layout

\begin_layout Standard
Es gibt zahlreiche Umsetzungen der SSE Befehle.
 Diese reichen von SSE bis SSE5, wobei ab SSE3 AMD und Intel jeweils eigene
 Implementationen der SSE Architektur vornahmen.
 Der Nachfolger von SSE heißt AVX (Advanced Vector Extensions) und verbreitert
 die Register auf 16x
\begin_inset space ~
\end_inset

256
\begin_inset space ~
\end_inset

Bit.
 
\end_layout

\begin_layout Standard
Innerhalb dieser Arbeit wurden nur SSE Befehle verwendet, da diese praktisch
 von allen aktuellen CPUs und auch Compilern unterstützt werden.
 Für die Verwendung von AVX sind relativ neue Kompiler und CPUs notwendig,
 dies kann bei einigen Kunden zu Problemen führen.
 Durch die 128
\begin_inset space ~
\end_inset

Bit Register können nun in einem Rechenschritt vier float (32
\begin_inset space ~
\end_inset

Bit) oder zwei double (64
\begin_inset space ~
\end_inset

Bit) Werte gleichzeitig verarbeitet werden.
 Um diese Funktionen zu nutzen, müssen im C++-Code spezielle SSE Befehle
 verwendet werden 
\begin_inset CommandInset citation
LatexCommand citep
key "AGN,INTEL"

\end_inset

.
 Das folgende Listing zeigt die Umsetzung der Gauss Korrelationsfunktion
 mit SSE Befehlen, wobei die Parallelisierung hier über die Hyperparameter
 gemacht wird.
 Diese Methode wird zur Berechnung der Einträge der Kovarianzmatrix verwendet
 und wird dementspchrend oft aufgerufen.
 Aus diesem Grund ist es sinnvoll diese Methode zu Beschleunigen.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language={C++},numbers=left,basicstyle={\scriptsize},tabsize=4"
inline false
status open

\begin_layout Plain Layout

__m128d correlSSE=_mm_setzero_pd();
\end_layout

\begin_layout Plain Layout

__m128d thetasExpSSE, point1SSE, point2SSE, pointDiffSSE;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

array thetasExpArray;
\end_layout

\begin_layout Plain Layout

array point1Array;
\end_layout

\begin_layout Plain Layout

array point2Array;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for(i=0; i<point1.getNumVars()-1 ; i+=2){
\end_layout

\begin_layout Plain Layout

		thetasExpSSE =_mm_load_pd(&(thetasExpArray[i]));
\end_layout

\begin_layout Plain Layout

		point1SSE =_mm_load_pd(&(point1Array[i]));
\end_layout

\begin_layout Plain Layout

		point2SSE =_mm_load_pd(&(point2Array[i]));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		pointDiffSSE = _mm_sub_pd(point1SSE,point2SSE);
\end_layout

\begin_layout Plain Layout

		pointDiffSSE = _mm_mul_pd(pointDiffSSE,pointDiffSSE);
\end_layout

\begin_layout Plain Layout

		pointDiffSSE = _mm_mul_pd( thetasExpSSE, pointDiffSSE  );
\end_layout

\begin_layout Plain Layout

		correlSSE = _mm_add_pd( correlSSE,  pointDiffSSE );
\end_layout

\begin_layout Plain Layout

} 	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

correlSSE = _mm_hadd_pd(correlSSE,correlSSE); 
\end_layout

\begin_layout Plain Layout

_mm_store_sd(&correl,correlSSE);
\end_layout

\begin_layout Plain Layout

for(; i<point1.getNumVars() ; i++) 	{
\end_layout

\begin_layout Plain Layout

		correl += thetasExp[0][i] * (point1.getVar(i) - point2.getVar(i))*(point1.getVar(
i) - point2.getVar(i));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

correl=fmath::expd(-0.5*corre);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In den Zeilen 1-2 werden verschiedene Variablen definiert vom Typ 
\begin_inset Quotes eld
\end_inset

__m128d
\begin_inset Quotes erd
\end_inset

, dieser Typ stellt ein 128 Bit großes SSE Datentypen dar und kann zwei
 64
\begin_inset space ~
\end_inset

Bit double Werte aufnehmen.
 Zudem wird die Variable correlSSE mithilfe der Funktion_mm_setzero_pd()
 auf 0 gesetzt.
 Die Zeilen 4-6 stellen Arrays dar, welche für die Berechnung der Korrelationsfu
nktion benötigt werden.
 Das Array thetasExpArray beinhaltet die berechneten Hyperparameter 
\begin_inset Formula $e^{\theta_{l}}$
\end_inset

.
 Da diese Werte für alle Einträge in der Kovarianzmatrix identisch sollten
 sie daher vor dem Belegen der Kovarianzmatrix berechnet werden.
 Danach werden die beiden Arrays initialisiert, welche die Ortsvariablen
 
\begin_inset Formula $\vec{x}_{1},\vec{x}_{2}\in\mathbb{R^{\mathrm{k}}}$
\end_inset

 beinhalten.
 Die darauffolgende for-Schleife iteriert über die Anzahl an freien Variablen.
 Der Zähler wird hier immer um den Wert 2 erhöht, da mit den SSE Routinen
 2 double Werte gleichzeitig berechnet werden können.
 In den Zeilen 9-11 werden 128Bit aus den Arrays an der Stelle i in die
 SSE Register übertragen.
 Aus diesem Grund muss der Speicher zwingend 128Bit Speicherausrichtung
 besitzen.
 
\end_layout

\begin_layout Paragraph
Einschub: Speicherausrichtung
\begin_inset CommandInset label
LatexCommand label
name "par:Einschub-Speicherausrichtung"

\end_inset


\end_layout

\begin_layout Standard
In aktuellen C++ Compilern wird eine Speicherausrichtung von 128Bit im Normalfal
l gewährleistet.
 Die folgende Tabelle soll die Speicherausrichtung und die damit entstehende
 Problematik beim Programmieren verdeutlichen:
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64Bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64Bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64Bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64Bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64Bit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64Bit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
underbrace{128Bit aligned}$
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:128Bit-Speicherausrichtung"

\end_inset

128Bit Speicherausrichtung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die erste Zeile der Tabelle beschreibt den Index eines normalen Arrays mit
 6 Einträgen und jeder Eintrag hat die Größe eines 64Bit (z.B.
 double) Werts.
 Der Compiler garantiert in diesem Fall einen zusammenhängenden Speicher
 von 128Bit, dargstellt durch die dritte Zeile.
 
\end_layout

\begin_layout Standard
In Zeile 5 wird die Variable correlSSE mit der Funktion auf Null gesetzt.
 Da in einem Schritt immer zwei Befehle gleichzeitig ausgeführt werden,
 muss die Anzahl durch zwei teilbar sein.
 Ist dies nicht der Fall, muss der Rest mit normalen Befehlen durchgeführt
 werden.
 Zeile 7 setzt die Anzahl der Schleifendurchläufe auf die Anzahl der freien
 Variablen geteilt durch zwei.
 Ist die Anzahl der freien Variablen ungerade, wird eins subtrahiert und
 dann durch zwei geteilt.
 Die Zeilen 8-16 stellen die Summation aus der Gauss Formel dar.
 Zuerst wird in den Zeilen 9-10 zwei Werte der Stützstellen in die SSE Variablen
 geladen.
 Dies geschieht mit der Funktion _mm_loadu_pd().
 Als Parameter erwartet die Funktion eine Speicheradresse und transferiert
 dann 128
\begin_inset space ~
\end_inset

Bit ab dieser Adresse in die entsprechende SSE Variable.
 In den Zeilen 11-12 wird die Exponentialfunktion der Hyperparameter berechnet.
 Dies geschieht auf konventionelle Weise, da es keinen SSE Befehl für die
 Exponentialfunktion gibt.
 Die beiden berechneten Werte werden dann in Zeile 13 ebenfalls in eine
 SSE Variable geladen.
 Die Differenz der Stützstellenkomponenten wird anschließend in Zeile 14
 vorgenommen.
 Hier werden wie bereits erwähnt, direkt zwei Differenzen gleichzeitig berechnet.
 In Zeile 15 wird dann die Differenz quadriert, mit den Hyperparametern
 multipliziert und aufsummiert, alles mit SSE Befehlen.
 
\end_layout

\begin_layout Standard
Ist der Schleifendurchlauf beendet, wird in Zeile 17 das Ergebnis in eine
 normale Variable zurück transferiert und in den restlichen Zeilen wird
 (falls die Anzahl der freien Variablen nicht durch zwei teilbar war) das
 letzte Element mit konventionellen Methoden berechnet.
 Die gemessenen Geschwindigkeitsvorteile lagen bei ca.
 20
\begin_inset space ~
\end_inset

%
\begin_inset space ~
\end_inset

-
\begin_inset space ~
\end_inset

30
\begin_inset space ~
\end_inset

%.
 
\end_layout

\begin_layout Subsection
Filtern von unwichtigen Samples
\end_layout

\begin_layout Standard
Paar finden über Max Korrelation
\end_layout

\begin_layout Standard
Dann wird es etwas schwierig, da die maximale Korrelations ja minimal werden
 soll.
 
\end_layout

\begin_layout Standard
Als StartOption für das Kriging
\end_layout

\begin_layout Standard
Kriging schreibt neue dataBasePost raus
\end_layout

\begin_layout Standard
Nur mit UltraRestart !!!!
\end_layout

\begin_layout Standard
Grundlegend soll die maximale Korrelation minimal werden! 
\end_layout

\begin_layout Standard
ZDT3, siehe Gl.
\end_layout

\begin_layout Standard
Links sind gleichverteilt 500 Samples + 500 in der Mitte Normalverteilt
 mit einer Standardabweichung von 10% der Raumgröße (1x1)
\end_layout

\begin_layout Standard
Rechts sind die 100 gefilterte Samples, von der ursprünglichen Verteilung
 in der Mitte ist nichts mehr zu sehen.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

	// How many Samples and PartDers should be deleted
\end_layout

\begin_layout Plain Layout

	if(sampleSize+partDerSize > cfg.maxMatrixSize){
\end_layout

\begin_layout Plain Layout

		if(sampleSize<=cfg.maxMatrixSize){
\end_layout

\begin_layout Plain Layout

			killPartDer = sampleSize+partDerSize - cfg.maxMatrixSize;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else{
\end_layout

\begin_layout Plain Layout

			killPartDer = partDerSize;
\end_layout

\begin_layout Plain Layout

			killSamples = (sampleSize-cfg.maxMatrixSize);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	BOOST_LOG_TRIVIAL(debug) <<"reducePointsAndCreateMatPositions(): NumSamples:"<<
sampleSize<<" NumPartDer:"<<partDerSize;
\end_layout

\begin_layout Plain Layout

	BOOST_LOG_TRIVIAL(debug) <<"reducePointsAndCreateMatPositions(): MaxMatrixSize:
 "<<cfg.maxMatrixSize<<" NumberSamples+Der="<<sampleSize+partDerSize<<" killPartD
er:"<<killPartDer<<" killSamples:"<<killSamples;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	size_t killedPartDer = 0;
\end_layout

\begin_layout Plain Layout

	//Reduce PartDers
\end_layout

\begin_layout Plain Layout

	while(killedPartDer < killPartDer){
\end_layout

\begin_layout Plain Layout

		int randPoint = rand() % points.size();
\end_layout

\begin_layout Plain Layout

		int randPartDer = rand() % cfg.numFreeVars;
\end_layout

\begin_layout Plain Layout

		if(points[randPoint].getAllPartDervsRef().count(randPartDer) >0){
\end_layout

\begin_layout Plain Layout

			points[randPoint].deletePartialDerivative(randPartDer);
\end_layout

\begin_layout Plain Layout

			killedPartDer++;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if(cfg.initType != ultrarestart or init==true){
\end_layout

\begin_layout Plain Layout

		//Reduce Samples
\end_layout

\begin_layout Plain Layout

		vector<int> deleteIndices = global::createUniqueRandomIntegers(0, points.size()
, killSamples);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	else{
\end_layout

\begin_layout Plain Layout

		typedef map< B, pair<int,int> > m;
\end_layout

\begin_layout Plain Layout

		m corrs;
\end_layout

\begin_layout Plain Layout

		typename m::reverse_iterator it;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		BOOST_LOG_TRIVIAL(debug) <<"reducePointsAndCreateMatPositions(): UltraRestart
 filter nearest Samples";
\end_layout

\begin_layout Plain Layout

		//#pragma omp parallel for schedule(dynamic)
\end_layout

\begin_layout Plain Layout

		for(size_t i=0; i<points.size(); i++){
\end_layout

\begin_layout Plain Layout

			for(size_t j=i+1; j<points.size(); j++){
\end_layout

\begin_layout Plain Layout

				B corr = correlationMap(points[i].getType(),points[j].getType())->calcSimpleCo
rrelation(points[j],points[i]);
\end_layout

\begin_layout Plain Layout

				corrs[corr] =pair<int,int>(i,j);
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		for(it = corrs.rbegin(); it!=corrs.rend() and deleteIndices.size()<killSamples;
 it++) {
\end_layout

\begin_layout Plain Layout

			bool firstInside =  std::find(deleteIndices.begin(), deleteIndices.end(),
 it->second.first)==deleteIndices.end() ?  false:true;
\end_layout

\begin_layout Plain Layout

			bool secondInside =  std::find(deleteIndices.begin(), deleteIndices.end(),
 it->second.second)==deleteIndices.end() ?  false:true;
\end_layout

\begin_layout Plain Layout

			// Keiner drin -> Random
\end_layout

\begin_layout Plain Layout

			if(!(firstInside or secondInside))
\end_layout

\begin_layout Plain Layout

				if(rand()%2==0)deleteIndices.push_back(it->second.first );
\end_layout

\begin_layout Plain Layout

				else deleteIndices.push_back(it->second.second );
\end_layout

\begin_layout Plain Layout

			else
\end_layout

\begin_layout Plain Layout

				continue;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	std::sort (deleteIndices.rbegin(), deleteIndices.rend());
\end_layout

\begin_layout Plain Layout

	vector<Point<T,B> > newPoints;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	for(size_t i=0; i<points.size(); i++){
\end_layout

\begin_layout Plain Layout

		if(std::find(deleteIndices.begin(), deleteIndices.end(), (int)i) != deleteIndice
s.end())
\end_layout

\begin_layout Plain Layout

			continue;
\end_layout

\begin_layout Plain Layout

		newPoints.push_back(points[i]);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	points = newPoints;
\end_layout

\begin_layout Plain Layout

	//Count Samples and PartDer
\end_layout

\begin_layout Plain Layout

	sampleSize=0;
\end_layout

\begin_layout Plain Layout

	partDerSize=0;
\end_layout

\begin_layout Plain Layout

	for(size_t i=0; i<points.size(); i++){
\end_layout

\begin_layout Plain Layout

		sampleSize++;
\end_layout

\begin_layout Plain Layout

		partDerSize+=points[i].getNumPartDerivatives();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	BOOST_LOG_TRIVIAL(debug) <<"reducePointsAndCreateMatPositions(): after
 Delete: NumSamples:"<<sampleSize<<" NumPartDer:"<<partDerSize;
\end_layout

\begin_layout Plain Layout

	BOOST_LOG_TRIVIAL(debug) <<"reducePointsAndCreateMatPositions(): after
 Delete: MaxMatrixSize: "<<cfg.maxMatrixSize<<" NumberSamples+Der="<<sampleSize+p
artDerSize;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	cfg.numDerivatives = partDerSize;
\end_layout

\begin_layout Plain Layout

	cfg.numSamples	   = sampleSize;
\end_layout

\begin_layout Plain Layout

	cfg.numSamplesDerivatives = partDerSize+sampleSize;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../images/SoftwareTechnUmsetzung/SampleFilterAlgo_All.eps

\end_inset


\begin_inset Graphics
	filename ../images/SoftwareTechnUmsetzung/SampleFilterAlgo_Filtered.eps

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Insbesondere beim Gradient-Enhanced-Kriging sind sehr hohe Matrixgrößen
 von über 10000x10000 schnell erreicht.
 Aus diesem Grund ist es sinnvoll nur Samples auszusuchen, welche der Optimierun
g einen wirklichen Zugewinn bringen.
 Den Einfluss eines Samples auf den Optimierungsverlauf zu berechnen ist
 sehr schwierig, aus diesem Grund wäre es auch aktzeptabel die Samples herauszuf
iltern, welche nur einen kleinen Einfluss auf das Ersatzmodell haben.
 Eine einfach Möglichkeit wäre die Korrelationsmatrix selbst, in dieser
 stehen die Korrelationen zwischen allen Samples untereinander.
 Samples mit sehr hohen Korrelationen haben folglich nur einen sehr kleinen
 Abstand zueinander.
 Der Abstand wird allerdings über die im Kriging verwendeten Modell-Korrelations
funktionen bestimmt und diese sind sehr stark abhängig von den verwendeten
 Hyperparametern.
 Die Hyperparameter werden vom Training allerdings erst bei ausreichender
 Sample Anzahl vernünftig geschätzt.
 Dies kann im schlimmsten Fall dazu führen, dass man Samples aufgrund einer
 falsch geschätzten Metrik entfernt und den Optimierungsverlauf so empfindlich
 stört.
 
\end_layout

\begin_layout Standard
....
\end_layout

\begin_layout Standard
....
\begin_inset Newline newline
\end_inset

Wenn man die Thetas als Wirkweite der jeweiligen freien Variable interpretiert
 und zusätzlich davon ausgeht, dass das Training die korrekten Thetas bereits
 gefunden hat.
 So könnte man mehr partielle Ableitungen von freien Variablen mit hoher
 Wirkweite entfernen.
 Dies würde in etwa dem Gedanken entsprechen, dass bei einer komplexen bspw.
 hochfrequenten Funktion mehr partielle Ableitungen benötigt werden als
 bei einer sehr glatten simpleren Funktion.
 Allerdings würde man hier die Komplexität dann auf Parameterebene messen.
 Eine Möglichkeit wäre es, die Parameter nach Thetas zu sortieren, wobei
 kleine Thetas oben stehen sollten.
 Dann die partiellen Ableitungen mit dem kleinsten Abstand in der freien
 Variable aussortieren und jeweils einige entfernen.
 
\end_layout

\begin_layout Standard
Annahmen:
\end_layout

\begin_layout Itemize
Thetas bereits gut geschätzt
\end_layout

\begin_layout Itemize
Restart bereits im Gange
\end_layout

\begin_layout Itemize
Mit dem besten Restart Modell dann anfangen und folgende Schritte durchführen
\end_layout

\begin_layout Standard
Die niedrigsten Thetas raussortieren.
 Beim niedrigesten anfangen und dort die partiellen Ableitungen herauswerfen,
 welche den kürzesten Abstand in dieser freien Variable haben.
\end_layout

\begin_layout Standard
Dann das nächste niedrigste Theta und dort die partiellen Ableitungen rauswerfen.
 Dies sollte für ein stabileres Training sorgen ohne wichtige Informationen
 zu verlieren.
\end_layout

\begin_layout Standard
....
\end_layout

\begin_layout Subsection
Inverse durch Gleichungssysteme ersetzen 
\begin_inset CommandInset label
LatexCommand label
name "subsec:Inverse-durch-Gleichungssysteme"

\end_inset


\end_layout

\begin_layout Standard
Mit Hilfe der Cholesky Zerlegung können lineare Gleichungssysteme sehr effizient
 gelöst werden.
 Dies kann man sich zunutze machen, um bei der Likelihood Berechnung auf
 die Bestimmung der Inversen verzichten.
 Die Methodik ist weit verbreitet und soll in dieser Arbeit daher nur kurz
 erläutert werden.
 
\end_layout

\begin_layout Standard
Der Likelihoodterm (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Maximum-LikelihoodCovariance"

\end_inset

) sieht wie folgt aus:
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\log(N)= & -\log\left(\det(\mathbf{\mathbf{Cov}})\right)-\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{Cov}}^{-1}\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Die Determinante der Kovarianzmatrix wird aus der Cholesky Zerlegung gewonnen
 (siehe 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Cholesky-Zerlegung"

\end_inset

).
 Der quadratische Term 
\begin_inset Formula $\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{Cov}}^{-1}\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)$
\end_inset

 beinhaltet allerdings noch die Inverse Kovarianzmatrix.
 Dieser kann mit Hilfe der Cholesky Zerlegung gewonnen werden, wir führen
 hierfür einen Hilfsvektor 
\begin_inset Formula $\vec{e}$
\end_inset

 ein:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)=\vec{e}
\]

\end_inset


\end_layout

\begin_layout Standard
Zusätzlich noch einen Hilfsvektor 
\begin_inset Formula $\vec{d}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbf{\mathbf{Cov}}^{-1}\vec{e}=\vec{d}
\]

\end_inset


\end_layout

\begin_layout Standard
\noindent
Bei der Cholesky Zerlegung wird die Matrix 
\begin_inset Formula $\mathbf{\mathbf{Cov}}$
\end_inset

 in ein Produkt aus einer unteren Dreicksmatrix und deren Transponierten
 zerlegt, die Dreiecksmatrix 
\begin_inset Formula $\mathbf{L}$
\end_inset

 gilt an dieser Stelle als bekannt:
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\mathbf{L}\mathbf{L}^{T} & =\mathbf{\mathbf{Cov}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Daraus folgt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbf{\mathbf{\left(\mathbf{L}\mathbf{L}^{T}\right)}}^{-1}\vec{e}=\vec{d}
\]

\end_inset


\begin_inset Formula 
\[
\vec{e}=\vec{d}\mathbf{\mathbf{\mathbf{L}\mathbf{L}^{T}}}
\]

\end_inset


\end_layout

\begin_layout Standard
Führt man nun folgende Substitution ein:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vec{d_{tmp}}=\vec{d}\mathbf{\mathbf{\mathbf{L}}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vec{e}=\vec{d_{tmp}}\mathbf{\mathbf{\mathbf{L}^{T}}}
\]

\end_inset


\end_layout

\begin_layout Standard
So kann dieses Gleichungssystem durch eine einfache Rückwärtssubstitution
 
\begin_inset Formula $\vec{d}_{tmp}$
\end_inset

gelöst werden.
 Danach kann direkt das folgende Gleichungssystem durch Vorwärtseinsetzen
 gelöst werden und der Vektor 
\begin_inset Formula $\vec{d}$
\end_inset

 ist hiermit bekannt.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vec{d_{tmp}}=\vec{d}\mathbf{\mathbf{\mathbf{L}}}
\]

\end_inset


\end_layout

\begin_layout Standard
Der Aufwand hierfür ist deutlich geringer als bei der Invertierung, da nur
 zwei Gleichungssysteme gelöst werden müssen anstatt 
\begin_inset Formula $n$
\end_inset

 Gleichungssysteme für die gesamte Invertierung.
\end_layout

\begin_layout Subsection
Vollständiger Verzicht auf die Inverse durch Likelihood Partielle Ableitungen
 durch Approximation der Spur 
\begin_inset CommandInset label
LatexCommand label
name "subsec:SpurApprox"

\end_inset


\end_layout

\begin_layout Standard
Bei der Bestimmung der partiellen Ableitungen nach den Hyperparametern des
 Likelihood Terms ist es deutlich schwieriger auf die Invertierung zu verzichten.
 Dies liegt an der Bestimmung der Ableitung der Determinante nach den Hyperparam
etern.
 
\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\frac{\partial L\left(\vec{h}\right)}{\partial h_{l}}= & -\frac{\partial}{\partial h_{l}}\left(\log\left(\det(\mathbf{\mathbf{Cov}})\right)\right)-\frac{\partial}{\partial h_{l}}\left(\left(\vec{y}_{s}-\beta\overrightarrow{F}\right)^{T}\mathbf{\mathbf{Cov}}^{-1}\left(\vec{y}_{s}-\beta\overrightarrow{F}\right)\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\frac{\partial L\left(\vec{h}\right)}{\partial h_{l}}= & -\frac{1}{\det(\mathbf{\mathbf{Cov}})}\frac{\partial}{\partial h_{l}}\left(\det(\mathbf{\mathbf{Cov}})\right)+\left(\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{\mathbf{Cov}}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\mathbf{\mathbf{Cov}}^{-1}\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset Formula 
\begin{align*}
\frac{\partial L\left(\vec{h}\right)}{\partial h_{l}}= & -\textrm{Spur}\left(\mathbf{\mathbf{Cov}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\right)+\left(\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{\mathbf{Cov}}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\mathbf{\mathbf{Cov}}^{-1}\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Spur schätzen 
\begin_inset CommandInset citation
LatexCommand cite
key "Avron2011,hutchinson1989stochastic,MarkGibbs1997"

\end_inset


\begin_inset Formula 
\[
Spur\left(R\right)=E\left[\vec{d}^{T}R\vec{d}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Spur\left(R\right)\approx\frac{1}{N}\sum\vec{d}^{T}R\vec{d}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\vec{d}=\left[\begin{array}{c}
N\left(0,1\right)\\
\vdots\\
N\left(0,1\right)
\end{array}\right]
\]

\end_inset


\end_layout

\begin_layout Standard
Die Approximation benötigt leider einen sehr großen Zufallsvektor 
\begin_inset Formula $\vec{d}$
\end_inset

 um eine ausreichende Genauigkeit zu erhalten.
 Dies macht die Methode letztlich wieder ineffizient.
 Zudem bleibt immer eine Restunsicherheit in den partiellen Ableitungen
 die sich sehr negativ auf das Training auswirken kann.
 
\end_layout

\begin_layout Subsection
Vollständiger Verzicht auf die Inverse durch Rückwärtsdifferentiation der
 Cholesky Zerlegung
\end_layout

\begin_layout Standard
Wie in Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SpurApprox"

\end_inset

 bereits erwähnt, ist es bei der Berechnung des Likelihood Terms möglich
 auf die Invertierung der Kovarianzmatrix zu verzichten.
 Bei der Bestimmung der partiellen Ableitungen des Likelihood Terms nach
 den Hyperparametern ist dies allerdings schwieriger.
 Die Bestimmung der partiellen Ableitungen folgt dem folgenden Berechnungsschema
:
\end_layout

\begin_layout Enumerate
Über alle benötigen Hyperparameter 
\begin_inset Formula $h_{l}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Bestimmung der Ableitung der Kovarianzmatrix
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset


\end_layout

\begin_layout Enumerate
Berechnung der Ableitung der quadratischen Form: 
\begin_inset Formula $\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{\mathbf{Cov}}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\mathbf{Cov}^{-1}\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Berechnung der Ableitung der Determinante: 
\begin_inset Formula $\textrm{Spur}\left(\mathbf{\mathbf{Cov}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Punkt a bedeutet vom Aufwand die Aufstellung der symmetrischen Matrix 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset

.
 Die Komplexität des Algorithmus liegt bei 
\begin_inset Formula $\mathcal{O}\left(n^{2}\right)$
\end_inset

 und kann zudem sehr gut parallelisiert werden.
 Die Bestimmung der einzelnen Ableitungen der Kovarianzmatrix hängt stark
 von dem verwendeten Kriging Modell und der verwendeten Korrelationsfunktion
 ab.
 Beim Gradient Enhanced Kriging können diese Einzelableitungen komplexer
 werden und damit auch vom numerischen Aufwand teurer.
 Dennoch können in der Regel sehr viele Teile aus der Aufstellung der Kovarianzm
atrix wiederverwendet werden, was den Aufwand erheblich reduziert und daher
 eher unerheblich macht.
 
\end_layout

\begin_layout Standard
Punkt b ist vom Aufwand her nahezu vernachlässigbar.
 In der Regel wurde der Vektor 
\begin_inset Formula $\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{\mathbf{Cov}}}^{-1}$
\end_inset

 bereits in der Likelihood Berechnung bestimmt und es muss nur noch eine
 Vektor Matrix Multiplikation durchgeführt werden.
\end_layout

\begin_layout Standard
Punkt c ist der aufwendigste Teil, da nur für diesen Teil die Inverse bestimmt
 werden muss.
 Die Inverse wird natürlich außerhalb dieser Schleife nur einmal berechnet,
 dennoch könnte man ohne diesen Teil vollständig auf die direkte Berechnung
 der Inversen verzichten.
 Ist die Inverse bestimmt, liegt die Komplexität zur Berechnung der Spur
 bei 
\begin_inset Formula $\mathcal{O}\left(n^{2}\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
Der Hauptaufwand liegt also in der Berechnung der Inversen.
 Der genaue Ablauf zur Bestimmung der Inversen folgt dem Schema aus Kapitel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Cholesky-Zerlegung"

\end_inset

.
 Grundlegend besteht dieses Schema aus zwei Schritten:
\end_layout

\begin_layout Enumerate
Cholesky Zerlegung der Kovarianzmatrix
\end_layout

\begin_layout Enumerate
Vorwärts- und Rückwärtssubstitution zur Bestimmung der Inversen
\end_layout

\begin_layout Standard
Der Aufwand beider Schritte liegt bei 
\end_layout

\begin_layout Enumerate
Ungefähr 
\begin_inset Formula $\frac{1}{6}n^{3}$
\end_inset

Multiplikationen/Additionen, 
\begin_inset Formula $\frac{1}{2}n^{2}$
\end_inset

 Divisionen, 
\begin_inset Formula $n$
\end_inset

 Wurzeloperationen 
\end_layout

\begin_layout Enumerate
Vorwärts- und Rückwärtseinsetzen insgesamt: 
\begin_inset Formula $n^{3}$
\end_inset

 Multiplikationen/Additionen
\end_layout

\begin_layout Standard
Der Hauptaufwand liegt also bei der Vorwärts- und Rückwärtssubstitution.
 Wobei sich diese für den Fall einer Invertierung hervorragend parallelisieren
 lässt.
 Da man das Vorwärts- und Rückwärtseinsetzen bei der Invertierung über 
\begin_inset Formula $n$
\end_inset

 Vektoren macht, kann man die Berechnung über die Vektoren parallelisieren.
 SIMD Routinen sind hier besonders effizient, da für jeden Vektor immer
 dieselbe Routine durchlaufen wird und nur die Daten sich ändern.
 Eine GPU, SSE oder AVX Beschleunigung ist hier also besonders anzustreben.
 Denkbar ist aber auch eine Parallelisierung auf Prozessebene, diese ließe
 sich nach demselben Schema aufteilen und die Teile dann natürlich auch
 über SIMD Befehle beschleunigen.
 Im Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Verteiltes-Rechnen"

\end_inset

 wird eine mögliche Umsetzung der prozessweiten Parallelisierung aufgezeigt.
 
\end_layout

\begin_layout Standard
Ein kompletter Verzicht auf die Vorwärts Rückwärtssubstitution wäre dennoch
 erstrebenswert, da diese den größten Teil des Aufwands ausmacht.
 In Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:SpurApprox"

\end_inset

 wurde aufgezeigt, dass nur die Ableitung der Determinante der Kovarianzmatrix
 die Rückwärts- und Vorwärtssubstitution benötigt.
 Es gilt also eine andere Möglichkeit der analytischen Berechnung für diese
 Ableitung zu finden, die eine kürzere Laufzeit verspricht.
\end_layout

\begin_layout Standard
Einen interessanten Ansatz hierzu kann man in 
\begin_inset CommandInset citation
LatexCommand cite
key "toal2009adjoint"

\end_inset

 finden.
 Dieser bedient sich der algorithmischen Differentiation im Rückwärtsmodus,
 der interessierte Leser sei auf 
\begin_inset CommandInset citation
LatexCommand cite
key "Mader2008,Griewank2008"

\end_inset

 verwiesen, welche einen sehr guten Überblick über die algorithmische Differenti
ation bieten.
 Die grundlegende Idee in diesen Ansätzen ist es den gesamte Likelihood
 Term rückwärts zu differenzieren.
 Dieser Ansatz bietet die Möglichkeit auf die Vor- und Rückwärtssubstitution
 zu verzichten, allerdings werden rückwärtsdifferenzierte Algorithmen des
 Cholesky Algorithmus und auch der Vor- und Rückwärtssubstitution benötigt.
 Für diese Algorithmen gibt es keine performante Implementation über Bibliotheke
n.
 
\end_layout

\begin_layout Standard
Aus diesem Grund in 
\begin_inset CommandInset citation
LatexCommand cite
key "Toal2011"

\end_inset

 ein Algorithmus vorgeschlagen, welcher die Invertierung zwar benötigt,
 aber keine rückwärtsdifferenzierten Algorithmen.
 Ein Geschwindigkeitsvorteil wird hierbei bei der Aufstellung der partiellen
 Ableitungen der Kovarianzmatrix 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset

 erreicht.
 Diese muss bei dem verwendeten Algorithmus nicht mehr direkt erzeugt werden.
 Die Vorwärts- und Rückwärtssubstitution muss dennoch durchgeführt werden.
 Diese stellt grundlegend auch den Hauptanteil bei der Berechnung des Likelihood
s und der Ableitungen dar.
 
\end_layout

\begin_layout Standard
Eine andere Möglichkeit bietet die alleinige Rückwärtsdifferentiation der
 Determinante der Kovarianzmatrix.
 Dieser Ansatz bietet einen grundsätzliches Geschwindigkeitsvorteil,wie
 sich im Weiteren herausstellen wird.
 Zudem bietet dieser Ansatz den Vorteil, dass der Quellcode sich nur minimal
 ändert und für alle Kriging-Verfahren und auch Korrelationsfunktionen gilt.
 Es wird allerdings eine rückwärtsdifferenzierte Version des Cholesky Algorithmu
s benötigt.
 Für diese bestehen mittlerweile aber sehr effiziente BLAS-Implementierungen,
 diese werden im weiteren Verlauf vorgestellt.
 Der grundlegende Ansatz ist die Bestimmung der formellen Ableitung der
 gesuchten Ableitung:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & \frac{\partial\left(ln\left(det\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)}{\partial h_{l}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Wobei die Determinante das Produkt über alle quadrierten Diagonalelemente
 der Cholesky zerlegten Dreiecksmatrix 
\begin_inset Formula $LL^{T}$
\end_inset

 ist:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
ln\left(det\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right) & =ln\left(\prod_{i}L_{i,i}^{2}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Wobei folgende Form in der Regel bevorzugt wird, da diese numerisch stabiler
 ist:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & =2\sum ln\left(L_{i,i}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Daraus ergibt sich die folgende Verkettung, welche die Cholesky Zerlegung
 berücksichtigt 
\begin_inset Formula $f_{chol}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & \frac{\partial\left(ln\left(det\left(f_{chol}\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)\right)}{\partial h_{l}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Die bestehenden Abbildungen sehen wie folgt aus;
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathbf{\mathbf{\mathbf{Cov}}}:\mathbb{R}\longmapsto\mathbb{R}^{n^{2}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
f_{chol}:\mathbb{R}^{n^{2}}\longmapsto\mathbb{R}^{n^{2}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
det:\mathbb{R}^{n^{2}}\longmapsto\mathbb{R}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
ln:\mathbb{R}\longmapsto\mathbb{R}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Der Logarithmus der Determinante wird als 
\begin_inset Formula $f_{lndet}$
\end_inset

 zusammengefasst
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & \frac{\partial\left(f_{lndet}\left(f_{chol}\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)}{\partial h_{l}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
f_{lndet}:\mathbb{R}^{n^{2}}\longmapsto\mathbb{R}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
es gilt also
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
f_{lndet}\circ f_{chol}\circ\mathbf{\mathbf{\mathbf{Cov}}} & :\mathbb{R}\longmapsto\mathbb{R}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
daraus resultieren die Jacobi Matrizen 
\begin_inset Formula $D_{cov}$
\end_inset

 der Größe 
\begin_inset Formula $n^{2}\times1$
\end_inset

, 
\begin_inset Formula $D_{chol}$
\end_inset

 der Größe 
\begin_inset Formula $n^{2}\times n^{2}$
\end_inset

 und 
\begin_inset Formula $D_{flndet}$
\end_inset

 der Größe 
\begin_inset Formula $1\times n^{2}$
\end_inset

 wobei 
\begin_inset Formula $\mathbf{\mathbf{C_{i,j}}}$
\end_inset

 einen Eintrag der Matrix 
\begin_inset Formula $\mathbf{\mathbf{\mathbf{Cov}}}$
\end_inset

 bedeutet.
\end_layout

\begin_layout Standard
Damit wird die gesamte Ableitung zu:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\frac{\partial\left(f_{lndet}\left(f_{chol}\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)}{\partial h_{l}} & =D_{flndet}D_{chol}D_{cov}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\frac{\partial\left(f_{lndet}\left(f_{chol}\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)}{\partial h_{l}} & =\sum_{i}\sum_{_{j<=i}}\sum_{k}\sum_{_{m<=k}}\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{i,j}}}}}\frac{\partial\mathbf{\mathbf{\mathbf{L_{i,j}}}}}{\partial\mathbf{\mathbf{\mathbf{C_{k,m}}}}}\frac{\partial\mathbf{\mathbf{C_{k,m}}}}{\partial h_{l}}\label{eq:KettenregelCholesky}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Es gilt nun sich zu überlegen, wie man die hier gezeigte mehrdimensionale
 Kettenregel möglichst effizient bestimmen kann.
 Berechnet man die vollständige Summe, dann wäre die Komplexität für die
 Berechnung der Ableitung bei 
\begin_inset Formula $\mathcal{O}\left(n^{4}\right)$
\end_inset

.
 Der Aufwand wäre also deutlich größer als über die Bestimmung der Inversen.
 Benötigt wird also ein Algorithmus, welcher die notwendigen Terme der mehrdimen
sionalen Kettenregel ohne große Matrizen berechnen kann.
 Als erste Vereinfachung kann man sich versuchen die einzelnen Jacobi Vektoren
 zu bestimmen.
 Der Vektor 
\begin_inset Formula $D_{cov}$
\end_inset

 entspricht einfach nur allen Einträgen der Matrix 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset

 und ist im Kriging daher bekannt.
 Als nächstes kann man den Vektor 
\begin_inset Formula $D_{flndet}$
\end_inset

 bestimmen, da man die Funktion 
\begin_inset Formula $f_{lndet}$
\end_inset

 kennt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
D_{flndet}^{T} & =\left(\begin{array}{c}
\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{1,1}}}}}\\
\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{2,1}}}}}\\
\vdots\\
\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{n-1,n}}}}}\\
\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{n,n}}}}}
\end{array}\right)=\left(\begin{array}{c}
\frac{\partial2\sum ln\left(L_{i,i}\right)}{\partial\mathbf{\mathbf{\mathbf{L_{1,1}}}}}\\
\frac{\partial2\sum ln\left(L_{i,i}\right)}{\partial\mathbf{\mathbf{\mathbf{L_{2,1}}}}}\\
\vdots\\
\frac{\partial2\sum ln\left(L_{i,i}\right)}{\partial\mathbf{\mathbf{\mathbf{L_{n-1,n}}}}}\\
\frac{\partial2\sum ln\left(L_{i,i}\right)}{\partial\mathbf{\mathbf{\mathbf{L_{n,n}}}}}
\end{array}\right)=\left(\begin{array}{c}
\frac{2}{L_{1,1}}\\
0\\
\vdots\\
0\\
\frac{2}{L_{n,n}}
\end{array}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Die Bestimmung dieses Vektors kann auch als Diagonalmatrix interpretiert
 werden welche sehr schnell aus der Cholesky zerlegten Matrix bestimmt werden
 kann.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\bar{D}_{flndet}= & \left[\begin{array}{ccc}
\frac{2}{L_{1,1}} & \cdots & 0\\
\vdots & \ddots & \vdots\\
0 & \cdots & \frac{2}{L_{n,n}}
\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Auffällig ist hierbei, das der Großteil des Jacobi Vektors aus 0 Einträgen
 besteht, mit dieser Information lässt sich Gleichung 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:KettenregelCholesky"

\end_inset

 stark vereinfachen, da nur noch die Einträge 
\begin_inset Formula $\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{i,j}}}}}\neq0\left|i=j\right.$
\end_inset

 sind:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\frac{\partial\left(f_{lndet}\left(f_{chol}\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)}{\partial h_{l}} & =\sum_{i}\sum_{k}\sum_{_{m<=k}}\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}\frac{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}{\partial\mathbf{\mathbf{\mathbf{C_{k,m}}}}}\frac{\partial\mathbf{\mathbf{C_{k,m}}}}{\partial h_{l}}\label{eq:KettenregelCholeskyReduced}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Die Komplexität liegt somit nur noch bei 
\begin_inset Formula $\mathcal{O}\left(n^{3}\right)$
\end_inset

.
 
\end_layout

\begin_layout Standard
Als nächsten Schritt muss man sich nun überlegen, wie man den mittleren
 Teil der Kettenregel (
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}{\partial\mathbf{\mathbf{\mathbf{C_{k,m}}}}}$
\end_inset

) bestimmen kann.
 Hierfür gibt es prinzipiell zwei Möglichkeiten:
\end_layout

\begin_layout Enumerate
Man geht von den Werten 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{C_{k,m}}}}{\partial h_{l}}$
\end_inset

 aus und bestimmt ausgehend von diesen die Einträge von 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}{\partial h_{l}}$
\end_inset

 über eine vorwärts differenzierte Cholesky Zerlegung
\end_layout

\begin_layout Enumerate
Man geht von den Werten 
\begin_inset Formula $\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}$
\end_inset

 aus und bestimmt ausgehend von diesen die Einträge von 
\begin_inset Formula $\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{C_{k,m}}}}}$
\end_inset

über eine rückwärts differenzierte Cholesky Zerlegung
\end_layout

\begin_layout Standard
Grundsätzlich sollten beide Vorgehensweise vom numerischen Aufwand gleichwertig
 sein.
 Da man allerdings für jeden der 
\begin_inset Formula $o$
\end_inset

-Hyperparameter 
\begin_inset Formula $h_{l}$
\end_inset

 die Matrix 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{C_{k,m}}}}{\partial h_{l}}$
\end_inset

 bestimmen muss und damit wiederum 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}{\partial\mathbf{\mathbf{\mathbf{C_{k,m}}}}}$
\end_inset

, muss man also die vorwärts differenzierte Cholesky Zerlegung 
\begin_inset Formula $o$
\end_inset

-mal aufrufen.
 In Fall 2 ist dies nicht so, denn die Berechnung ist unabhängig von der
 Anzahl der Hyperparameter.
 Aus diesem Grund verspricht der rückwärtsdifferenzierte Fall einen Vorteil
 bei der Bestimmung der partiellen Ableitungen der Hyperparameter.
\end_layout

\begin_layout Standard
Der numerische Aufwand für einen solchen rückwärtsdifferenzierten Cholesky
 Algorithmus liegt bei dem ungefähr doppelten Aufwand einer normalen Cholesky
 Zerlegung 
\begin_inset CommandInset citation
LatexCommand cite
key "Smith1995"

\end_inset

.
 Das ist immer noch deutlich schneller als eine Vor- und Rückwärtssubstitution.
 Der in 
\begin_inset CommandInset citation
LatexCommand cite
key "Smith1995"

\end_inset

 beschriebene Algorithmus ist allerdings nur schwer parallelisierbar und
 auch für SIMD Architekturen nur schlecht geeignet.
 In Anhang 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Beschleunigter-BackChodec"

\end_inset

 wird eine parallelisierte und SIMD-beschleunigte Variante des Algorithmus
 nach Smith-Algorithmus präsentiert.
 
\end_layout

\begin_layout Standard
In der Arbeit von 
\begin_inset CommandInset citation
LatexCommand cite
key "Murray2016,Sarkka2013"

\end_inset

 werden einige moderne Varianten präsentiert, welche es ermöglichen Standard
 Level 2-3 BLAS Routinen zu verwenden.
 Diese stellen die effizientesten Methoden dar und werden folgend auch verwendet.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Subsection*
Adjoint Matrix
\end_layout

\begin_layout Paragraph
Level 3 BLAS Umsetzung
\end_layout

\begin_layout Paragraph
Benchmarks
\end_layout

\begin_layout Plain Layout
Einzelne Rückwärts Cholesky
\end_layout

\begin_layout Plain Layout
Komplettes GTraining mit verschiedenen Matrixgrößen
\end_layout

\begin_layout Plain Layout

\size larger
Mehrere Korrelationsfunktionen GEK und CO-Kriging sind hier sehr problematisch
\size default
 (SICHER?), da sich die Ableitung des Likelihood nach den Hyperparametern
 komplexer gestaltet und Softwaretechnisch nur noch schlecht zu lösen sind.
 
\end_layout

\begin_layout Plain Layout
- Rverse Vorwärts und Rückwärts und Reverse Choelsky muss durchlaufen werden,
 ansonsten sehr elegant und schneller als die normale Implmentierung
\end_layout

\begin_layout Plain Layout
In 
\begin_inset CommandInset citation
LatexCommand cite
key "Toal2011"

\end_inset

 wird dieser Ansatz nochmals verändert und mithilfe der linearen Algebra
 Ansätze von 
\begin_inset CommandInset citation
LatexCommand cite
key "Giles2008"

\end_inset

 auf eine Form gebracht, die auf die Rückwärtsdifferenzierung des Cholesky
 Algorithmus und der Vor- und Rückwärtssubstitution verzichtet.
 Allerdings wird hierfür die Inverse der Kovarianzmatrix benötigt, also
 auch die Vor- und Rückwärtssubstitution.
 Dieser Umstand wird in 
\begin_inset CommandInset citation
LatexCommand cite
key "Toal2011"

\end_inset

 als Vorteil angesehen, da masn Standardbibliotheken für lineare Algebra
 ohne Probleme weiterverwenden kann und die Bestimmung der Likelihood Ableitunge
n etwas .
 
\end_layout

\begin_layout Plain Layout
Eine andere Möglichkeit ist die Bestimmung ....
\begin_inset Newline newline
\end_inset

-Trugschluss da Reverse Cholesky nur 2x Aufwand von Cholesky also immer
 nopch viel schneller als Vor und R+ückwärts
\end_layout

\begin_layout Plain Layout
-Reverse Vor und Rück wird sowieso nicht benötigt, wenn nur die ableitung
 nach Determinante
\end_layout

\begin_layout Plain Layout
- Reverse Cholesky wird nur eine effizienze Implementierung verwendet, hier
 wird eine aufgezeigt welche von 8sec auf 0.2sec bei 20 CPUs und SSE runter
 ist.
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Murray2016"

\end_inset

 wird auch eine Implementierung gezeugt, welche die Verwendung von Standardblibi
otheksunftionen ermöglicht.
 
\begin_inset Newline newline
\end_inset

– - - - - - - - - - - - - - - - – - - - - - - - - - - - - - - - – - - -
 - - - - - - - - - - - - – - - - - - - - - - - - - - - - 
\end_layout

\begin_layout Plain Layout
– - - - - - - - - - - - - - - - – - - - - - - - - - - - - - - - – - - -
 - - - - - - - - - - - - – - - - - - - - - - - - - - - - 
\end_layout

\begin_layout Plain Layout
– - - - - - - - - - - - - - - - – - - - - - - - - - - - - - - - – - - -
 - - - - - - - - - - - - – - - - - - - - - - - - - - - - 
\end_layout

\begin_layout Plain Layout
In wird ein Verfahren dargestellt, welches die gesamte Likelihood Berechnung
 rückwärts differenziert.
 Für dieses Verfahren ist es allerdings notwendig die komplette Vor- und
 Rückwärtssubstitution zu durchlaufen, zudem muss dieses Verfahren für jede
 neue Korrelationsfunktion umgeschrieben werden, was es softwaretechnisch
 kompliziert macht.
 Der Aufwand der Vor- und Rückwärtssubstitution würde dadurch ebenfalls
 nicht wegfallen oder vermindert werden.
 Würde eine Beschleunigung in der Bestimmung der partiellen Ableitungen
 der Kovarianzmatrix bringen.
 Der Nachteil liegt jedoch darin, dass man eine Reverse Version der Cholesky
 Zerlegung und der Vorwärts- und Rückwärtssubstition benötigt.
 Dies würde eine Benutzung von Libraries wie CUDA oder der Intel MKL verhindern.
 Die Beschleunigung durch CUDA oder MKL wird von uns als deutlich höher
 eingeschätzt als der Zugewinn durch die adjungierte Kovarianzmatrix.
 Aus diesem Grund wird darauf verzichtet.
\end_layout

\begin_layout Plain Layout
Grundlegend ist es nicht nötig die gesamte Likelihood Berechnung rückwärts
 zu differenzieren, denn der einzig wirklich problematische Term ist 
\begin_inset Formula $\frac{\partial}{\partial h_{l}}\left(\log\left(\det(\mathbf{\mathbf{Cov}})\right)\right)$
\end_inset

.
 Für diesen Term ist es zwingend notwendig die Inverse der Kovarianzmatrix
 zu berechnen.
 Es ist also ausreichend, nur diesen Term rückwärts zu differenzieren.
 
\end_layout

\begin_layout Plain Layout
In wird die Cholesky Zerlegung rückwärts differenziert, mithilfe dieses
 Algorithmus ist es möglich die Ableitung der Determinante ohne vorherige
 Invertierung der Kovarianzmatrix zu erhalten.
 
\end_layout

\begin_layout Plain Layout

\size larger
Code Optimierung vergleich, zwischen dem Originalcode und dem optimierten,
 Native & SSE !!!!!!
\end_layout

\begin_layout Plain Layout
Der Code wird deutlich unleserlicher und schwerer zu pflegen, deswegen nur
 für feste Code Bestandteile sinnvoll
\end_layout

\begin_layout Plain Layout
_mm_load_pd(*adress) ist aligned und daher extrem schnell (wenn ich auf
 einer geraden Anzahl bin vom Array)
\end_layout

\begin_layout Plain Layout
_mm_loadu_pd(double,double) is unaligned und daher sehr langsam(wenn ich
 auf einer ungeraden Anzahl bin vom Array)
\end_layout

\begin_layout Plain Layout
Benchmark: alte Version bereits mit SSE und Parallelisierung, Gleichungssysteme
 stattt Inverse benutzt, nur für RPunkt die Inverse
\end_layout

\begin_layout Plain Layout
Nur die chodecReverse und invertierung verlgiehcen, da der Rest prinzipiell
 gleich ist
\end_layout

\begin_layout Plain Layout
asd
\end_layout

\begin_layout Plain Layout
Erklären wie SSE durch den Speicher geht, also Speicher in 4er Blöcken aligned
 und wenn man außerhalb davon zugreift, liest die CPU die nächsten 2 Adressen
 und die 2te ist dann woanders.
 Das führt danndazu, mdass das Betriebssystem meckert und dem Prozess nicht
 erlaubt den Bereich zu lesen-> Speicherzugriffsfehöer
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

	register int i; 
\end_layout

\begin_layout Plain Layout

	int n = this->getColumnSize(); 
\end_layout

\begin_layout Plain Layout

	if(this->getColumnSize() != this->getRowSize()){ 	  cout <<"Matrix nicht
 quadratisch!
\backslash
n"; 	  return false; 	} 	if(this->getColumnSize() <=0){ 	  cout <<"Matrix
 Größe <= 0!
\backslash
n"; 	  return false; 	} 
\end_layout

\begin_layout Plain Layout

	adjointMat.setSymmetric(true);
\end_layout

\begin_layout Plain Layout

        // Set Seed Matrix #pragma omp parallel for         for(int i=0;
 i<n; i++){             adjointMat[i][i] = 2.0/(*this)[i][i];         } 
                          for(int k=n-1; k>=0; k--){             for(int
 j=k+1; j<n;j++){                 for(int i=j; i<n;i++){               
          adjointMat[i][k]  -=  adjointMat[i][j]*(*this)[j][k];        
                 adjointMat[j][k]  -=  adjointMat[i][j]*(*this)[i][k]; 
                }             }                          for(int j=k+1;
 j<n;j++){                 adjointMat[j][k] /=  (*this)[k][k];         
        adjointMat[k][k] -=  adjointMat[j][k]*(*this)[j][k];           
  }             adjointMat[k][k]=0.5*adjointMat[k][k]/(*this)[k][k];    
     }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	adjointMat.setSymmetric(true); 
\end_layout

\begin_layout Plain Layout

	return true;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Vergleich zwischen der Invertierung und der Rückwärtsdifferenziereu
\end_layout

\begin_layout Standard
Bei dem hier vorgestelltem Algorithmus handelt es sich prinzipiell nicht
 um eine klassische Rückwärtsdifferenzierung wie z.B.
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "toal2009adjoint"

\end_inset

.
 Diese differenzieren die gesamte Ableitung des Likelihoods rückwärts.
 Diese Algorithmen haben jedoch den Nachteil, dass der Quellcode deutlich
 komplexer und schwerer zu warten ist, insbesondere wenn man mehrere Korrelation
sfunktionen und Verfahren anbietet.
 In beiden Fällen ist es aber nicht direkt ersichtlich, dass die Rückwärtsdiffer
enzierte Methode die schneller ist.
 Die Vermutung ist allerdings, dass die Algortihmen der Rückwärtsdifferenzierung
 weniger Operationen benötigen und sich besser beschleunigen lassen.
 Ein direkter Vergleich der benötigten Operationen innerhalb der Algorithmen
 ist allerdings so gut wie unmöglich, da meist sehr stark optimierte Bibliotheke
n wie die Intel MKL oder ATLAS Bibliothek verwendet werden.
 Diese bedienen sich oft komplexer Algorithmen wie z.B.
 den Strassen Algorithmus, welcher eine Matrix Multiplikation mit einer
 Komplexität von 
\begin_inset Formula $\mathcal{O}\left(n^{log_{2}7}\right)$
\end_inset

 berechnen kann.
 Oft werden die Algorithmen je nach Matrix Größe umgeschaltet, sodass sich
 die echte Komplexität kaum noch bestimmen lässt.
 In der Regel wird diese auch nicht dokumentiert.
 Dennoch lässt sich davon ausgehen, dass diese Bibliotheken das aktuelle
 Maximum an Geschwindigkeit darstellen, sodass eine gute und auch realistische
 Vergleichbarkeit gewährleistet ist.
 Aus diesem Grund sollen in diesem Abschnitt die Unterschiede der Verfahren
 über Benchmarks ermittelt werden.
 
\end_layout

\begin_layout Standard
Betrachtet man den Teil der Berechnung zur Bestimmung der Ableitung des
 Likelihoods nach den Hyperparameter, in dem sich die beiden Verfahren untersche
iden, so handelt es sich prinzipiell nur um einen Term:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & \frac{\partial\left(ln\left(det\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)\right)}{\partial h_{l}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Die analytische Ableitung ist wie folgt bestimmt:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\textrm{Spur}\left(\mathbf{\mathbf{Cov}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\right)$
\end_inset


\end_layout

\begin_layout Standard
Für beide Verfahren gilt die gleiche Ausgangssituation: Die nach den Hyperparame
tern abgeleitete Kovarianzmatrix ist bekannt 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset

 und auch die Cholesky-zerlegte Matrix 
\begin_inset Formula $\mathbf{L}$
\end_inset

 ist bekannt.
 Ziel ist es die Ableitung nach den Hyperparametern des Terms 
\begin_inset Formula $ln\left(det\left(\mathbf{\mathbf{\mathbf{Cov}}}\left(h_{l}\right)\right)\right)$
\end_inset

 zu bestimmen.
\end_layout

\begin_layout Standard
\noindent
Die Bestimmung der vorwärtsdifferenzierten Ableitung benötigt folgende Schritte:
\end_layout

\begin_layout Enumerate
Bestimmung der differenzierten Kovarianzmatrix 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset

 für jeweils einen Hyperparameter 
\begin_inset Formula $h_{l}$
\end_inset


\end_layout

\begin_layout Enumerate
Bestimmung der Cholesky Zerlegung 
\begin_inset Formula $\mathbf{L}$
\end_inset

 
\end_layout

\begin_layout Enumerate
Bestimmung von 
\begin_inset Formula $\mathbf{\mathbf{Cov}}^{-1}$
\end_inset

, da die zerlegte Matrix bekannt ist, muss noch eine Vor- und Rückwärtssubstitut
ion durchgeführt werden diese benötigt relativ genau 
\begin_inset Formula $n^{3}$
\end_inset

 Operationen.
\end_layout

\begin_layout Enumerate
Die Bestimmung der quadratischen Form 
\begin_inset Formula $\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{\mathbf{Cov}}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\mathbf{Cov}^{-1}\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Das Matrixprodukt 
\begin_inset Formula $\mathbf{\mathbf{Cov}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset

, wobei hiervon nur die Diagonale berechnet werden muss, daher liegt diese
 Berechnung bei ca.
 
\begin_inset Formula $n^{2}$
\end_inset

 Operationen.
 Durch die Spur kann man sparen, es gibt keine BLAS Routine dafür.
 
\end_layout

\begin_layout Standard
Die Bestimmung der Rückwärtsdifferenzierten Ableitung benötigt folgende
 Schritte.
\end_layout

\begin_layout Enumerate
Bestimmung der differenzierten Kovarianzmatrix 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset

 für jeweils einen Hyperparameter 
\begin_inset Formula $h_{l}$
\end_inset


\end_layout

\begin_layout Enumerate
Bestimmung der Cholesky Zerlegung 
\begin_inset Formula $\mathbf{L}$
\end_inset

 
\end_layout

\begin_layout Enumerate
Die Bestimmung der Rückwärtsdifferenzierten Cholesky Zerlegung 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}{\partial\mathbf{\mathbf{\mathbf{C_{k,m}}}}}$
\end_inset

 inlkusive Aufstellen der Seed Matrix 
\begin_inset Formula $\mathbf{\bar{L}}$
\end_inset

 (siehe 
\begin_inset Formula $\frac{\partial f_{lndet}}{\partial\mathbf{\mathbf{\mathbf{L_{i,i}}}}}$
\end_inset

) dieses benötigt 
\begin_inset Formula $n$
\end_inset

 Operationen
\end_layout

\begin_layout Enumerate
Die Bestimmung der quadratischen Form 
\begin_inset Formula $\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)^{T}\mathbf{\mathbf{\mathbf{Cov}}}^{-1}\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}\mathbf{Cov}^{-1}\left(\vec{y}_{s}-\beta_{1}\overrightarrow{F}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Die Bestimmung des Produkts der aus Punkt 2 berechneten Matrix und den Einträgen
 der differenzierten 
\begin_inset Formula $\frac{\partial\mathbf{\mathbf{\mathbf{Cov}}}}{\partial h_{l}}$
\end_inset

 
\begin_inset Formula $\sim\frac{n^{2}}{2}+\frac{n}{2}$
\end_inset


\end_layout

\begin_layout Standard
Letztlich zählt für den Vergelcih haupütsächlich der Unterschied zwischen
 der Vorwärts- und Rückwärtssubstitution und der Rückwärtsdifferenzierten
 Cholesky Zerlegung.
 da beides über Intel MKL Routinen umgesetzt wurde, ist nicht bekannt wieviele
 Operationen wirklich gemacht werden.
 Daher wird folgend ein zeitlicher Vergleich über ein Benchmark angestellt.
 Erwartet wird ein konstanter Faktor zugunsten der Rückwärtsdifferenziereung.
\end_layout

\begin_layout Standard
Als Benchmark dienten zufällig erzeugte Testdaten aus der ZDT3 Funktion
 (siehe Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Benchmarks"

\end_inset

) mit jeweils 8 Parametern.
 Es wurden jeweils 10 Kriging Iterationen durchgeführt und die Zeiten für
 die Erzeugung der partiellen Ableitungen des Likelihoods gemessen.
 Berechnet wurde der Testfall dabei zwei Xeon E5 2640 v3 mit insgesamt 16
 Threads.
 Für alle Berechnungen wurde die Intel MKL Bibliothek verwendet.
 
\end_layout

\begin_layout Standard
Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ForwarBackwardBenchmarkGesamtzeit"

\end_inset

 zeigt die benötigte Zeit für die Erzeugung der partiellen Ableitungen.
 Der Rückwärtsmodus war in diesem Fall grundlegend schneller als der Vorwärtsmod
us.
 Im Schnitt konnte ein konstanter Faktor zwischen den beiden Berechnungsmoden
 gefunden werden der bei ca.
 0.68 lag.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../images/SoftwareTechnUmsetzung/BackwardBenchPartDerTimeFull.eps
	scale 80

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Vergleich der benötigten Gesamtzeit für die Erzeugung der partiellen Ableitungen
 im Vorwärts- und Rückwärtsmodus über verschiedene Matrixgrößen
\begin_inset CommandInset label
LatexCommand label
name "fig:ForwarBackwardBenchmarkGesamtzeit"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die folgenden Abbildungen zeigen die Zeiten der verschiedenen Schritte im
 Vergleich:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../images/SoftwareTechnUmsetzung/BackwardBenchPartDerTimeStep1.eps
	scale 70

\end_inset


\begin_inset Graphics
	filename ../images/SoftwareTechnUmsetzung/BackwardBenchPartDerTimeStep2-3.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../images/SoftwareTechnUmsetzung/BackwardBenchPartDerTimeStep4.eps
	scale 70

\end_inset


\begin_inset Graphics
	filename ../images/SoftwareTechnUmsetzung/BackwardBenchPartDerTimeStep5.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wie erwartet sind die Zeiten vom ersten und vom vierten Schritt nahezu identisch
, da die Berechnung letztlich auch dieselbe ist.
 Unterschiede können in Schritt 2-3 und Schritt 5 gesehen werden, in beiden
 Fällen ist der Rückwärtsmodus schneller.
 
\end_layout

\begin_layout Subsection
Verwendung von GPGPU 
\begin_inset CommandInset label
LatexCommand label
name "sec:Verwendung-von-GPGPU"

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset citation
LatexCommand cite
key "Toal2016"

\end_inset

 wird die Verwendung von GPUs innerhalb des Kriging Verfahren bereits als
 gewinnbringend beschrieben.
 Innerhalb dieses Kapitels soll eine konkrete Umsetzung gezeigt werden und
 zudem auch ein Vergleich verschiedenster aktueller GPUs und CPUs angestellt
 werden.
 
\end_layout

\begin_layout Standard

\size huge
Institutsvortrag Erklärungen nehmen !!!
\end_layout

\begin_layout Standard
General Purpose Computation on Graphics Processing Unit blablabla#
\end_layout

\begin_layout Standard
Blocked Algorithmus
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="17" columns="9">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 GFlops (double FMA)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cores
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Base/AVX Clock
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AVX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Straßenpreis (8.8.2016)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
max.
 Leistung
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Watt/GFlop
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GFlops/Euro
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gold 5120
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gold 6148
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gold 6152
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gold 6154
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18*2,1*32=1209GFlops
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3/2,1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
512(FMA)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Platinum 8168
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24*1,9*32=1459GFlops
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,7/1,9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
512(2xFMA)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Platinum 8180
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28*1.7*32=1523Gflops
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,5/1,7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
512(2xFMA)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Platinum 8160
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24*1.4*32=1075Gflops
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,1/1,4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
512(2xFMA)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Platinum 8176
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E7-8890v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
844.8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7600€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
165W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.195
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.111
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E5-4669v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
774.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7500€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
135W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.174
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.103
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E5-2699v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
662.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3830€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
145W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.219
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.173
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E5-2698v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
588.8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3000€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
135W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.229
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.196
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E5-2650v4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
422.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1200€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
105W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.249
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.352
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E5-2650v3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
368
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1200€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
105W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.285
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.307
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E5-2695v2 (Cluster)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
230.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2100€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
115W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.11
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E5-2620v2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100.8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
sdfgsdf
\end_layout

\begin_layout Standard
sdf
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="8">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 GFlops (double FMA)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Straßenpreis (8.8.2016)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPU RAM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GB/s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
max.
 Leistung
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Watt/GFlop
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GFlops/Euro
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tesla P100 NVLink
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unbekannt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16GB (HBM)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
720
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.057
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unbekannt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tesla P100 PCIe
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4700
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7300€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16GB (HBM)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
720
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
250W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.053
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.64
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tesla K80
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1863(@BaseClock 560MHz), 2912@BoostClock(875MHz)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5800€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24GB (DDR5)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2x288
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.103
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tesla K40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1430
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4400€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12GB (DDR5)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
288
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
235W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.164
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.325
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quadro K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1732@901Mhz, 1152@600Mhz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5000€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12GB (DDR5)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
288
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
225W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
~0.17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.286-0.23
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GTX1080
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
277
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
800€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12GB (DDR5)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
320
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
180W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.65
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.347
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Intel
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="8">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 GFlops (double FMA)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Straßenpreis (8.8.2016)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPU RAM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GB/s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
max.
 Leistung
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Watt/GFlop
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GFlops/Euro
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7290*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3456
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6800€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16GB 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
490
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
245W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.071
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.508
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7250
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3046
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5400€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16GB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
490
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
215W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0706
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.56
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7120
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1210
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4000€
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16GB (DDR4)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
352
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
300W
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.248
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.30
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
72xx = (KnightsLanding)
\end_layout

\begin_layout Standard
71xx = KnightsCorner
\end_layout

\begin_layout Standard
K80 = 2 GPUs erwähnen 
\end_layout

\begin_layout Subsection
GPU Resourcenverteilung bei parallelen Trainings
\end_layout

\begin_layout Enumerate
Nur GPUs aufteilen, da CPUs immer identisch sind und die GPUs auch CPU Anteile
 verwenden die immer gleich sind von der Berechnung her.
\end_layout

\begin_layout Enumerate
Speicher auf den GPUs checken und schauen wieviele Krigings maximal auf
 eine GPU gehen.
 Damit wird der jeweilige Anteil limitiert.
\end_layout

\begin_layout Enumerate
Anteil berechnen
\end_layout

\begin_deeper
\begin_layout Enumerate
Abhängig von der Matrixgröße (Aufteilung über GFlops sinnvoll)
\end_layout

\begin_layout Enumerate
Abhängig von der Anzahl der gleichzeitigen Trainings
\end_layout

\end_deeper
\begin_layout Standard
2.
\end_layout

\begin_layout Standard
Der Speicherbedarf in Megabyte pro Matrix liegt bei 
\begin_inset Formula $\frac{64Bit*n^{2}}{8*1024*2014}=r$
\end_inset

.
 Während eines Trainings werden maximal 2 dieser Matrizen auf einer GPU
 allokiert.
 
\end_layout

\begin_layout Standard
Scheduler, Resourcenverteilung, verschiedene Resourcen, passt alles in den
 RAM
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainings
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anteil GTX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anteil K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 Time GTX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 Time K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
156s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
156s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
130s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
143s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
143s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
133s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
132s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
133s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
191s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
128s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
191s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
133s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
133s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
113s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
121s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
121s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
122s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
119s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
122s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
187s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
113s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
187s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
96s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
96s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
101s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
85s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
101s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
142s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
83s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
142s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
178s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
82s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
178s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
72s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
72s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
98s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
71s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
98s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
123s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
66s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
123s
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Benchmark der besten Verteilung mehrerer Trainings mit 5000 Samples auf
 2 verschiedene GPUs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
1000x1000
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainings
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anteil GTX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anteil K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 Time GTX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 Time K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.5s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.8s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.8s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.8s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5s
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Benchmark der besten Verteilung mehrerer Trainings mit 1000 Samples auf
 2 verschiedene GPUs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
500x500
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="19" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Trainings
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anteil GTX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anteil K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 Time GTX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Max.
 Time K6000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17.7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.1s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12.31s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11.3s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.8s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10.5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7.7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.5s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.9s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.1s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.1s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.2s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.7s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.4s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Benchmark der besten Verteilung mehrerer Trainings mit 1000 Samples auf
 2 verschiedene GPUs
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Analysesoftware von Krigingmodellen während der Laufzeit
\end_layout

\begin_layout Standard
Khon.py beschreiben
\end_layout

\begin_layout Subsection
Hyperparameter aus zusammengesetzten Kovarianzfunktionen plotten 
\end_layout

\begin_layout Standard
Angenommen alle Parameter außer dem betrachteten Parameter spielen keine
 Rolle, dann vereinfacht sich die Gauss-Korrelations-Formel zu:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
cov\left(x_{1},x_{2}\right)=a^{2}*\sigma_{l}^{2}*e^{-e^{\theta_{l}}\left|x_{1}-x_{2}\right|^{2}}+\sigma_{err}^{2}*e^{-e^{\theta_{err}}\left|x_{1}-x_{2}\right|^{2}}
\]

\end_inset


\end_layout

\begin_layout Standard
Nimmt man weiterhin an, dass der Abstand 
\begin_inset Formula $\left|x_{1}-x_{2}\right|=1$
\end_inset

 ist, vereinfacht sich die Formel weiter.
 Diese Annahme ist in der hier verwendeten Implementierung sinnvoll, da
 alle Koordinaten auf einen Erwartungswert von 0 und eine Standardabweichung
 von 1 normiert wurden.
 
\begin_inset Formula 
\[
cov\left(x_{1},x_{2}\right)=a^{2}*\sigma_{l}^{2}*e^{-e^{\theta_{l}}}+\sigma_{err}^{2}*e^{-e^{\theta_{err}}}
\]

\end_inset


\end_layout

\begin_layout Standard
Die Gesamtvarianz des Modells liegt bei:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\sigma_{ges}^{2}=a^{2}*\sigma_{l}^{2}+\sigma_{err}^{2}
\]

\end_inset


\end_layout

\begin_layout Standard
Die Korrelation wird hier als sinnvolleres Maß als die Kovarianz angesehen,
 da der Wertebereich bekannt ist.
 Die Korrelation ergibt sich wie folgt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
corr_{ges}\left(x_{1},x_{2}\right)=\frac{cov\left(x_{1},x_{2}\right)}{\sigma_{ges}^{2}}=\frac{a^{2}*\sigma_{l}^{2}*e^{-e^{\theta_{l}}}+\sigma_{err}^{2}*e^{-e^{\theta_{err}}}}{a^{2}*\sigma_{l}^{2}+\sigma_{err}^{2}}
\]

\end_inset


\end_layout

\begin_layout Standard
Mit dieser Formel hat man eine Abschätzung für einen zusammengefassten Hyperpara
meter, dieser ermöglicht z.B.
 Diagramme usw.
 
\end_layout

\begin_layout Section
Umsetzung der Entscheidungsfunktion 
\begin_inset CommandInset label
LatexCommand label
name "chap:Entscheidungsfunktion"

\end_inset


\end_layout

\begin_layout Standard
Die Annahmen klären Ersatzmodelle nicht neu trainieren jedesmal.
 bestimmung der Sigmas durch Bedingte Varianzvorhersage usw.
\end_layout

\begin_layout Subsubsection*
Benutzergesteuerte Entscheidungsfunktionen
\end_layout

\begin_layout Standard
Vorgabe einer Wahrscheinlichkeitsfunktion
\end_layout

\begin_layout Subsection*
\begin_inset Note Note
status collapsed

\begin_layout Subsection*
Cholesky Zerlegung
\begin_inset CommandInset label
LatexCommand label
name "subsec:Cholesky-Zerlegung"

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
Die Methode chodec() stellt eine Cholesky Zerlegung für positiv definite
 und symmetrische Matrizen bereit, für die Matrix 
\begin_inset Formula $\mathbf{R}$
\end_inset

 muss also gelten:
\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Formula 
\begin{align*}
\mathbf{R}=\mathbf{R}^{T}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
und 
\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Formula 
\begin{align*}
\mathbf{\overrightarrow{v}*R*\overrightarrow{v}}>0 & \,\,für\,alle\,Vektoren\,\overrightarrow{v}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
Bei der Cholesky Zerlegung wird die Matrix 
\begin_inset Formula $\mathbf{R}$
\end_inset

 in ein Produkt aus einer unteren Dreicksmatrix und deren Transponierten
 zerlegt:
\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Formula 
\begin{align*}
\mathbf{L}\mathbf{L}^{T} & =\mathbf{R}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
Die Zerlegung kann nun verwendet werden, um durch Vor- und Rückwärtseinsetzen
 lineare Gleichungssysteme in der Form 
\begin_inset Formula $\mathbf{R}\overrightarrow{x}=b$
\end_inset

 zu lösen.
 Hierfür wird zuerst vorwärts eingesetzt:
\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Formula 
\begin{align*}
\mathbf{L}\overrightarrow{y} & =\overrightarrow{b}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
und dann durch Rückwärtseinsetzen kann der gesuchte Vektor 
\begin_inset Formula $\overrightarrow{x}$
\end_inset

 erhalten werden: 
\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Formula 
\begin{align*}
\mathbf{L}^{T}\overrightarrow{x} & =\overrightarrow{y}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
\Longrightarrow & \mathbf{R}\overrightarrow{x}=\mathbf{L}\mathbf{L}^{T}\overrightarrow{x}=\mathbf{L}\overrightarrow{y}=\overrightarrow{b}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
ersetzt man nun 
\begin_inset Formula $\overrightarrow{x}$
\end_inset

 durch 
\begin_inset Formula $\mathbf{R}^{-1}$
\end_inset

 und 
\begin_inset Formula $\overrightarrow{b}$
\end_inset

 durch die Einheitsmatrix 
\begin_inset Formula $\mathbf{E}$
\end_inset

, kann man mit der Zerlegung die Inverse der Matrix 
\begin_inset Formula $\mathbf{R}$
\end_inset

 berechnen.
 
\end_layout

\begin_layout Plain Layout
\noindent
Nach diesem Schritt können die Vor- und Rückwärtssubstitutionen spaltenweise
 durchgeführt werden.
 Diese lassen sich sehr gut parallelisieren, da jede CPU einfach einen Vektor
 der Inversen berechnet.
\end_layout

\begin_layout Plain Layout
\noindent
Ein weiterer Vorteil der Zerlegung ist, dass die Determinante der Matrix
 
\begin_inset Formula $\mathbf{R}$
\end_inset

 mit der Zerlegung einfach durch Multiplikation der Diagonalelemente der
 zerlegten Matrix gewonnen werden kann:
\end_layout

\begin_layout Plain Layout
\noindent
\begin_inset Formula 
\begin{align*}
det\left(\mathbf{R}\right) & =\overset{n}{\underset{i=1}{\prod}}L_{i,i}^{2}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
Der verwendete Algorithmus ist in 
\begin_inset CommandInset citation
LatexCommand citet
key "press2007numerical,gill2007numerical"

\end_inset

 nochmals detaillierter beschrieben.
\end_layout

\begin_layout Subsection*
Quadratische Form
\end_layout

\begin_layout Plain Layout
Da bei dem Training eines Kriging Modells häufig quadratische Formen 
\begin_inset Formula $\vec{v^{T}}R\vec{v}$
\end_inset

 berechnet werden müssen, lohnt es sich diese zu beschleunigen.
 Dies wird dadurch gemacht, dass die Multiplikationen nicht nacheinander
 durchgeführt werden, sondern beide Multiplikationen in einer doppel-Schleife
 behandelt werden.
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
\overset{n}{\underset{i=1}{\sum}}\left(v_{i}\overset{n}{\underset{j=1}{\sum}}R_{i,j}*v_{j}\right) & =\vec{v}^{T}R\vec{v}
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
Der Algorithmus ist im folgenden Listing gezeigt:
\end_layout

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\footnotesize}"
inline false
status open

\begin_layout Plain Layout

#pragma omp parallel for reduction(+:ret)
\end_layout

\begin_layout Plain Layout

for(size_t row=0; row < matrix->getRowSize(); row++){
\end_layout

\begin_layout Plain Layout

	double sum=0.;
\end_layout

\begin_layout Plain Layout

	for(size_t col=0; col < matrix->getColumnSize(); col++){
\end_layout

\begin_layout Plain Layout

		sum += matrix[row][col] * vec[col];
\end_layout

\begin_layout Plain Layout

	} 			
\end_layout

\begin_layout Plain Layout

	sum *= vec[row];
\end_layout

\begin_layout Plain Layout

	result +=sum;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
In der ersten Zeile wird eine Schleifenparallelisierung über OpenMP initialisier
t, wobei das Aufsummieren von result nicht parallelisiert werden darf.
 Dies würde sonst zu unvorhersehbaren Fehlern führen, da mehrere Threads
 gleichzeitig in die Variable result schreiben möchten.
 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
